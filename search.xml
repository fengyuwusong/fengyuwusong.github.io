<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从事务到分布式事务</title>
      <link href="/2022/08/26/%E4%BB%8E%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/08/26/%E4%BB%8E%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>CAP理论是分布式系统、特别是分布式存储领域中被讨论的最多的理论。其中C代表一致性 (Consistency)，A代表可用性 (Availability)，P代表分区容错性 (Partition tolerance)。CAP理论告诉我们C、A、P三者不能同时满足，最多只能满足其中两个。</p><p><img src="https://pdai.tech/_images/arch/arch-cap-1.png" alt="cap描述"></p><ul><li>Consistency（一致性）一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。所有节点访问同一份最新的数据。</li><li>Availability（可用性）对数据更新具备高可用性，请求能够及时处理，不会一直等待，即使出现节点失效。</li><li>Partition tolerance（分区性容错性）能容忍网络分区，在网络断开的情况下，被分隔的节点仍能正常对外提供服务。</li></ul><h5 id="思考题：对CAP的理解（为什么只能满足两个？）"><a href="#思考题：对CAP的理解（为什么只能满足两个？）" class="headerlink" title="思考题：对CAP的理解（为什么只能满足两个？）"></a>思考题：对CAP的理解（为什么只能满足两个？）</h5><p>假设放弃P，考虑CA。</p><h5 id="现有系统符合的种类"><a href="#现有系统符合的种类" class="headerlink" title="现有系统符合的种类"></a>现有系统符合的种类</h5><p>CA: 不需要分区的数据库（单机mysql、mongo等）<br>CP: 需要分区和强一致性而放弃了可用性的系统（ACID强事务型数据库）<br>AP: 需要分区和高可用而放弃了可用性的系统（非事务型数据库、大多数互联网应用）</p><h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><p><img src="https://pdai.tech/_images/arch/arch-cap-2.png" alt="base 描述"></p><ul><li>Basically Available（基本可用）分布式系统在出现不可预知故障的时候，允许损失部分可用性</li><li>Soft state（软状态）软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</li><li>Eventually consistent（最终一致性）最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</li></ul><p>BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），更具体地说，<strong>是对 CAP 中 AP 方案的一个补充</strong>。<br>其基本思路就是：通过业务，牺牲强一致性而获得可用性，并允许数据在一段时间内是不一致的，但是最终达到一致性状态。</p><h4 id="数据库事务定义"><a href="#数据库事务定义" class="headerlink" title="数据库事务定义"></a>数据库事务定义</h4><p>把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul><li>Atomicity（原子性）：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</li><li>Consistency（一致性）：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</li><li>Isolation（隔离性）：一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li><li>Durability（持久性）：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li></ul><p><img src="https://camo.githubusercontent.com/d688683e3f6fb14d059412247e4f427a7cd1aa7686417bc552e061628f24dd84/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231303433373032332e706e67" alt="enter image description here"></p><h5 id="思考题：如何实现原子性和持久性的回滚和丢失恢复？"><a href="#思考题：如何实现原子性和持久性的回滚和丢失恢复？" class="headerlink" title="思考题：如何实现原子性和持久性的回滚和丢失恢复？"></a>思考题：如何实现原子性和持久性的回滚和丢失恢复？</h5><p>Undo Log、Redo Log</p><h4 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h4><ul><li>丢失修改</li><li>读脏数据</li><li>不可重复读</li><li>幻影读</li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src="https://camo.githubusercontent.com/1632a88a3a4fa7954026cb939edf2f8a30bb5d60a1bce4921c7e0d0e4d245739/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232333430303738372e706e67" alt="enter image description here"></p><h4 id="不同隔离级别实现原理"><a href="#不同隔离级别实现原理" class="headerlink" title="不同隔离级别实现原理"></a>不同隔离级别实现原理</h4><p>未提交读：一直读最新数据<br>提交读、可重复读：MVCC<br>可串行化隔离级别需要对所有读取的行都加锁（Next-Key Locks），单纯使用 MVCC 无法实现。</p><h5 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h5><p>TODO</p><h5 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h5><p>TODO</p><h4 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h4><ul><li>读写锁、意向锁： TODO</li><li>封锁协议：TODO</li></ul><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>本地事务是指仅操作单一事务资源的、不需要全局事务管理器进行协调的事务。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>数据库本身支持事务。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>单个服务使用单个数据源的场景。<br>例如最简单的单机单数据源多表转账服务。</p><h3 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>与本地事务相对的是全局事务（Global Transaction）<br>全局事务被限定为一种适用于单个服务使用多个数据源场景的事务解决方案。</p><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li>思考题：以下代码有什么问题？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyBook</span><span class="params">(PaymentBill bill)</span> </span>&#123;</span><br><span class="line">    userTransaction.begin();</span><br><span class="line">    warehouseTransaction.begin();</span><br><span class="line">    businessTransaction.begin();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        userAccountService.pay(bill.getMoney());</span><br><span class="line">        warehouseService.deliver(bill.getItems());</span><br><span class="line">        businessAccountService.receipt(bill.getMoney());</span><br><span class="line">        userTransaction.commit();</span><br><span class="line">        warehouseTransaction.commit();</span><br><span class="line">        businessTransaction.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        userTransaction.rollback();</span><br><span class="line">        warehouseTransaction.rollback();</span><br><span class="line">        businessTransaction.rollback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h5><p>XA是由X/Open组织提出的分布式事务的规范，XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如mysql在XA中扮演的是RM角色。</p><h5 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h5><p><img src="https://www.dtm.pub/assets/xa_normal.5a0ce600.jpg" alt="enter image description here"></p><p><strong>准备阶段</strong>：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。这里所说的准备操作跟人类语言中通常理解的准备并不相同，对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。<br><strong>提交阶段</strong>：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载的操作。</p><ul><li>2PC存在的问题<ul><li>单点问题</li><li>性能问题</li><li>一致性风险</li></ul></li></ul><h5 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h5><p>增加CanCommit询问阶段，增加成功概率，一定程度解决单点和性能问题。</p><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/20220826160139.png" alt="enter image description here"></p><h3 id="共享事务"><a href="#共享事务" class="headerlink" title="共享事务"></a>共享事务</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>共享事务（Share Transaction）是指多个服务共用同一个数据源。</p><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li>多个服务共享数据库链接（新增应用用于串行化执行多个微服务对于数据库的操作）</li><li>使用消息队列</li><li>分布式锁</li></ul><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>目前软总线服务上多个微服务同时读写设备表。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><ul><li>思考题：以下流程存在什么问题？</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/20220826161614.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">场景事例</span><br><span class="line"></span><br><span class="line">Fenix&#39;s Bookstore 是一个在线书店。每当一本书被成功售出时，需要确保以下三件事情被正确地处理：</span><br><span class="line"></span><br><span class="line">用户的账号扣减相应的商品款项。</span><br><span class="line">商品仓库中扣减库存，将商品标识为待配送状态。</span><br><span class="line">商家的账号增加相应的商品款项。</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/20220826162159.png" alt=""></p><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>多个服务同时访问多个数据源的事务处理机制，目前仅支持柔性事务。</p><ul><li>刚性事务：达到实现强一致性的事务（目前无法实现，具体参考：<a href="https://www.dtm.pub/practice/theory.html#%E6%97%A0%E6%B3%95%E5%BC%BA%E4%B8%80%E8%87%B4" target="_blank" rel="noopener">https://www.dtm.pub/practice/theory.html#%E6%97%A0%E6%B3%95%E5%BC%BA%E4%B8%80%E8%87%B4</a>）</li><li>柔性事务：达到实现最终一致性的事务</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>最大努力交付/通知（接收方保证一致性）</li><li>本地/事务消息表消息表（消息队列保证）</li><li>AT</li><li>XA</li><li>二阶段消息</li><li>Workflow</li><li>SAGA</li><li>TCC</li></ul><h5 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h5><p><img src="https://dtm.pub/assets/local_msg_table.089f1fd3.jpg" alt="enter image description here"></p><h5 id="SAGA"><a href="#SAGA" class="headerlink" title="SAGA"></a>SAGA</h5><p><img src="https://dtm.pub/assets/saga_normal.a2849672.jpg" alt="enter image description here"></p><h5 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h5><p><img src="https://dtm.pub/assets/tcc_normal.dea14fb3.jpg" alt="enter image description here"></p><h5 id="XA-1"><a href="#XA-1" class="headerlink" title="XA"></a>XA</h5><p><img src="https://dtm.pub/assets/xa_normal.5a0ce600.jpg" alt="enter image description here"></p><h5 id="二阶消息"><a href="#二阶消息" class="headerlink" title="二阶消息"></a>二阶消息</h5><p><img src="https://dtm.pub/assets/msg_normal.25a4cb15.jpg" alt="enter image description here"></p><h4 id="如何选择合适的模式"><a href="#如何选择合适的模式" class="headerlink" title="如何选择合适的模式"></a>如何选择合适的模式</h4><ul><li>二阶段消息模式: 适合不需要回滚的场景</li><li>saga模式: 适合需要回滚的场景</li><li>tcc事务模式: 适合一致性要求较高的场景</li><li>xa事务模式: 适合并发要求不高，没有数据库行锁争抢的场景</li></ul><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p><a href="https://dtm.pub/app/intro.html" target="_blank" rel="noopener">https://dtm.pub/app/intro.html</a></p><h4 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h4><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><ul><li>网络延迟</li><li>进程暂停</li><li>时钟漂移</li></ul><h5 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h5><ul><li>空补偿</li><li>悬挂</li><li>幂等</li></ul><p><img src="https://www.dtm.pub/assets/exception.4254ab59.jpg" alt="enter image description here"></p><h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p><a href="https://www.dtm.pub/practice/barrier.html" target="_blank" rel="noopener">https://www.dtm.pub/practice/barrier.html</a></p><h5 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h5><p><a href="https://github.com/nivin-studio/go-zero-mall" target="_blank" rel="noopener">https://github.com/nivin-studio/go-zero-mall</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>凤凰架构：<a href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/" target="_blank" rel="noopener">http://icyfenix.cn/architect-perspective/general-architecture/transaction/</a><br>数据库系统原理：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E4%B8%80%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E4%B8%80%E4%BA%8B%E5%8A%A1</a><br>DTM官网：<a href="https://www.dtm.pub/" target="_blank" rel="noopener">https://www.dtm.pub/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 事务 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang垃圾回收</title>
      <link href="/2022/05/18/Golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2022/05/18/Golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="垃圾回收是什么？"><a href="#垃圾回收是什么？" class="headerlink" title="垃圾回收是什么？"></a>垃圾回收是什么？</h3><p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。</p><h3 id="Go-V1-3之前的标记-清除-mark-and-sweep-算法"><a href="#Go-V1-3之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="Go V1.3之前的标记-清除(mark and sweep)算法"></a>Go V1.3之前的标记-清除(mark and sweep)算法</h3><ol><li>暂停程序，分析当前程序可达的对象</li><li>对于所有可达的对象做上标记</li><li>清除未标记的对象</li><li>停止暂停，程序业务逻辑继续运行，然后重复该过程。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>stw：gc时程序需要暂停</li><li>标记需要扫描整个heap</li><li>清楚数据会产生heap碎片</li></ol><p>gov1.3版本将步骤4提前到步骤3，即sweep清楚时，并不需要暂停整个程序</p><h3 id="Go-V1-5的三色并发标记法"><a href="#Go-V1-5的三色并发标记法" class="headerlink" title="Go V1.5的三色并发标记法"></a>Go V1.5的三色并发标记法</h3><ol><li>每次新创建的对象，默认的颜色都是标记为“白色”</li><li>每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合【遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层】</li><li>遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合【遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层】</li><li>重复第三步, 直到灰色中无任何对象</li><li>回收所有白色对象</li></ol><h4 id="没STW的三色标记法"><a href="#没STW的三色标记法" class="headerlink" title="没STW的三色标记法"></a>没STW的三色标记法</h4><p>当三色标记法同时出现以下两种情况时，会出现对象丢失：</p><ol><li>一个白色对象被黑色对象引用(白色被挂在黑色下)</li><li>灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)</li></ol><h4 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h4><p>为了避免不使用STW，同时不存在对象丢失的情况，于是设计了屏障机制。</p><p>通过上述描述发现，当GC回收期满足以下两种情形之一时，即可不丢失对象。</p><ul><li>“强-弱” 三色不变式<ol><li>强三色不变式：不存在黑色对象引用到白色对象的指针。</li><li>弱三色不变式：所有被黑色对象引用的白色对象都处于灰色保护状态。【灰色对象直接引用或它的链路上游存在灰色对象】</li></ol></li></ul><p>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们分别是：“插入屏障”, “删除屏障”。</p><ul><li>插入屏障</li></ul><p>具体操作：当黑色对象引用白色对象时，白色对象被标记为灰色。<br>满足：强三色不变式</p><p>伪代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">  标记灰色(新下游对象ptr)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景：</p><ol><li>黑色对象直接添加下游对象</li><li>黑色对象替换下游引用对象</li></ol><p>适用情况：<br>这段伪码逻辑就是写屏障, 黑色对象的内存槽有两种位置, 栈和堆.<br>栈空间的特点是容量小, 但是要求相应速度快, 因此栈空间内并不使用，仅适用于堆</p><ul><li>删除屏障</li></ul><p>具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。<br>满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)</p><p>伪代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot， 新下游对象ptr) &#123;</span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">  <span class="keyword">if</span> (当前下游对象slot是灰色 || 当前下游对象slot是白色) &#123;</span><br><span class="line">    标记灰色(当前下游对象slot)     <span class="comment">//slot为被删除对象， 标记为灰色</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景：</p><ol><li>A.添加下游对象(B, nil)   //A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)</li><li>A.添加下游对象(B, C)     //A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)</li></ol><p>适用情况：<br>一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p><h4 id="插入写屏障和删除写屏障的短板"><a href="#插入写屏障和删除写屏障的短板" class="headerlink" title="插入写屏障和删除写屏障的短板"></a>插入写屏障和删除写屏障的短板</h4><ul><li>插入写屏障：<strong>结束时需要STW来重新扫描栈</strong>，标记栈上引用的白色对象的存活；</li><li>删除写屏障：回收精度低，<strong>GC开始时STW扫描堆栈来记录初始快照</strong>，这个过程会保护开始时刻的所有存活对象。</li></ul><h3 id="Go-V1-8-混合写屏障"><a href="#Go-V1-8-混合写屏障" class="headerlink" title="Go V1.8 混合写屏障"></a>Go V1.8 混合写屏障</h3><p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p><h4 id="混合写屏障规则"><a href="#混合写屏障规则" class="headerlink" title="混合写屏障规则"></a>混合写屏障规则</h4><ul><li>具体操作</li></ul><p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)<br>2、GC期间，任何在栈上创建的新对象，均为黑色。<br>3、被删除的对象标记为灰色。<br>4、被添加的对象标记为灰色。</p><p>满足: 变形的弱三色不变式.</p><ul><li>伪代码</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">   <span class="comment">//1 </span></span><br><span class="line">  标记灰色(当前下游对象slot)    <span class="comment">//只要当前下游对象被移走，就标记灰色</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2 </span></span><br><span class="line">   标记灰色(新下游对象ptr)</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//3</span></span><br><span class="line">   当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意点</li></ul><p><strong>屏障技术是不在栈上应用的，因为要保证栈的运行效率</strong></p><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ol><li>对象被一个堆对象删除引用，成为栈对象的下游【堆对象删除引用置为灰】</li><li>对象被一个栈对象删除引用，成为另一个栈对象的下游【栈对象删除引用，不变色】</li><li>对象被一个堆对象删除引用，成为另一个堆对象的下游【堆对象删除引用、被另一个堆对象添加引用，置为灰】</li><li>对象从一个栈对象删除引用，成为另一个堆对象的下游【栈对象本身为黑，堆对象转移引用，删除引用的堆对象置为灰】</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Golang中的混合写屏障满足弱三色不变式，结合了删除写屏障和插入写屏障的优点，<strong>只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后添加的对象始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间</strong>。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p><p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通。</p><p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.yuque.com/aceld/golang/zhzanb" target="_blank" rel="noopener">Golang三色标记混合写屏障GC模式全分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prometheus学习笔记</title>
      <link href="/2022/05/12/prometheus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/12/prometheus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Markmap</title><style>* {  margin: 0;  padding: 0;}# mindmap {  display: block;  width: 100vw;  height: 100vh;}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.13.2/dist/style.css"><meta name="generator" content="Hexo 4.2.0"></head><body><svg id="mindmap"></svg><script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.13.2"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.13.2/dist/index.umd.min.js"></script><script>(r => {                setTimeout(r);              })(() => {  const {    markmap,    mm  } = window;  const toolbar = new markmap.Toolbar();  toolbar.attach(mm);  const el = toolbar.render();  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');  document.body.append(el);})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {        const markmap = getMarkmap();        window.mm = markmap.Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(markmap, jsonOptions), root);      })(() => window.markmap,(markmap, jsonOptions) => markmap.deriveOptions(jsonOptions),{"type":"heading","depth":1,"payload":{"lines":[1,2]},"content":"prometheus相关实践","children":[{"type":"heading","depth":2,"payload":{"lines":[3,4]},"content":"docker部署prometheus和grafana","children":[{"type":"heading","depth":3,"payload":{"lines":[5,6]},"content":"启动node-exporter","children":[{"type":"fence","depth":4,"content":"<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> run -d -p <span class=\"token number\">9100</span>:9100 <span class=\"token punctuation\">\\</span>\n --name node-exporter <span class=\"token punctuation\">\\</span>\n --restart<span class=\"token operator\">=</span>always  <span class=\"token punctuation\">\\</span>\n -v /data/apps/docker/node-exporter-data/proc:/host/proc:ro <span class=\"token punctuation\">\\</span>\n -v /data/apps/docker/node-exporter-data/sys:/host/sys:ro <span class=\"token punctuation\">\\</span>\n -v /data/apps/docker/node-exporter-data:/rootfs:ro <span class=\"token punctuation\">\\</span>\n prom/node-exporter\n</code></pre>\n"}]},{"type":"heading","depth":3,"payload":{"lines":[17,18]},"content":"编写prometheus.yml","children":[{"type":"fence","depth":4,"content":"<pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">global</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">scrape_interval</span><span class=\"token punctuation\">:</span> 60s\n  <span class=\"token key atrule\">evaluation_interval</span><span class=\"token punctuation\">:</span> 60s\n\n<span class=\"token key atrule\">scrape_configs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">job_name</span><span class=\"token punctuation\">:</span> prometheus\n    <span class=\"token key atrule\">static_configs</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">targets</span><span class=\"token punctuation\">:</span>\n          <span class=\"token punctuation\">-</span> 192.168.0.104<span class=\"token punctuation\">:</span><span class=\"token number\">9090</span>\n\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">job_name</span><span class=\"token punctuation\">:</span> node<span class=\"token punctuation\">-</span>exporter\n    <span class=\"token key atrule\">static_configs</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">targets</span><span class=\"token punctuation\">:</span>\n          <span class=\"token punctuation\">-</span> 192.168.0.104<span class=\"token punctuation\">:</span><span class=\"token number\">9100</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">job_name</span><span class=\"token punctuation\">:</span> jenkins\n    <span class=\"token key atrule\">scheme</span><span class=\"token punctuation\">:</span> http\n    <span class=\"token key atrule\">metrics_path</span><span class=\"token punctuation\">:</span> prometheus\n    <span class=\"token key atrule\">bearer_token</span><span class=\"token punctuation\">:</span> bearer_token\n    <span class=\"token key atrule\">static_configs</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">targets</span><span class=\"token punctuation\">:</span>\n          <span class=\"token punctuation\">-</span> 192.168.57.242<span class=\"token punctuation\">:</span><span class=\"token number\">8080</span>\n</code></pre>\n"}]},{"type":"heading","depth":3,"payload":{"lines":[43,44]},"content":"启动promethus","children":[{"type":"fence","depth":4,"content":"<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> run -d <span class=\"token punctuation\">\\</span>\n --name prometheus <span class=\"token punctuation\">\\</span>\n --restart<span class=\"token operator\">=</span>always <span class=\"token punctuation\">\\</span>\n -u root <span class=\"token punctuation\">\\</span>\n -p <span class=\"token number\">9090</span>:9090 <span class=\"token punctuation\">\\</span>\n -v /data/apps/docker/prometheus-data/prometheus.yml:/etc/prometheus/prometheus.yml <span class=\"token punctuation\">\\</span>\n -v /data/apps/docker/prometheus-data:/prometheus <span class=\"token punctuation\">\\</span>\n -v /data/apps/docker/prometheus-data/conf:/etc/prometheus/conf <span class=\"token punctuation\">\\</span>\n prom/prometheus --web.enable-lifecycle\n</code></pre>\n"}]},{"type":"heading","depth":3,"payload":{"lines":[57,58]},"content":"启动grafana","children":[{"type":"fence","depth":4,"content":"<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> run -d <span class=\"token punctuation\">\\</span>\n -p <span class=\"token number\">3000</span>:3000 <span class=\"token punctuation\">\\</span>\n --restart<span class=\"token operator\">=</span>always <span class=\"token punctuation\">\\</span>\n --name<span class=\"token operator\">=</span>grafana <span class=\"token punctuation\">\\</span>\n -u root <span class=\"token punctuation\">\\</span>\n -v /data/apps/docker/grafana-data:/var/lib/grafana <span class=\"token punctuation\">\\</span>\n grafana/grafana\n</code></pre>\n"}]}]},{"type":"heading","depth":2,"payload":{"lines":[71,72]},"content":"Metric指标","children":[{"type":"heading","depth":3,"payload":{"lines":[73,74]},"content":"数据模型","children":[{"type":"list_item","depth":5,"payload":{"lines":[79,80]},"content":"指标名和指标标签集合：metric_name{&lt;label1=v1&gt;,&lt;label2=v2&gt;....}，指标名：表示这个指标是监控哪一方面的状态，比如 http_request_total 表示：请求数量；指标标签，描述这个指标有哪些维度，比如 http_request_total 这个指标，有请求状态码 code = 200/400/500，请求方式：method = get/post 等，实际上指标名称实际上是以标签的形式保存，这个标签是name，即：name=。"},{"type":"list_item","depth":5,"payload":{"lines":[80,81]},"content":"时间戳：描述当前时间序列的时间，单位：毫秒。"},{"type":"list_item","depth":5,"payload":{"lines":[81,82]},"content":"样本值：当前监控指标的具体数值，比如 http_request_total 的值就是请求数是多少。"}]},{"type":"heading","depth":3,"payload":{"lines":[83,84]},"content":"指标类型","children":[{"type":"list_item","depth":5,"payload":{"lines":[85,86]},"content":"Counter 计数器"},{"type":"list_item","depth":5,"payload":{"lines":[86,87]},"content":"Gauge 仪表盘"},{"type":"list_item","depth":5,"payload":{"lines":[87,88]},"content":"Histogram 直方图"},{"type":"list_item","depth":5,"payload":{"lines":[88,89]},"content":"Summary 摘要"}]}]},{"type":"heading","depth":2,"payload":{"lines":[90,91]},"content":"PromQL","children":[{"type":"bullet_list","depth":3,"payload":{"lines":[94,99]},"content":"","children":[{"type":"list_item","depth":4,"payload":{"lines":[94,95]},"content":"字符串：只作为某些内置函数的参数出现"},{"type":"list_item","depth":4,"payload":{"lines":[95,96]},"content":"标量：单一的数字值，可以是函数参数，也可以是函数的返回结果"},{"type":"list_item","depth":4,"payload":{"lines":[96,97]},"content":"瞬时向量：某一时刻的时序数据"},{"type":"list_item","depth":4,"payload":{"lines":[97,98]},"content":"区间向量：某一时间区间内的时序数据集合"}]},{"type":"heading","depth":3,"payload":{"lines":[99,100]},"content":"瞬时查询","children":[{"type":"fence","depth":4,"content":"<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># 直接查询</span>\ngo_gc_duration_seconds_count\n<span class=\"token comment\"># 筛选</span>\ngo_gc_duration_seconds_count<span class=\"token punctuation\">{</span>instance<span class=\"token operator\">=</span><span class=\"token string\">\"127.0.0.1:9600\"</span><span class=\"token punctuation\">}</span>\n<span class=\"token comment\"># 正则</span>\ngo_gc_duration_seconds_count<span class=\"token punctuation\">{</span>instance<span class=\"token operator\">=~</span><span class=\"token string\">\"localhost.*\"</span><span class=\"token punctuation\">}</span>\n</code></pre>\n"}]},{"type":"heading","depth":3,"payload":{"lines":[112,113]},"content":"范围查询","children":[{"type":"fence","depth":4,"content":"<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># d：天，h：小时，m：分钟，ms：毫秒，s：秒，w：周，y：年</span>\ngo_gc_duration_seconds_count<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span>5m<span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 偏移</span>\ngo_gc_duration_seconds_count<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span>5m<span class=\"token punctuation\">]</span> offset 1d\n</code></pre>\n"}]},{"type":"heading","depth":3,"payload":{"lines":[123,124]},"content":"内置函数","children":[{"type":"heading","depth":4,"payload":{"lines":[125,126]},"content":"rate","children":[{"type":"fence","depth":5,"content":"<pre class=\"language-shell\"><code class=\"language-shell\">rate函数<span class=\"token operator\">=</span>时间区间前后两个点的差 / 时间范围\n</code></pre>\n"},{"type":"fence","depth":5,"content":"<pre class=\"language-shell\"><code class=\"language-shell\">rate<span class=\"token punctuation\">(</span>demo_api_request_duration_seconds_count<span class=\"token punctuation\">[</span>1m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>/60\n</code></pre>\n"}]},{"type":"heading","depth":4,"payload":{"lines":[141,142]},"content":"irate","children":[{"type":"fence","depth":5,"content":"<pre class=\"language-shell\"><code class=\"language-shell\">irate <span class=\"token operator\">=</span> 时间区间内最后两个样本点的差 / 最后两个样本点的时间差\n</code></pre>\n"}]},{"type":"heading","depth":4,"payload":{"lines":[147,148]},"content":"聚合函数：Sum() by() without()","children":[{"type":"fence","depth":5,"content":"<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># 将多个服务多个接口的请求聚合</span>\nsum<span class=\"token punctuation\">(</span>rate<span class=\"token punctuation\">(</span>demo_api_request_duration_seconds_count<span class=\"token punctuation\">{</span>job<span class=\"token operator\">=</span><span class=\"token string\">\"demo\"</span>, <span class=\"token assign-left variable\">method</span><span class=\"token operator\">=</span><span class=\"token string\">\"GET\"</span>, <span class=\"token assign-left variable\">status</span><span class=\"token operator\">=</span><span class=\"token string\">\"200\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span>5m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">))</span>\n\n<span class=\"token comment\"># 根据请求接口标签分组</span>\nsum<span class=\"token punctuation\">(</span>rate<span class=\"token punctuation\">(</span>demo_api_request_duration_seconds_count<span class=\"token punctuation\">{</span>job<span class=\"token operator\">=</span><span class=\"token string\">\"demo\"</span>, <span class=\"token assign-left variable\">method</span><span class=\"token operator\">=</span><span class=\"token string\">\"GET\"</span>, <span class=\"token assign-left variable\">status</span><span class=\"token operator\">=</span><span class=\"token string\">\"200\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span>5m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">))</span> by<span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 不根据接口路径分组</span>\nsum<span class=\"token punctuation\">(</span>rate<span class=\"token punctuation\">(</span>demo_api_request_duration_seconds_count<span class=\"token punctuation\">{</span>job<span class=\"token operator\">=</span><span class=\"token string\">\"demo\"</span>, <span class=\"token assign-left variable\">method</span><span class=\"token operator\">=</span><span class=\"token string\">\"GET\"</span>, <span class=\"token assign-left variable\">status</span><span class=\"token operator\">=</span><span class=\"token string\">\"200\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span>5m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">))</span> without<span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span>\n</code></pre>\n"}]},{"type":"heading","depth":4,"payload":{"lines":[160,161]},"content":"histogram_quantile","children":[{"type":"fence","depth":5,"content":"<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># 用来统计百分位数：第一个参数是百分位，第二个 histogram 指标，这样计算出来的就是中位数，即 P50</span>\nhistogram_quantile<span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span>,go_gc_pauses_seconds_total_bucket<span class=\"token punctuation\">)</span>\n</code></pre>\n"}]}]},{"type":"heading","depth":3,"payload":{"lines":[167,168]},"content":"其他","children":[{"type":"heading","depth":4,"payload":{"lines":[169,170]},"content":"prometheus配置动态动态更新","children":[{"type":"list_item","depth":6,"payload":{"lines":[171,172]},"content":"启动时需带上参数 <code>prometheus --config.file=/usr/local/etc/prometheus.yml --web.enable-lifecycle</code>"},{"type":"list_item","depth":6,"payload":{"lines":[172,173]},"content":"更新prometheus.yml配置"},{"type":"list_item","depth":6,"payload":{"lines":[173,174]},"content":"通过post的方式请求接口<code>curl -v --request POST 'http://localhost:9090/-/reload'</code>"}]},{"type":"heading","depth":4,"payload":{"lines":[175,176]},"content":"指标抓取和存储","children":[{"type":"fence","depth":5,"content":"<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">global</span><span class=\"token punctuation\">:</span>\n <span class=\"token key atrule\">scrape_interval</span><span class=\"token punctuation\">:</span> 15s\n</code></pre>\n"}]},{"type":"heading","depth":4,"payload":{"lines":[186,187]},"content":"prometheus分位数坑点"}]}]},{"type":"heading","depth":2,"payload":{"lines":[194,195]},"content":"参考","children":[{"type":"list_item","depth":4,"payload":{"lines":[196,197]},"content":"<a href=\"https://mp.weixin.qq.com/s/sQpB0WTs7eBDi4BuWp7gQg\">一文带你了解 Prometheus</a>"}]}]},{})</script></body></html><a id="more"></a><h3 id="prometheus相关实践"><a href="#prometheus相关实践" class="headerlink" title="prometheus相关实践"></a>prometheus相关实践</h3><h4 id="docker部署prometheus和grafana"><a href="#docker部署prometheus和grafana" class="headerlink" title="docker部署prometheus和grafana"></a>docker部署prometheus和grafana</h4><h5 id="启动node-exporter"><a href="#启动node-exporter" class="headerlink" title="启动node-exporter"></a>启动node-exporter</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9100:9100 \</span><br><span class="line"> --name node-exporter \</span><br><span class="line"> --restart=always  \</span><br><span class="line"> -v /data/apps/docker/node-exporter-data/proc:/host/proc:ro \</span><br><span class="line"> -v /data/apps/docker/node-exporter-data/sys:/host/sys:ro \</span><br><span class="line"> -v /data/apps/docker/node-exporter-data:/rootfs:ro \</span><br><span class="line"> prom/node-exporter</span><br></pre></td></tr></table></figure><h5 id="编写prometheus-yml"><a href="#编写prometheus-yml" class="headerlink" title="编写prometheus.yml"></a>编写prometheus.yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">60s</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">60s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.104</span><span class="string">:9090</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.104</span><span class="string">:9100</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">jenkins</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">bearer_token:</span> <span class="string">bearer_token</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.57</span><span class="number">.242</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><h5 id="启动promethus"><a href="#启动promethus" class="headerlink" title="启动promethus"></a>启动promethus</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line"> --name prometheus \</span><br><span class="line"> --restart=always \</span><br><span class="line"> -u root \</span><br><span class="line"> -p 9090:9090 \</span><br><span class="line"> -v /data/apps/docker/prometheus-data/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line"> -v /data/apps/docker/prometheus-data:/prometheus \</span><br><span class="line"> -v /data/apps/docker/prometheus-data/conf:/etc/prometheus/conf \</span><br><span class="line"> prom/prometheus --web.enable-lifecycle</span><br></pre></td></tr></table></figure><h5 id="启动grafana"><a href="#启动grafana" class="headerlink" title="启动grafana"></a>启动grafana</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line"> -p 3000:3000 \</span><br><span class="line"> --restart=always \</span><br><span class="line"> --name=grafana \</span><br><span class="line"> -u root \</span><br><span class="line"> -v /data/apps/docker/grafana-data:/var/lib/grafana \</span><br><span class="line"> grafana/grafana</span><br></pre></td></tr></table></figure><p>grafana账号密码默认admin</p><h4 id="Metric指标"><a href="#Metric指标" class="headerlink" title="Metric指标"></a>Metric指标</h4><h5 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h5><p><img src="https://pic.fengyuwusong.cn/20220512151720.png" alt="数据模型"></p><p>Prometheus 采集的所有指标都是以时间序列的形式进行存储，每一个时间序列有三部分组成：</p><ul><li>指标名和指标标签集合：metric_name{&lt;label1=v1&gt;,&lt;label2=v2&gt;….}，指标名：表示这个指标是监控哪一方面的状态，比如 http_request_total 表示：请求数量；指标标签，描述这个指标有哪些维度，比如 http_request_total 这个指标，有请求状态码 code = 200/400/500，请求方式：method = get/post 等，实际上指标名称实际上是以标签的形式保存，这个标签是name，即：name=。</li><li>时间戳：描述当前时间序列的时间，单位：毫秒。</li><li>样本值：当前监控指标的具体数值，比如 http_request_total 的值就是请求数是多少。</li></ul><h5 id="指标类型"><a href="#指标类型" class="headerlink" title="指标类型"></a>指标类型</h5><ul><li>Counter 计数器</li><li>Gauge 仪表盘</li><li>Histogram 直方图</li><li>Summary 摘要</li></ul><h4 id="PromQL"><a href="#PromQL" class="headerlink" title="PromQL"></a>PromQL</h4><p>PromQL 是 Prometheus 为我们提供的函数式的查询语言，查询表达式有四种类型：</p><ul><li>字符串：只作为某些内置函数的参数出现</li><li>标量：单一的数字值，可以是函数参数，也可以是函数的返回结果</li><li>瞬时向量：某一时刻的时序数据</li><li>区间向量：某一时间区间内的时序数据集合</li></ul><h5 id="瞬时查询"><a href="#瞬时查询" class="headerlink" title="瞬时查询"></a>瞬时查询</h5><p>直接通过指标名即可进行查询，查询结果是当前指标最新的时间序列，比如查询 Gc 累积消耗的时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接查询</span></span><br><span class="line">go_gc_duration_seconds_count</span><br><span class="line"><span class="meta">#</span><span class="bash"> 筛选</span></span><br><span class="line">go_gc_duration_seconds_count&#123;instance="127.0.0.1:9600"&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 正则</span></span><br><span class="line">go_gc_duration_seconds_count&#123;instance=~"localhost.*"&#125;</span><br></pre></td></tr></table></figure><h5 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h5><p>范围查询的结果集就是区间向量，可以通过[]指定时间来做范围查询，查询 5 分钟内的 Gc 累积消耗时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> d：天，h：小时，m：分钟，ms：毫秒，s：秒，w：周，y：年</span></span><br><span class="line">go_gc_duration_seconds_count&#123;&#125;[5m]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 偏移</span></span><br><span class="line">go_gc_duration_seconds_count&#123;&#125;[5m] offset 1d</span><br></pre></td></tr></table></figure><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><h6 id="rate"><a href="#rate" class="headerlink" title="rate"></a>rate</h6><p>rate 函数可以用来求指标的平均变化速率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate函数=时间区间前后两个点的差 / 时间范围</span><br></pre></td></tr></table></figure><p>一般 rate 函数可以用来求某个时间区间内的请求速率，也就是我们常说的 QPS：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(demo_api_request_duration_seconds_count[1m])/60</span><br></pre></td></tr></table></figure><p>但是 rate 函数只是算出来了某个时间区间内的平均速率，没办法反映突发变化，假设在一分钟的时间区间里，前 50 秒的请求量都是 0 到 10 左右，但是最后 10 秒的请求量暴增到 100 以上，这时候算出来的值可能无法很好的反映这个峰值变化。这个问题可以通过 irate 函数解决，irate 函数求出来的就是瞬时变化率。</p><h6 id="irate"><a href="#irate" class="headerlink" title="irate"></a>irate</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irate = 时间区间内最后两个样本点的差 / 最后两个样本点的时间差</span><br></pre></td></tr></table></figure><h6 id="聚合函数：Sum-by-without"><a href="#聚合函数：Sum-by-without" class="headerlink" title="聚合函数：Sum() by() without()"></a>聚合函数：Sum() by() without()</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将多个服务多个接口的请求聚合</span></span><br><span class="line">sum(rate(demo_api_request_duration_seconds_count&#123;job="demo", method="GET", status="200"&#125;[5m]))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据请求接口标签分组</span></span><br><span class="line">sum(rate(demo_api_request_duration_seconds_count&#123;job="demo", method="GET", status="200"&#125;[5m])) by(path)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不根据接口路径分组</span></span><br><span class="line">sum(rate(demo_api_request_duration_seconds_count&#123;job="demo", method="GET", status="200"&#125;[5m])) without(path)</span><br></pre></td></tr></table></figure><h6 id="histogram-quantile"><a href="#histogram-quantile" class="headerlink" title="histogram_quantile"></a>histogram_quantile</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用来统计百分位数：第一个参数是百分位，第二个 histogram 指标，这样计算出来的就是中位数，即 P50</span></span><br><span class="line">histogram_quantile(0.5,go_gc_pauses_seconds_total_bucket)</span><br></pre></td></tr></table></figure><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><h6 id="prometheus配置动态动态更新"><a href="#prometheus配置动态动态更新" class="headerlink" title="prometheus配置动态动态更新"></a>prometheus配置动态动态更新</h6><ul><li>启动时需带上参数 <code>prometheus --config.file=/usr/local/etc/prometheus.yml --web.enable-lifecycle</code></li><li>更新prometheus.yml配置</li><li>通过post的方式请求接口<code>curl -v --request POST &#39;http://localhost:9090/-/reload&#39;</code></li></ul><h6 id="指标抓取和存储"><a href="#指标抓取和存储" class="headerlink" title="指标抓取和存储"></a>指标抓取和存储</h6><p>Prometheus 对指标的抓取采取主动 Pull 的方式，即周期性的请求被监控服务暴露的 metrics 接口或者是 PushGateway，从而获取到 Metrics 指标，默认时间是 15s 抓取一次，配置项如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"> <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br></pre></td></tr></table></figure><p>抓取到的指标会被以时间序列的形式保存在内存中，并且定时刷到磁盘上，默认是两个小时回刷一次。并且为了防止 Prometheus 发生崩溃或重启时能够恢复数据，Prometheus 也提供了类似 MySQL 中 binlog 一样的预写日志，当 Prometheus 崩溃重启时，会读这个预写日志来恢复数据。</p><h6 id="prometheus分位数坑点"><a href="#prometheus分位数坑点" class="headerlink" title="prometheus分位数坑点"></a>prometheus分位数坑点</h6><p>Prometheus 不保存具体的指标数值的，他会帮你把指标放到具体的桶，但是他不会保存你指标的值，计算的分位数是一个预估的值，怎么预估呢？就是假设每个桶内的样本分布是均匀的，线性分布来计算的。<br>假设我们指定桶为：<code>[]float64{0,2.5,5,7.5,10}</code><br>则 P50，其实就是算排在第50%位置的样本值，假设刚刚所有的数据都落在了第一个桶，那么他在计算的时候就会假定这个50%值在第一个桶的中点，他就会假定这个数就是 <code>0.5*2.5</code>，P99 就是第一个桶的 99%的位置，他就会假定这个数就是 <code>0.99*2.5</code>。</p><p>导致这个误差较大的原因就是我们的 bucket 设置的不合理。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://mp.weixin.qq.com/s/sQpB0WTs7eBDi4BuWp7gQg" target="_blank" rel="noopener">一文带你了解 Prometheus</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
            <tag> 监控 </tag>
            
            <tag> prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang逃逸分析</title>
      <link href="/2022/05/10/Golang%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
      <url>/2022/05/10/Golang%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="Golang编译器逃逸分析"><a href="#Golang编译器逃逸分析" class="headerlink" title="Golang编译器逃逸分析"></a>Golang编译器逃逸分析</h3><h4 id="逃逸分析-escape-analysis"><a href="#逃逸分析-escape-analysis" class="headerlink" title="逃逸分析(escape analysis)"></a>逃逸分析(escape analysis)</h4><p>go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，<strong>当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。</strong></p><a id="more"></a><h5 id="判断是否发生逃逸"><a href="#判断是否发生逃逸" class="headerlink" title="判断是否发生逃逸"></a>判断是否发生逃逸</h5><ul><li>查看指针是否连续</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(arg_val <span class="keyword">int</span>)</span> <span class="params">(*<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> foo_val1 <span class="keyword">int</span> = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">var</span> foo_val2 <span class="keyword">int</span> = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">var</span> foo_val3 <span class="keyword">int</span> = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">var</span> foo_val4 <span class="keyword">int</span> = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">var</span> foo_val5 <span class="keyword">int</span> = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处循环是防止go编译器将foo优化成inline(内联函数)</span></span><br><span class="line">    <span class="comment">//如果是内联函数，main调用foo将是原地展开，所以foo_val1-5相当于main作用域的变量</span></span><br><span class="line">    <span class="comment">//即使foo_val3发生逃逸，地址与其他也是连续的</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="built_in">println</span>(&amp;arg_val, &amp;foo_val1, &amp;foo_val2, &amp;foo_val3, &amp;foo_val4, &amp;foo_val5)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回foo_val3给main函数</span></span><br><span class="line">    <span class="keyword">return</span> &amp;foo_val3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    main_val := foo(<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(*main_val, main_val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0xc000038768 0xc000038760 0xc000038758 0xc000038750 0xc000038748 0xc000038740</span><br><span class="line">0xc000038768 0xc000038760 0xc000038758 0xc000038750 0xc000038748 0xc000038740</span><br><span class="line">0xc000038768 0xc000038760 0xc000038758 0xc000038750 0xc000038748 0xc000038740</span><br><span class="line">0xc000038768 0xc000038760 0xc000038758 0xc000038750 0xc000038748 0xc000038740</span><br><span class="line">0xc000038768 0xc000038760 0xc000038758 0xc000038750 0xc000038748 0xc000038740</span><br><span class="line">13 0xc000038750</span><br></pre></td></tr></table></figure><ul><li>使用<code>go tool compile</code>测试，发现该变量被判断为逃逸，在堆中被开辟</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ go tool compile -m demo.go </span><br><span class="line">demo.go:3:6: can inline foo</span><br><span class="line">demo.go:22:6: can inline main</span><br><span class="line">demo.go:23:17: inlining call to foo</span><br><span class="line">demo.go:7:6: moved to heap: foo_val3</span><br></pre></td></tr></table></figure><ul><li>也可以采用去汇编的方式来证实是否逃逸</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S demo.go &gt; demo.S</span><br></pre></td></tr></table></figure><p>截取demo.S部分，发现<code>runtime.newobject(SB)</code>,说明该变量在堆空间开辟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x0033 00051 (demo.go:7) LEAQ type.int(SB), AX</span><br><span class="line">0x003a 00058 (demo.go:7) MOVQ AX, (SP)</span><br><span class="line">0x003e 00062 (demo.go:7) PCDATA $1, $0</span><br><span class="line">0x003e 00062 (demo.go:7) NOP</span><br><span class="line">0x0040 00064 (demo.go:7) CALL runtime.newobject(SB)</span><br><span class="line">0x0045 00069 (demo.go:7) MOVQ 8(SP), AX</span><br><span class="line">0x004a 00074 (demo.go:7) MOVQ AX, &quot;&quot;.&amp;foo_val3+56(SP)</span><br><span class="line">0x004f 00079 (demo.go:7) MOVQ $13, (AX)</span><br><span class="line">0x0056 00086 (demo.go:8) MOVQ $14, &quot;&quot;.foo_val4+32(SP)</span><br><span class="line">0x005f 00095 (demo.go:9) MOVQ $15, &quot;&quot;.foo_val5+24(SP)</span><br><span class="line">0x0068 00104 (demo.go:9) XORL CX, CX</span><br></pre></td></tr></table></figure><h4 id="逃逸规则"><a href="#逃逸规则" class="headerlink" title="逃逸规则"></a>逃逸规则</h4><p><strong>一般我们给一个引用类对象中的引用类成员进行赋值，可能出现逃逸现象。</strong><br>可以理解为访问一个引用对象实际上底层就是通过一个指针来间接的访问了，但如果再访问里面的引用成员就会有第二次间接访问，这样操作这部分对象的话，极大可能会出现逃逸的现象。</p><p>Go语言中的引用类型有<br><strong>func（函数类型），interface（接口类型），slice（切片类型），map（字典类型），channel（管道类型），*（指针类型），等</strong></p><h5 id="逃逸范例"><a href="#逃逸范例" class="headerlink" title="逃逸范例"></a>逃逸范例</h5><ol><li>[]interface{}数据类型，通过[]赋值必定会出现逃逸。</li><li>map[string]interface{}类型尝试通过赋值，必定会出现逃逸。</li><li>map[interface{}]interface{}类型尝试通过赋值，会导致key和value的赋值，key和value均出现逃逸。</li><li>map[string][]string数据类型，赋值会发生[]string发生逃逸。</li><li>[]*int数据类型，赋值的右值会发生逃逸现象。</li><li>func(*int)函数类型，进行函数赋值，会使传递的形参出现逃逸现象。</li><li>func([]string): 函数类型，进行[]string{“value”}赋值，会使传递的参数出现逃逸现象。</li><li>chan []string数据类型，想当前channel中传输[]string{“value”}会发生逃逸现象。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 逃逸分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux学习笔记</title>
      <link href="/2022/05/08/tmux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/08/tmux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h3><p><img src="http://pic.fengyuwusong.cn/20220508163622.png" alt="思维导图"></p><a id="more"></a><h4 id="Tmux是什么"><a href="#Tmux是什么" class="headerlink" title="Tmux是什么"></a>Tmux是什么</h4><h5 id="会话与进程"><a href="#会话与进程" class="headerlink" title="会话与进程"></a>会话与进程</h5><ul><li>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。用户与计算机的这种临时的交互，称为一次”会话”（session） 。</li><li>会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</li><li>故为了避免上述问题，需要将会话和窗口“解绑”</li></ul><h5 id="Tmux的作用"><a href="#Tmux的作用" class="headerlink" title="Tmux的作用"></a>Tmux的作用</h5><p>Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。</p><ul><li>它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</li><li>它可以让新窗口”接入”已经存在的会话。</li><li>它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</li><li>它还支持窗口任意的垂直和水平拆分。</li></ul><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu 或 Debian</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install tmux</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS 或 Fedora</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install tmux</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Mac</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install tmux</span></span><br></pre></td></tr></table></figure><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux</span><br></pre></td></tr></table></figure><h5 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h5><ul><li><code>exit</code></li><li><code>Ctrl+d</code></li></ul><h5 id="前缀键"><a href="#前缀键" class="headerlink" title="前缀键"></a>前缀键</h5><ul><li><code>Ctrl+b</code></li></ul><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是Ctrl+b，即先按下Ctrl+b，快捷键才会生效。</p><h4 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h4><h5 id="新建会话"><a href="#新建会话" class="headerlink" title="新建会话"></a>新建会话</h5><ul><li><code>tmux new -s &lt;session-name&gt;</code></li></ul><p>第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p><p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p><h5 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h5><ul><li><code>tmux detach</code></li><li><code>Ctrl+b d</code></li></ul><p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p><h5 id="查看会话"><a href="#查看会话" class="headerlink" title="查看会话"></a>查看会话</h5><ul><li><code>tmux ls</code></li><li><code>tmux list-session</code></li></ul><h5 id="接入会话"><a href="#接入会话" class="headerlink" title="接入会话"></a>接入会话</h5><ul><li><code>tmux attach -t &lt;session-id&gt;</code></li><li><code>tmux attach -t &lt;session-name&gt;</code></li></ul><h5 id="杀死会话"><a href="#杀死会话" class="headerlink" title="杀死会话"></a>杀死会话</h5><ul><li><code>tmux kill-session -t &lt;session-id&gt;</code></li><li><code>tmux kill-session -t &lt;session-name&gt;</code></li></ul><h5 id="切换会话"><a href="#切换会话" class="headerlink" title="切换会话"></a>切换会话</h5><ul><li><code>tmux switch -t &lt;session-id&gt;</code></li><li><code>tmux switch -t &lt;session-name&gt;</code></li></ul><h5 id="重命名会话"><a href="#重命名会话" class="headerlink" title="重命名会话"></a>重命名会话</h5><ul><li>`tmux rename-session -t <session-id> <session-new-name></li><li><code>Ctrl+b $</code> 重命名当前会话</li></ul><h5 id="会话快捷键"><a href="#会话快捷键" class="headerlink" title="会话快捷键"></a>会话快捷键</h5><ul><li><code>Ctrl+b d</code> 分离当前会话</li><li><code>Ctrl+b s</code> 列出所有会话</li><li><code>Ctrl+b $</code> 重命名当前会话</li></ul><h4 id="窗格操作"><a href="#窗格操作" class="headerlink" title="窗格操作"></a>窗格操作</h4><h5 id="划分窗格"><a href="#划分窗格" class="headerlink" title="划分窗格"></a>划分窗格</h5><ul><li><code>tmux split-window</code> 划分上下两个窗格</li><li><code>tmux split-window -h</code> 划分左右两个窗格</li></ul><h5 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h5><ul><li><code>tmux select-pane -U</code> 光标切换到上方窗格</li><li><code>tmux select-pane -D</code> 光标切换到下方窗格</li><li><code>tmux select-pane -L</code> 光标切换到左边窗格</li><li><code>tmux select-pane -R</code> 光标切换到右边窗格</li></ul><h5 id="交换窗格位置"><a href="#交换窗格位置" class="headerlink" title="交换窗格位置"></a>交换窗格位置</h5><ul><li><code>tmux swap-pane -U</code> 当前窗格上移</li><li><code>tmux swap-pane -D</code> 当前窗格下移</li></ul><h5 id="窗格快捷键"><a href="#窗格快捷键" class="headerlink" title="窗格快捷键"></a>窗格快捷键</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+b %：划分左右两个窗格。</span><br><span class="line">Ctrl+b "：划分上下两个窗格。</span><br><span class="line">Ctrl+b &lt;arrow key&gt;：光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。</span><br><span class="line">Ctrl+b ;：光标切换到上一个窗格。</span><br><span class="line">Ctrl+b o：光标切换到下一个窗格。</span><br><span class="line">Ctrl+b &#123;：当前窗格与上一个窗格交换位置。</span><br><span class="line">Ctrl+b &#125;：当前窗格与下一个窗格交换位置。</span><br><span class="line">Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</span><br><span class="line">Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</span><br><span class="line">Ctrl+b x：关闭当前窗格。</span><br><span class="line">Ctrl+b !：将当前窗格拆分为一个独立窗口。</span><br><span class="line">Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。</span><br><span class="line">Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。</span><br><span class="line">Ctrl+b q：显示窗格编号。</span><br></pre></td></tr></table></figure><h4 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h4><h5 id="新建窗口"><a href="#新建窗口" class="headerlink" title="新建窗口"></a>新建窗口</h5><ul><li><code>tmux new-window</code></li><li><code>tmux new-window -n &lt;window-name&gt;</code></li></ul><h5 id="切换窗口"><a href="#切换窗口" class="headerlink" title="切换窗口"></a>切换窗口</h5><ul><li><code>tmux select-window -t &lt;window-number&gt;</code> 切换到指定编号的窗口</li><li><code>tmux select-window -t &lt;window-name&gt;</code> 切换到指定名称的窗口</li></ul><h5 id="重命名窗口"><a href="#重命名窗口" class="headerlink" title="重命名窗口"></a>重命名窗口</h5><ul><li><code>tmux rename-window &lt;new-name&gt;</code> 命名当前窗口(重命名)</li></ul><h5 id="窗口快捷键"><a href="#窗口快捷键" class="headerlink" title="窗口快捷键"></a>窗口快捷键</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。</span><br><span class="line">Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。</span><br><span class="line">Ctrl+b n：切换到下一个窗口。</span><br><span class="line">Ctrl+b &lt;number&gt;：切换到指定编号的窗口，其中的&lt;number&gt;是状态栏上的窗口编号。</span><br><span class="line">Ctrl+b w：从列表中选择窗口。</span><br><span class="line">Ctrl+b ,：窗口重命名。</span><br></pre></td></tr></table></figure><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有快捷键，及其对应的 Tmux 命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux list-keys</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有 Tmux 命令及其参数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux list-commands</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出当前所有 Tmux 会话的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux info</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载当前的 Tmux 配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux <span class="built_in">source</span>-file ~/.tmux.conf</span></span><br></pre></td></tr></table></figure><h4 id="踩坑点"><a href="#踩坑点" class="headerlink" title="踩坑点"></a>踩坑点</h4><ul><li>鼠标滚轮不能翻动缓冲区<ul><li>需要更改<code>~/.tmux.conf</code>配置，增加配置 <code>set -g mode-mouse on</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> linux </tag>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang的协程调度器原理及GMP设计思想</title>
      <link href="/2022/05/07/Golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
      <url>/2022/05/07/Golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Markmap</title><style>* {  margin: 0;  padding: 0;}#mindmap {  display: block;  width: 100vw;  height: 100vh;}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.13.2/dist/style.css"><meta name="generator" content="Hexo 4.2.0"></head><body><svg id="mindmap"></svg><script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.13.2"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.13.2/dist/index.umd.min.js"></script><script>(r => {                setTimeout(r);              })(() => {  const {    markmap,    mm  } = window;  const toolbar = new markmap.Toolbar();  toolbar.attach(mm);  const el = toolbar.render();  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');  document.body.append(el);})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {        const markmap = getMarkmap();        window.mm = markmap.Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(markmap, jsonOptions), root);      })(() => window.markmap,(markmap, jsonOptions) => markmap.deriveOptions(jsonOptions),{"type":"heading","depth":1,"payload":{"lines":[1,2]},"content":"GMP设计思想","children":[{"type":"heading","depth":2,"payload":{"lines":[3,4]},"content":"调度器的由来","children":[{"type":"heading","depth":3,"payload":{"lines":[5,6]},"content":"单进程"},{"type":"heading","depth":3,"payload":{"lines":[9,10]},"content":"多进程/线程","children":[{"type":"list_item","depth":5,"payload":{"lines":[13,14]},"content":"优点","children":[{"type":"list_item","depth":7,"payload":{"lines":[14,15]},"content":"可以并发执行任务"}]},{"type":"list_item","depth":5,"payload":{"lines":[15,16]},"content":"缺点","children":[{"type":"list_item","depth":7,"payload":{"lines":[16,17]},"content":"高内存占用"},{"type":"list_item","depth":7,"payload":{"lines":[17,18]},"content":"调度的高消耗CPU"},{"type":"list_item","depth":7,"payload":{"lines":[18,19]},"content":"锁&amp;竞争冲突"}]}]},{"type":"heading","depth":3,"payload":{"lines":[20,21]},"content":"协程","children":[{"type":"list_item","depth":5,"payload":{"lines":[22,23]},"content":"解决多进程&amp;线程的缺点而被设计"},{"type":"list_item","depth":5,"payload":{"lines":[23,24]},"content":"线程和协程关系","children":[{"type":"list_item","depth":7,"payload":{"lines":[24,25]},"content":"N:1","children":[{"type":"list_item","depth":9,"payload":{"lines":[25,26]},"content":"缺点：无法使用硬件多核能力、协程阻塞则无法并行"}]},{"type":"list_item","depth":7,"payload":{"lines":[26,27]},"content":"1:1","children":[{"type":"list_item","depth":9,"payload":{"lines":[27,28]},"content":"缺点：协程创建、删除和切换的代价都依赖CPU线程完成，代价昂贵"}]},{"type":"list_item","depth":7,"payload":{"lines":[28,29]},"content":"M:N","children":[{"type":"list_item","depth":9,"payload":{"lines":[29,30]},"content":"克服了以上缺点"}]}]},{"type":"list_item","depth":5,"payload":{"lines":[30,31]},"content":"线程&amp;协程区别","children":[{"type":"list_item","depth":7,"payload":{"lines":[31,32]},"content":"占用空间"},{"type":"list_item","depth":7,"payload":{"lines":[32,33]},"content":"调度：抢占式vs协作式（协程让出CPU后才执行下一个协程）"}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[34,35]},"content":"Goroutine调度器的GMP模型设计思想","children":[{"type":"heading","depth":3,"payload":{"lines":[36,37]},"content":"Go语言的协程goroutine","children":[{"type":"list_item","depth":5,"payload":{"lines":[38,39]},"content":"goroutine&amp;channel"},{"type":"list_item","depth":5,"payload":{"lines":[39,40]},"content":"特点","children":[{"type":"list_item","depth":7,"payload":{"lines":[40,41]},"content":"占用内存更小"},{"type":"list_item","depth":7,"payload":{"lines":[41,42]},"content":"调度更灵活"}]}]},{"type":"heading","depth":3,"payload":{"lines":[43,44]},"content":"旧版goroutine调度器","children":[{"type":"list_item","depth":5,"payload":{"lines":[49,50]},"content":"缺点","children":[{"type":"list_item","depth":7,"payload":{"lines":[50,51],"index":1},"content":"1. 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。"},{"type":"list_item","depth":7,"payload":{"lines":[51,52],"index":2},"content":"2. M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M'。"},{"type":"list_item","depth":7,"payload":{"lines":[52,53],"index":3},"content":"3. 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。"}]}]},{"type":"heading","depth":3,"payload":{"lines":[54,55]},"content":"GMP模型","children":[{"type":"list_item","depth":5,"payload":{"lines":[58,59]},"content":"模型相关","children":[{"type":"list_item","depth":7,"payload":{"lines":[59,60],"index":1},"content":"1. 全局队列（Global Queue）：存放等待运行的G。"},{"type":"list_item","depth":7,"payload":{"lines":[60,61],"index":2},"content":"2. P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。"},{"type":"list_item","depth":7,"payload":{"lines":[61,62],"index":3},"content":"3. P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。"},{"type":"list_item","depth":7,"payload":{"lines":[62,63],"index":4},"content":"4. M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。"}]},{"type":"list_item","depth":5,"payload":{"lines":[63,64]},"content":"P和M的个数问题","children":[{"type":"list_item","depth":7,"payload":{"lines":[64,65]},"content":"P的数量","children":[{"type":"list_item","depth":9,"payload":{"lines":[65,66]},"content":"由启动时环境变量<code>$GOMAXPROCS</code>或者是由<code>runtime</code>的方法<code>GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有<code>$GOMAXPROCS个goroutine</code>在同时运行。"},{"type":"list_item","depth":9,"payload":{"lines":[66,67]},"content":"M的数量","children":[{"type":"list_item","depth":11,"payload":{"lines":[67,68]},"content":"go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。"},{"type":"list_item","depth":11,"payload":{"lines":[68,69]},"content":"<code>runtime/debug</code>中的<code>SetMaxThreads</code>函数，设置M的最大数量"},{"type":"list_item","depth":11,"payload":{"lines":[69,70]},"content":"一个M阻塞了，会创建新的M。"}]},{"type":"list_item","depth":9,"payload":{"lines":[70,71]},"content":"P和M的关系","children":[{"type":"list_item","depth":11,"payload":{"lines":[71,72]},"content":"M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。"}]},{"type":"list_item","depth":9,"payload":{"lines":[72,73]},"content":"P和M何时被创建","children":[{"type":"list_item","depth":11,"payload":{"lines":[73,74]},"content":"P：在确定P的最大数量n后，运行时系统会根据这个数量创建n个P"},{"type":"list_item","depth":11,"payload":{"lines":[74,75]},"content":"M：没有足够的M来关联P并运行其中可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。"}]}]}]}]},{"type":"heading","depth":3,"payload":{"lines":[76,77]},"content":"调度器的设计策略","children":[{"type":"list_item","depth":5,"payload":{"lines":[78,79]},"content":"复用线程","children":[{"type":"list_item","depth":7,"payload":{"lines":[79,80]},"content":"work stealing机制：当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。"},{"type":"list_item","depth":7,"payload":{"lines":[80,81]},"content":"hand off机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。"}]},{"type":"list_item","depth":5,"payload":{"lines":[81,82]},"content":"利用并行","children":[{"type":"list_item","depth":7,"payload":{"lines":[82,83]},"content":"GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。"}]},{"type":"list_item","depth":5,"payload":{"lines":[83,84]},"content":"抢占","children":[{"type":"list_item","depth":7,"payload":{"lines":[84,85]},"content":"在coroutine中要等待一个协程主动让出CPU才执行下一个协程，<strong>在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</strong>"}]},{"type":"list_item","depth":5,"payload":{"lines":[85,86]},"content":"全局G队列","children":[{"type":"list_item","depth":7,"payload":{"lines":[86,87]},"content":"在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。"}]}]},{"type":"heading","depth":3,"payload":{"lines":[88,89]},"content":"<code>go func()</code>调度流程"},{"type":"heading","depth":3,"payload":{"lines":[99,100]},"content":"调度器的生命周期","children":[{"type":"fence","depth":4,"content":"<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello world\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"},{"type":"bullet_list","depth":4,"payload":{"lines":[113,125]},"content":"","children":[{"type":"list_item","depth":5,"payload":{"lines":[113,114]},"content":"M0&amp;G0","children":[{"type":"list_item","depth":7,"payload":{"lines":[114,115]},"content":"M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。"},{"type":"list_item","depth":7,"payload":{"lines":[115,116]},"content":"G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。"}]},{"type":"list_item","depth":5,"payload":{"lines":[116,117]},"content":"生命周期流程","children":[{"type":"list_item","depth":7,"payload":{"lines":[117,118],"index":1},"content":"1. runtime创建最初的线程m0和goroutine g0，并把2者关联。"},{"type":"list_item","depth":7,"payload":{"lines":[118,119],"index":2},"content":"2. 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。"},{"type":"list_item","depth":7,"payload":{"lines":[119,120],"index":3},"content":"3. 示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。"},{"type":"list_item","depth":7,"payload":{"lines":[120,121],"index":4},"content":"4. 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。"},{"type":"list_item","depth":7,"payload":{"lines":[121,122],"index":5},"content":"5. G拥有栈，M根据G中的栈信息和调度信息设置运行环境"},{"type":"list_item","depth":7,"payload":{"lines":[122,123],"index":6},"content":"6. M运行G"},{"type":"list_item","depth":7,"payload":{"lines":[123,124],"index":7},"content":"7. G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。"}]}]}]},{"type":"heading","depth":3,"payload":{"lines":[125,126]},"content":"可视化GMP编程","children":[{"type":"bullet_list","depth":4,"payload":{"lines":[127,129]},"content":"","children":[{"type":"list_item","depth":5,"payload":{"lines":[127,128]},"content":"<code>go tool trace</code>"}]},{"type":"fence","depth":4,"content":"<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"os\"</span>\n    <span class=\"token string\">\"fmt\"</span>\n    <span class=\"token string\">\"runtime/trace\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">//创建trace文件</span>\n    f<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"trace.out\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">defer</span> f<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">//启动trace goroutine</span>\n    err <span class=\"token operator\">=</span> trace<span class=\"token punctuation\">.</span><span class=\"token function\">Start</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">defer</span> trace<span class=\"token punctuation\">.</span><span class=\"token function\">Stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">//main</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"},{"type":"bullet_list","depth":4,"payload":{"lines":[162,164]},"content":"","children":[{"type":"list_item","depth":5,"payload":{"lines":[162,163]},"content":"<code>Debug trace</code>"}]},{"type":"fence","depth":4,"content":"<pre class=\"language-shell\"><code class=\"language-shell\">  $ <span class=\"token assign-left variable\">GODEBUG</span><span class=\"token operator\">=</span>schedtrace<span class=\"token operator\">=</span><span class=\"token number\">1000</span> ./trace2\n  SCHED 0ms: <span class=\"token assign-left variable\">gomaxprocs</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">idleprocs</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token assign-left variable\">threads</span><span class=\"token operator\">=</span><span class=\"token number\">4</span> <span class=\"token assign-left variable\">spinningthreads</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">idlethreads</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">runqueue</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n  Hello World\n  SCHED 1003ms: <span class=\"token assign-left variable\">gomaxprocs</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">idleprocs</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">threads</span><span class=\"token operator\">=</span><span class=\"token number\">4</span> <span class=\"token assign-left variable\">spinningthreads</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token assign-left variable\">idlethreads</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">runqueue</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n  Hello World\n  SCHED 2014ms: <span class=\"token assign-left variable\">gomaxprocs</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">idleprocs</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">threads</span><span class=\"token operator\">=</span><span class=\"token number\">4</span> <span class=\"token assign-left variable\">spinningthreads</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token assign-left variable\">idlethreads</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">runqueue</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n  Hello World\n  SCHED 3015ms: <span class=\"token assign-left variable\">gomaxprocs</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">idleprocs</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">threads</span><span class=\"token operator\">=</span><span class=\"token number\">4</span> <span class=\"token assign-left variable\">spinningthreads</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token assign-left variable\">idlethreads</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">runqueue</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n  Hello World\n  SCHED 4023ms: <span class=\"token assign-left variable\">gomaxprocs</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">idleprocs</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">threads</span><span class=\"token operator\">=</span><span class=\"token number\">4</span> <span class=\"token assign-left variable\">spinningthreads</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token assign-left variable\">idlethreads</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">runqueue</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n  Hello World\n</code></pre>\n"},{"type":"bullet_list","depth":4,"payload":{"lines":[180,192]},"content":"","children":[{"type":"list_item","depth":5,"payload":{"lines":[180,181]},"content":"执行方式：<code>GODEBUG=schedtrace=1000 ./trace2</code>"},{"type":"list_item","depth":5,"payload":{"lines":[181,182]},"content":"说明","children":[{"type":"list_item","depth":7,"payload":{"lines":[182,183]},"content":"SCHED：调试信息输出标志字符串，代表本行是goroutine调度器的输出；"},{"type":"list_item","depth":7,"payload":{"lines":[183,184]},"content":"0ms：即从程序启动到输出这行日志的时间；"},{"type":"list_item","depth":7,"payload":{"lines":[184,185]},"content":"gomaxprocs: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；"},{"type":"list_item","depth":7,"payload":{"lines":[185,186]},"content":"idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；"},{"type":"list_item","depth":7,"payload":{"lines":[186,187]},"content":"threads: os threads/M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；"},{"type":"list_item","depth":7,"payload":{"lines":[187,188]},"content":"spinningthreads: 处于自旋状态的os thread数量；"},{"type":"list_item","depth":7,"payload":{"lines":[188,189]},"content":"idlethread: 处于idle状态的os thread的数量；"},{"type":"list_item","depth":7,"payload":{"lines":[189,190]},"content":"runqueue=0： Scheduler全局队列中G的数量；"},{"type":"list_item","depth":7,"payload":{"lines":[190,191]},"content":"[0 0]: 分别为2个P的local queue中的G的数量。"}]}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[192,193]},"content":"Go调度器调度场景过程全解析","children":[{"type":"list_item","depth":4,"payload":{"lines":[196,197]},"content":"新建G会优先放到当前的P本地队列"},{"type":"list_item","depth":4,"payload":{"lines":[197,198]},"content":"M执行完G时，会先切换G0负责协程的调度切换，从而执行下一个G"},{"type":"list_item","depth":4,"payload":{"lines":[198,199]},"content":"当开辟过多G，P本地队列装不下的时候，则会执行负载均衡（把P本地队列前一半的G和新建的G打乱顺序转移到全局队列【新建的G不一定会转移，需视是否需立即执行决定】）"},{"type":"list_item","depth":4,"payload":{"lines":[199,200]},"content":"创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行"},{"type":"list_item","depth":4,"payload":{"lines":[200,201]},"content":"空闲M从全局队列GQ获取G的数量符合公式：<code>n = min(len(GQ) / GOMAXPROCS + 1, cap(LQ) / 2 )</code>"},{"type":"list_item","depth":4,"payload":{"lines":[201,202]},"content":"如全局队列已经没有G，则m需要自行<code>work stealing</code>: 从其他P的本地队列中偷取一半的G，放到自己的P队列"},{"type":"list_item","depth":4,"payload":{"lines":[202,203]},"content":"空闲线程如没有G执行，则会让其处于自旋状态【由于创建销毁本身也需消耗资源，故保存自旋当有新的G时可立马执行】，最多有GOMAXPROCS个自旋线程"},{"type":"list_item","depth":4,"payload":{"lines":[203,204]},"content":"当G进行了系统调用时，则M和P会立即解绑，此时如P本地队列存在G、全局队列有G或有空闲的M，P都会立马唤醒一个M和它绑定，否则P会加入空闲P列表，等待M来获取【即当前M用于执行阻塞系统调用的G，此时M无P绑定】"},{"type":"list_item","depth":4,"payload":{"lines":[204,205]},"content":"假设G进行的系统调用并非阻塞，则M执行完毕系统后，G会重新投入G全局队列中并标记为可运行状态，同时M会重新尝试获取之前绑定的P，如该P已被其他M绑定，则从空闲队列中获取P，如仍获取失败则M因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。"}]},{"type":"heading","depth":2,"payload":{"lines":[206,207]},"content":"总结"},{"type":"heading","depth":2,"payload":{"lines":[210,211]},"content":"参考","children":[{"type":"list_item","depth":4,"payload":{"lines":[212,213]},"content":"<a href=\"https://www.yuque.com/aceld/golang/srxd6d\">Golang的协程调度器原理及GMP设计思想</a>"}]}]},{})</script></body></html><a id="more"></a><h3 id="GMP设计思想"><a href="#GMP设计思想" class="headerlink" title="GMP设计思想"></a>GMP设计思想</h3><h4 id="调度器的由来"><a href="#调度器的由来" class="headerlink" title="调度器的由来"></a>调度器的由来</h4><h5 id="单进程"><a href="#单进程" class="headerlink" title="单进程"></a>单进程</h5><p>一个进程只能处理一个任务，故不需要调度器</p><h5 id="多进程-线程"><a href="#多进程-线程" class="headerlink" title="多进程/线程"></a>多进程/线程</h5><p>进程阻塞时，可以切换其他进程来执行其他任务</p><ul><li>优点<ul><li>可以并发执行任务</li></ul></li><li>缺点<ul><li>高内存占用</li><li>调度的高消耗CPU</li><li>锁&amp;竞争冲突</li></ul></li></ul><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><ul><li>解决多进程&amp;线程的缺点而被设计</li><li>线程和协程关系<ul><li>N:1<ul><li>缺点：无法使用硬件多核能力、协程阻塞则无法并行</li></ul></li><li>1:1<ul><li>缺点：协程创建、删除和切换的代价都依赖CPU线程完成，代价昂贵</li></ul></li><li>M:N<ul><li>克服了以上缺点</li></ul></li></ul></li><li>线程&amp;协程区别<ul><li>占用空间</li><li>调度：抢占式vs协作式（协程让出CPU后才执行下一个协程）</li></ul></li></ul><h4 id="Goroutine调度器的GMP模型设计思想"><a href="#Goroutine调度器的GMP模型设计思想" class="headerlink" title="Goroutine调度器的GMP模型设计思想"></a>Goroutine调度器的GMP模型设计思想</h4><h5 id="Go语言的协程goroutine"><a href="#Go语言的协程goroutine" class="headerlink" title="Go语言的协程goroutine"></a>Go语言的协程goroutine</h5><ul><li>goroutine&amp;channel</li><li>特点<ul><li>占用内存更小</li><li>调度更灵活</li></ul></li></ul><h5 id="旧版goroutine调度器"><a href="#旧版goroutine调度器" class="headerlink" title="旧版goroutine调度器"></a>旧版goroutine调度器</h5><p>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？<br><img src="http://pic.fengyuwusong.cn/20220509002839.png" alt="GPM模型"><br><img src="http://pic.fengyuwusong.cn/20220509002636.png" alt="旧版调度流程"></p><ul><li>缺点<ol><li>创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。</li><li>M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li><li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li></ol></li></ul><h5 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h5><p><img src="http://pic.fengyuwusong.cn/20220509002911.png" alt="GPM模型"></p><ul><li>模型相关<ol><li>全局队列（Global Queue）：存放等待运行的G。</li><li>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li><li>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</li><li>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li></ol></li><li>P和M的个数问题<ul><li>P的数量<ul><li>由启动时环境变量<code>$GOMAXPROCS</code>或者是由<code>runtime</code>的方法<code>GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有<code>$GOMAXPROCS个goroutine</code>在同时运行。</li><li>M的数量<ul><li>go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li><li><code>runtime/debug</code>中的<code>SetMaxThreads</code>函数，设置M的最大数量</li><li>一个M阻塞了，会创建新的M。</li></ul></li><li>P和M的关系<ul><li>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</li></ul></li><li>P和M何时被创建<ul><li>P：在确定P的最大数量n后，运行时系统会根据这个数量创建n个P</li><li>M：没有足够的M来关联P并运行其中可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</li></ul></li></ul></li></ul></li></ul><h5 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h5><ul><li>复用线程<ul><li>work stealing机制：当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</li><li>hand off机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</li></ul></li><li>利用并行<ul><li>GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。</li></ul></li><li>抢占<ul><li>在coroutine中要等待一个协程主动让出CPU才执行下一个协程，<strong>在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</strong></li></ul></li><li>全局G队列<ul><li>在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</li></ul></li></ul><h5 id="go-func-调度流程"><a href="#go-func-调度流程" class="headerlink" title="go func()调度流程"></a><code>go func()</code>调度流程</h5><p><img src="http://pic.fengyuwusong.cn/20220509004938.png" alt="go func()调度流程"></p><p> 1、我们通过 go func()来创建一个goroutine；<br> 2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；<br> 3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；<br> 4、一个M调度G执行的过程是一个循环机制；<br> 5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；<br> 6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p><h5 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h5><p><img src="http://pic.fengyuwusong.cn/20220509005403.png" alt="调度器的声生命周期"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>M0&amp;G0<ul><li>M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</li><li>G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</li></ul></li><li>生命周期流程<ol><li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li><li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li><li>示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li><li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li><li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li><li>M运行G</li><li>G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。</li></ol></li></ul><h5 id="可视化GMP编程"><a href="#可视化GMP编程" class="headerlink" title="可视化GMP编程"></a>可视化GMP编程</h5><ul><li><code>go tool trace</code></li></ul><p>trace记录了运行时的信息，能提供可视化的Web页面。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime/trace"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动trace goroutine</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Debug trace</code></li></ul><p>编译二进制包后使用以下方式执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> GODEBUG=schedtrace=1000 ./trace2</span></span><br><span class="line">SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 1003ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 2014ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 3015ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 4023ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><ul><li>执行方式：<code>GODEBUG=schedtrace=1000 ./trace2</code></li><li>说明<ul><li>SCHED：调试信息输出标志字符串，代表本行是goroutine调度器的输出；</li><li>0ms：即从程序启动到输出这行日志的时间；</li><li>gomaxprocs: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；</li><li>idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；</li><li>threads: os threads/M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；</li><li>spinningthreads: 处于自旋状态的os thread数量；</li><li>idlethread: 处于idle状态的os thread的数量；</li><li>runqueue=0： Scheduler全局队列中G的数量；</li><li>[0 0]: 分别为2个P的local queue中的G的数量。</li></ul></li></ul><h4 id="Go调度器调度场景过程全解析"><a href="#Go调度器调度场景过程全解析" class="headerlink" title="Go调度器调度场景过程全解析"></a>Go调度器调度场景过程全解析</h4><p>具体参考下列文章，重点如下：</p><ul><li>新建G会优先放到当前的P本地队列</li><li>M执行完G时，会先切换G0负责协程的调度切换，从而执行下一个G</li><li>当开辟过多G，P本地队列装不下的时候，则会执行负载均衡（把P本地队列前一半的G和新建的G打乱顺序转移到全局队列【新建的G不一定会转移，需视是否需立即执行决定】）</li><li>创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行</li><li>空闲M从全局队列GQ获取G的数量符合公式：<code>n =  min(len(GQ) / GOMAXPROCS +  1,  cap(LQ) / 2 )</code></li><li>如全局队列已经没有G，则m需要自行<code>work stealing</code>: 从其他P的本地队列中偷取一半的G，放到自己的P队列</li><li>空闲线程如没有G执行，则会让其处于自旋状态【由于创建销毁本身也需消耗资源，故保存自旋当有新的G时可立马执行】，最多有GOMAXPROCS个自旋线程</li><li>当G进行了系统调用时，则M和P会立即解绑，此时如P本地队列存在G、全局队列有G或有空闲的M，P都会立马唤醒一个M和它绑定，否则P会加入空闲P列表，等待M来获取【即当前M用于执行阻塞系统调用的G，此时M无P绑定】</li><li>假设G进行的系统调用并非阻塞，则M执行完毕系统后，G会重新投入G全局队列中并标记为可运行状态，同时M会重新尝试获取之前绑定的P，如该P已被其他M绑定，则从空闲队列中获取P，如仍获取失败则M因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.yuque.com/aceld/golang/srxd6d" target="_blank" rel="noopener">Golang的协程调度器原理及GMP设计思想</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> GMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go应用问题排查常用方法</title>
      <link href="/2022/05/05/go%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2022/05/05/go%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一般来说，在开发过程中我们的应用都会遇上各种问题场景，下面关于以下几种常见场景的排查分析问题常见方法进行一定的总结：</p><ul><li>分析程序运行时间和CPU利用率情况</li><li>分析golang程序内存占用情况</li><li>分析golang程序CPU性能情况</li></ul><a id="more"></a><h3 id="场景1：-如何分析程序的运行时间与CPU利用率情况？"><a href="#场景1：-如何分析程序的运行时间与CPU利用率情况？" class="headerlink" title="场景1： 如何分析程序的运行时间与CPU利用率情况？"></a>场景1： 如何分析程序的运行时间与CPU利用率情况？</h3><h4 id="1-shell内置time指令"><a href="#1-shell内置time指令" class="headerlink" title="(1) shell内置time指令"></a>(1) shell内置time指令</h4><p>这个方法不算新颖，但是确很实用。 time是Unix/Linux内置多命令，使用时一般不用传过多参数，直接跟上需要调试多程序即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> time go run test2.go</span></span><br><span class="line">&amp;&#123;&#123;0 0&#125; 张三 0&#125;</span><br><span class="line"></span><br><span class="line">real 0m0.843s</span><br><span class="line">user 0m0.216s</span><br><span class="line">sys 0m0.389s</span><br></pre></td></tr></table></figure><p>上面是使用time对 go run test2.go对执行程序坐了性能分析，得到3个指标。</p><p>● real：从程序开始到结束，实际度过的时间；<br>● user：程序在用户态度过的时间；<br>● sys：程序在内核态度过的时间。</p><p>一般情况下 <code>real &gt;= user + sys</code>，因为系统还有其它进程(切换其他进程中间对于本进程会有空白期)。</p><h3 id="2-usr-bin-time指令"><a href="#2-usr-bin-time指令" class="headerlink" title="2) /usr/bin/time指令"></a>2) /usr/bin/time指令</h3><p>这个指令比内置的time更加详细一些，使用的时候需要用绝对路径，而且<strong>要加上参数-v</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /usr/bin/time -v go run test2.go  </span></span><br><span class="line"></span><br><span class="line"> Command being timed: "go run test2.go"</span><br><span class="line"> User time (seconds): 0.12</span><br><span class="line"> System time (seconds): 0.06</span><br><span class="line"> Percent of CPU this job got: 115%</span><br><span class="line"> Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.16</span><br><span class="line"> Average shared text size (kbytes): 0</span><br><span class="line"> Average unshared data size (kbytes): 0</span><br><span class="line"> Average stack size (kbytes): 0</span><br><span class="line"> Average total size (kbytes): 0</span><br><span class="line"> Maximum resident set size (kbytes): 41172</span><br><span class="line"> Average resident set size (kbytes): 0</span><br><span class="line"> Major (requiring I/O) page faults: 1</span><br><span class="line"> Minor (reclaiming a frame) page faults: 15880</span><br><span class="line"> Voluntary context switches: 897</span><br><span class="line"> Involuntary context switches: 183</span><br><span class="line"> Swaps: 0</span><br><span class="line"> File system inputs: 256</span><br><span class="line"> File system outputs: 2664</span><br><span class="line"> Socket messages sent: 0</span><br><span class="line"> Socket messages received: 0</span><br><span class="line"> Signals delivered: 0</span><br><span class="line"> Page size (bytes): 4096</span><br><span class="line"> Exit status: 0</span><br></pre></td></tr></table></figure><p>可以看到这里的功能要强大多了，除了之前的信息外，还包括了：</p><p>● CPU占用率；<br>● 内存使用情况；<br>● Page Fault 情况；<br>● 进程切换情况；<br>● 文件系统IO；<br>● Socket 使用情况；<br>● ……</p><h3 id="场景2：-如何分析golang程序的内存使用情况？"><a href="#场景2：-如何分析golang程序的内存使用情况？" class="headerlink" title="场景2： 如何分析golang程序的内存使用情况？"></a>场景2： 如何分析golang程序的内存使用情况？</h3><h4 id="1-内存占用情况查看"><a href="#1-内存占用情况查看" class="headerlink" title="(1) 内存占用情况查看"></a>(1) 内存占用情况查看</h4><p>我们先写一段demo例子代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//slice 会动态扩容，用slice来做堆内存申请</span></span><br><span class="line">    container := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">" ===&gt; loop begin."</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>*<span class="number">1000</span>*<span class="number">1000</span>; i++ &#123;</span><br><span class="line">        container = <span class="built_in">append</span>(container, i)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">" ===&gt; loop end."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"Start."</span>)</span><br><span class="line"></span><br><span class="line">    test()</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">"force gc."</span>)</span><br><span class="line">    runtime.GC() <span class="comment">//强制调用gc回收</span></span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">"Done."</span>)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3600</span> * time.Second) <span class="comment">//睡眠，保持程序不退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">go build -o snippet_mem &amp;&amp; ./snippet_mem</span></span><br></pre></td></tr></table></figure><p>然后在<code>./snippet_mem</code>进程没有执行完，我们再开一个窗口，通过top命令查看进程的内存占用情况</p><p><code>$top -p $(pidof snippet_mem)</code></p><p>得到结果如下：</p><p><img src="https://pic.fengyuwusong.cn/20220506100834.png" alt="top结果"></p><p>我们看出来，没有退出的snippet_mem进程有约770m的内存被占用。</p><p>直观上来说，这个程序在test()函数执行完后，切片contaner的内存应该被释放，不应该占用770m那么大。</p><p>下面让我们使用GODEBUG来分析程序的内存使用情况。</p><h4 id="2-GODEBUG与gctrace"><a href="#2-GODEBUG与gctrace" class="headerlink" title="(2) GODEBUG与gctrace"></a>(2) GODEBUG与gctrace</h4><ul><li>用法</li></ul><p>执行<code>snippet_mem</code>程序之前添加环境变量<code>GODEBUG=&#39;gctrace=1&#39;</code>来跟踪打印垃圾回收器信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GODEBUG='gctrace=1' ./snippet_mem</span><br></pre></td></tr></table></figure><p>设置<code>gctrace=1</code>会使得垃圾回收器在每次回收时汇总所回收内存的大小以及耗时，<br>并将这些内容汇总成单行内容打印到标准错误输出中。</p><ul><li>格式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&gt;#-&gt;# MB, # MB goal, # P</span><br></pre></td></tr></table></figure><ul><li>含义</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gc #        GC次数的编号，每次GC时递增</span><br><span class="line"><span class="meta">@#</span><span class="bash">s         距离程序开始执行时的时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash">%          GC占用的执行时间百分比</span></span><br><span class="line"><span class="meta">#</span><span class="bash">+...+<span class="comment">#     GC使用的时间</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">-&gt;<span class="comment">#-&gt;# MB  GC开始，结束，以及当前活跃堆内存的大小，单位M</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MB goal   全局堆内存大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> P         使用processor的数量</span></span><br></pre></td></tr></table></figure><p>如果每条信息最后，以(forced)结尾，那么该信息是由runtime.GC()调用触发</p><p>我们来选择其中一行来解释一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gc 17 @0.149s 1%: 0.004+36+0.003 ms clock, 0.009+0/0.051/36+0.006 ms cpu, 181-&gt;181-&gt;101 MB, 182 MB goal, 2 P</span><br></pre></td></tr></table></figure><p>该条信息含义如下：</p><p>● gc 17: Gc 调试编号为17<br>● @0.149s:此时程序已经执行了0.149s<br>● 1%: 0.149s中其中gc模块占用了1%的时间<br>● 0.004+36+0.003 ms clock: 垃圾回收的时间，分别为STW（stop-the-world）清扫的时间+并发标记和扫描的时间+STW标记的时间<br>● 0.009+0/0.051/36+0.006 ms cpu: 垃圾回收占用cpu时间<br>● 181-&gt;181-&gt;101 MB： GC开始前堆内存181M， GC结束后堆内存181M，当前活跃的堆内存101M<br>● 182 MB goal: 全局堆内存大小<br>● 2 P: 本次GC使用了2个P(调度器中的Processer)</p><p>了解了GC的调试信息读法后，接下来我们来分析一下本次GC的结果。</p><p>我们还是执行GODEBUG调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GODEBUG='gctrace=1' ./snippet_mem</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">➜  study git:(main) ✗ GODEBUG='gctrace=1' ./main</span><br><span class="line">2022/05/06 10:16:30 Start.</span><br><span class="line">2022/05/06 10:16:30  ===&gt; loop begin.</span><br><span class="line">gc 1 @0.001s 3%: 0.008+0.42+0.002 ms clock, 0.017+0/0.10/0.33+0.004 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 2 P</span><br><span class="line">gc 2 @0.002s 2%: 0.006+1.6+0.003 ms clock, 0.012+0/0.10/0.59+0.006 ms cpu, 4-&gt;6-&gt;3 MB, 5 MB goal, 2 P</span><br><span class="line">gc 3 @0.004s 2%: 0.007+1.4+0.001 ms clock, 0.014+0/0.10/1.3+0.003 ms cpu, 8-&gt;8-&gt;2 MB, 9 MB goal, 2 P</span><br><span class="line">gc 4 @0.006s 3%: 0.017+0.49+0.001 ms clock, 0.034+0.11/0/0+0.003 ms cpu, 6-&gt;6-&gt;3 MB, 7 MB goal, 2 P</span><br><span class="line">gc 5 @0.007s 9%: 0.32+0.54+0.001 ms clock, 0.65+0.020/0.41/0+0.003 ms cpu, 8-&gt;8-&gt;4 MB, 9 MB goal, 2 P</span><br><span class="line">gc 6 @0.008s 7%: 0.006+2.5+0.002 ms clock, 0.013+0.005/0.075/2.4+0.005 ms cpu, 10-&gt;10-&gt;5 MB, 11 MB goal, 2 P</span><br><span class="line">gc 7 @0.011s 9%: 0.024+2.5+0.003 ms clock, 0.048+0.020/0.91/0+0.006 ms cpu, 12-&gt;12-&gt;6 MB, 13 MB goal, 2 P</span><br><span class="line">gc 8 @0.014s 9%: 0.11+1.7+0.001 ms clock, 0.23+0.10/0/0+0.003 ms cpu, 15-&gt;15-&gt;8 MB, 16 MB goal, 2 P</span><br><span class="line">gc 9 @0.016s 7%: 0.007+5.4+0.004 ms clock, 0.015+0/0.074/5.1+0.008 ms cpu, 19-&gt;19-&gt;10 MB, 20 MB goal, 2 P</span><br><span class="line">gc 10 @0.021s 6%: 0.007+1.4+0.002 ms clock, 0.014+0/0.076/1.2+0.005 ms cpu, 24-&gt;24-&gt;13 MB, 25 MB goal, 2 P</span><br><span class="line">gc 11 @0.023s 6%: 0.007+3.0+0.003 ms clock, 0.014+0/0.083/2.9+0.007 ms cpu, 30-&gt;30-&gt;16 MB, 31 MB goal, 2 P</span><br><span class="line">gc 12 @0.027s 14%: 0.050+9.4+0.004 ms clock, 0.10+0.012/7.2/0.009+0.008 ms cpu, 38-&gt;38-&gt;21 MB, 39 MB goal, 2 P</span><br><span class="line">gc 13 @0.037s 13%: 0.007+2.7+0.003 ms clock, 0.014+0/0.091/2.5+0.006 ms cpu, 47-&gt;47-&gt;26 MB, 48 MB goal, 2 P</span><br><span class="line">gc 14 @0.040s 17%: 0.084+5.8+0.003 ms clock, 0.16+0.021/5.3/0+0.007 ms cpu, 59-&gt;59-&gt;33 MB, 60 MB goal, 2 P</span><br><span class="line">gc 15 @0.046s 26%: 0.027+19+0.004 ms clock, 0.054+0.022/19/0+0.009 ms cpu, 74-&gt;74-&gt;41 MB, 75 MB goal, 2 P</span><br><span class="line">gc 16 @0.066s 24%: 0.007+5.2+0.003 ms clock, 0.014+0/0.11/4.9+0.007 ms cpu, 93-&gt;93-&gt;51 MB, 94 MB goal, 2 P</span><br><span class="line">gc 17 @0.072s 27%: 0.008+10+0.005 ms clock, 0.017+0.010/10/0.010+0.010 ms cpu, 116-&gt;116-&gt;64 MB, 117 MB goal, 2 P</span><br><span class="line">gc 18 @0.084s 18%: 0.007+40+0.005 ms clock, 0.015+0/0.080/39+0.010 ms cpu, 145-&gt;145-&gt;145 MB, 146 MB goal, 2 P</span><br><span class="line">gc 19 @0.167s 10%: 0.016+59+0.004 ms clock, 0.032+0/0.082/58+0.009 ms cpu, 372-&gt;372-&gt;126 MB, 373 MB goal, 2 P</span><br><span class="line">gc 20 @0.227s 12%: 0.34+15+0.015 ms clock, 0.69+0/14/0+0.030 ms cpu, 284-&gt;284-&gt;284 MB, 285 MB goal, 2 P</span><br><span class="line">gc 2022/05/06 10:16:30  ===&gt; loop end.</span><br><span class="line">21 @0.3242022/05/06 10:16:30 force gc.</span><br><span class="line">s 5%: 0.014+198+0.003 ms clock, 0.029+0/0.089/198+0.006 ms cpu, 728-&gt;728-&gt;0 MB, 729 MB goal, 2 P</span><br><span class="line">2022/05/06 10:16:30 Done.</span><br><span class="line">gc 22 @0.523s 5%: 0.006+2.4+0.002 ms clock, 0.013+0/0.045/2.4+0.005 ms cpu, 0-&gt;0-&gt;0 MB, 4 MB goal, 2 P (forced)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 分析</span><br><span class="line"></span><br><span class="line"> 先看在test()函数执行完后立即打印的gc 21那行的信息。&#96;728-&gt;728-&gt;0 MB, 729 MB goal&#96;表示垃圾回收器已经把729M的内存标记为非活跃的内存。</span><br><span class="line"></span><br><span class="line">再看下一个记录&#96;gc 22。0-&gt;0-&gt;0 MB, 4 MB goal&#96;表示垃圾回收器中的全局堆内存大小由729M下降为4M。</span><br><span class="line"></span><br><span class="line">- 结论</span><br><span class="line"></span><br><span class="line">1、在test()函数执行完后，demo程序中的切片容器所申请的堆空间都被垃圾回收器回收了。</span><br><span class="line"></span><br><span class="line">2、如果此时在top指令查询内存的时候，如果依然是800+MB，说明垃圾回收器回收了应用层的内存后，（可能）并不会立即将内存归还给系统。</span><br><span class="line"></span><br><span class="line">#### (3) runtime.ReadMemStats</span><br><span class="line"></span><br><span class="line">接下来我么换另一种方式查看内存的方式 利用 runtime库里的ReadMemStats()方法</span><br><span class="line"></span><br><span class="line">demo2.go</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func readMemStats() &#123;</span><br><span class="line"></span><br><span class="line">    var ms runtime.MemStats</span><br><span class="line"></span><br><span class="line">    runtime.ReadMemStats(&amp;ms)</span><br><span class="line"></span><br><span class="line">    log.Printf(&quot; &#x3D;&#x3D;&#x3D;&gt; Alloc:%d(bytes) HeapIdle:%d(bytes) HeapReleased:%d(bytes)&quot;, ms.Alloc, ms.HeapIdle, ms.HeapReleased)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() &#123;</span><br><span class="line">    &#x2F;&#x2F;slice 会动态扩容，用slice来做堆内存申请</span><br><span class="line">    container :&#x3D; make([]int, 8)</span><br><span class="line"></span><br><span class="line">    log.Println(&quot; &#x3D;&#x3D;&#x3D;&gt; loop begin.&quot;)</span><br><span class="line">    for i :&#x3D; 0; i &lt; 32*1000*1000; i++ &#123;</span><br><span class="line">        container &#x3D; append(container, i)</span><br><span class="line">        if ( i &#x3D;&#x3D; 16*1000*1000) &#123;</span><br><span class="line">            readMemStats()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Println(&quot; &#x3D;&#x3D;&#x3D;&gt; loop end.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    log.Println(&quot; &#x3D;&#x3D;&#x3D;&gt; [Start].&quot;)</span><br><span class="line"></span><br><span class="line">    readMemStats()</span><br><span class="line">    test()</span><br><span class="line">    readMemStats()</span><br><span class="line"></span><br><span class="line">    log.Println(&quot; &#x3D;&#x3D;&#x3D;&gt; [force gc].&quot;)</span><br><span class="line">    runtime.GC() &#x2F;&#x2F;强制调用gc回收</span><br><span class="line"></span><br><span class="line">    log.Println(&quot; &#x3D;&#x3D;&#x3D;&gt; [Done].&quot;)</span><br><span class="line">    readMemStats()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            readMemStats()</span><br><span class="line">            time.Sleep(10 * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(3600 * time.Second) &#x2F;&#x2F;睡眠，保持程序不退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们， 封装了一个函数readMemStats()，这里面主要是调用runtime中的ReadMemStats()方法获得内存信息，然后通过log打印出来。</p><p>我们执行一下代码并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  study git:(main) ✗ go run demo2.go </span><br><span class="line">2022/05/06 10:21:59  ===&gt; [Start].</span><br><span class="line">2022/05/06 10:21:59  ===&gt; Alloc:63872(bytes) HeapIdle:66592768(bytes) HeapReleased:66560000(bytes)</span><br><span class="line">2022/05/06 10:21:59  ===&gt; loop begin.</span><br><span class="line">2022/05/06 10:21:59  ===&gt; Alloc:238511072(bytes) HeapIdle:96509952(bytes) HeapReleased:96378880(bytes)</span><br><span class="line">2022/05/06 10:21:59  ===&gt; loop end.</span><br><span class="line">2022/05/06 10:21:59  ===&gt; Alloc:631416280(bytes) HeapIdle:173424640(bytes) HeapReleased:141795328(bytes)</span><br><span class="line">2022/05/06 10:21:59  ===&gt; [force gc].</span><br><span class="line">2022/05/06 10:21:59  ===&gt; [Done].</span><br><span class="line">2022/05/06 10:21:59  ===&gt; Alloc:51040(bytes) HeapIdle:804790272(bytes) HeapReleased:141795328(bytes)</span><br><span class="line">2022/05/06 10:21:59  ===&gt; Alloc:52064(bytes) HeapIdle:804782080(bytes) HeapReleased:141787136(bytes)</span><br><span class="line">2022/05/06 10:22:09  ===&gt; Alloc:52272(bytes) HeapIdle:804782080(bytes) HeapReleased:141795328(bytes)</span><br><span class="line">2022/05/06 10:22:19  ===&gt; Alloc:52416(bytes) HeapIdle:804782080(bytes) HeapReleased:202391552(bytes)</span><br></pre></td></tr></table></figure><p> 可以看到，打印[Done].之后那条trace信息，Alloc已经下降，即内存已被垃圾回收器回收。在2022/05/06 10:22:19的这条trace信息中，HeapReleased开始上升，即垃圾回收器把内存归还给系统。</p><p>另外，MemStats还可以获取其它哪些信息以及字段的含义可以参见<a href="http://golang.org/pkg/runtime/#MemStats" target="_blank" rel="noopener">官方文档</a></p><h4 id="4-pprof工具"><a href="#4-pprof工具" class="headerlink" title="(4) pprof工具"></a>(4) pprof工具</h4><p>pprof工具支持网页上查看内存的使用情况，需要在代码中添加一个协程即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line"> <span class="string">"net/http"</span></span><br><span class="line"> _ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"> log.Println(http.ListenAndServe(<span class="string">"0.0.0.0:10000"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">具体添加的完整代码如下：</span><br><span class="line"></span><br><span class="line">demo3.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    _ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ms runtime.MemStats</span><br><span class="line"></span><br><span class="line">    runtime.ReadMemStats(&amp;ms)</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">" ===&gt; Alloc:%d(bytes) HeapIdle:%d(bytes) HeapReleased:%d(bytes)"</span>, ms.Alloc, ms.HeapIdle, ms.HeapReleased)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//slice 会动态扩容，用slice来做堆内存申请</span></span><br><span class="line">    container := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">" ===&gt; loop begin."</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>*<span class="number">1000</span>*<span class="number">1000</span>; i++ &#123;</span><br><span class="line">        container = <span class="built_in">append</span>(container, i)</span><br><span class="line">        <span class="keyword">if</span> ( i == <span class="number">16</span>*<span class="number">1000</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">            readMemStats()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">" ===&gt; loop end."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动pprof</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Println(http.ListenAndServe(<span class="string">"0.0.0.0:10000"</span>, <span class="literal">nil</span>))</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">" ===&gt; [Start]."</span>)</span><br><span class="line"></span><br><span class="line">    readMemStats()</span><br><span class="line">    test()</span><br><span class="line">    readMemStats()</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">" ===&gt; [force gc]."</span>)</span><br><span class="line">    runtime.GC() <span class="comment">//强制调用gc回收</span></span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">" ===&gt; [Done]."</span>)</span><br><span class="line">    readMemStats()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            readMemStats()</span><br><span class="line">            time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3600</span> * time.Second) <span class="comment">//睡眠，保持程序不退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们正常运行程序，然后同时打开浏览器，</p><p>输入地址：<a href="http://127.0.0.1:10000/debug/pprof/heap?debug=1" target="_blank" rel="noopener">http://127.0.0.1:10000/debug/pprof/heap?debug=1</a></p><p>浏览器的内容其中有一部分如下，记录了目前的内存情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> runtime.MemStats</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Alloc = 228248</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> TotalAlloc = 1293696976</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Sys = 834967896</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Lookups = 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Mallocs = 2018</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Frees = 671</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> HeapAlloc = 228248</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> HeapSys = 804913152</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> HeapIdle = 804102144</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> HeapInuse = 811008</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> HeapReleased = 108552192</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> HeapObjects = 1347</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Stack = 360448 / 360448</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> MSpan = 28288 / 32768</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> MCache = 3472 / 16384</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> BuckHashSys = 1449617</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> GCSys = 27418976</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> OtherSys = 776551</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> NextGC = 4194304</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> LastGC = 1583203571137891390</span></span><br></pre></td></tr></table></figure><h3 id="场景3-如何分析Golang程序的CPU性能情况？"><a href="#场景3-如何分析Golang程序的CPU性能情况？" class="headerlink" title="场景3: 如何分析Golang程序的CPU性能情况？"></a>场景3: 如何分析Golang程序的CPU性能情况？</h3><h4 id="1-性能分析注意事项"><a href="#1-性能分析注意事项" class="headerlink" title="(1)性能分析注意事项"></a>(1)性能分析注意事项</h4><p>●  性能分析必须在一个<br>可重复的、稳定的环境中来进行。<br>  ○ 机器必须闲置<br>    ■ 不要在共享硬件上进行性能分析;<br>    ■ 不要在性能分析期间，在同一个机器上去浏览网页<br>  ○ 注意省电模式和过热保护，如果突然进入这些模式，会导致分析数据严重不准确<br>  ○ 不要使用虚拟机、共享的云主机，太多干扰因素，分析数据会很不一致；<br>  ○ 不要在 macOS 10.11 及以前的版本运行性能分析，有 bug，之后的版本修复了。</p><p>如果承受得起，购买专用的性能测试分析的硬件设备，上架。</p><p>● 关闭电源管理、过热管理;<br>● 绝不要升级，以保证测试的一致性，以及具有可比性。</p><p>如果没有这样的环境，那就一定要在多个环境中，执行多次，以取得可参考的、具有相对一致性的测试结果。</p><h4 id="2-CPU性能分析"><a href="#2-CPU性能分析" class="headerlink" title="(2) CPU性能分析"></a>(2) CPU性能分析</h4><p>我们来用下面的代码进行测试</p><p>demo4.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    _ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">" ===&gt; loop begin."</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        log.Println(genSomeBytes())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">" ===&gt; loop end."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成一个随机字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genSomeBytes</span><span class="params">()</span> *<span class="title">bytes</span>.<span class="title">Buffer</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buff bytes.Buffer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">20000</span>; i++ &#123;</span><br><span class="line">        buff.Write([]<span class="keyword">byte</span>&#123;<span class="string">'0'</span> + <span class="keyword">byte</span>(rand.Intn(<span class="number">10</span>))&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;buff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            test()</span><br><span class="line">            time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动pprof</span></span><br><span class="line">    http.ListenAndServe(<span class="string">"0.0.0.0:10000"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面还是启动了pprof的坚挺,有关pprof启动的代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    "net/http"</span><br><span class="line">    _ "net/http/pprof"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> //...</span><br><span class="line">  //...</span><br><span class="line">  </span><br><span class="line">  //启动pprof</span><br><span class="line">  http.ListenAndServe("0.0.0.0:10000", nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()里的流程很简单,启动一个goroutine去无限循环调用test()方法,休眠1s.</p><p>test()的流程是生成1000个20000个字符的随机字符串.并且打印.</p><p>我们将上面的代码编译成可执行的二进制文件 demo4(记住这个名字,稍后我们能用到)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build demo4.go</span></span><br></pre></td></tr></table></figure><p>接下来我们启动程序,程序会无限循环的打印字符串.</p><p>接下来我们通过几种方式来查看进程的cpu性能情况.</p><h5 id="A-Web界面查看"><a href="#A-Web界面查看" class="headerlink" title="A. Web界面查看"></a>A. Web界面查看</h5><p>浏览器访问<a href="http://127.0.0.1:10000/debug/pprof/" target="_blank" rel="noopener">http://127.0.0.1:10000/debug/pprof/</a></p><p>我们会看到如下画面</p><p>这里面能够通过pprof查看包括(阻塞信息、cpu信息、内存堆信息、锁信息、goroutine信息等等), 我们这里关心的cpu的性能的profile信息.</p><p>有关profile下面的英文解释大致如下:</p><p>“CPU配置文件。您可以在秒GET参数中指定持续时间。获取概要文件后，请使用go tool pprof命令调查概要文件。”</p><p>所以我们要是想得到cpu性能,就是要获取到当前进程的profile文件,这个文件默认是30s生成一个,所以你的程序要至少运行30s以上(这个参数也可以修改,稍后我们介绍)</p><p>我们可以直接点击网页的profile,浏览器会给我们下载一个profile文件. 记住这个文件的路径, 可以拷贝到与demo4所在的同一文件夹下.</p><h5 id="B-使用pprof工具查看"><a href="#B-使用pprof工具查看" class="headerlink" title="B. 使用pprof工具查看"></a>B. 使用pprof工具查看</h5><p>pprof 的格式如下</p><p>go tool pprof [binary] [profile]</p><p>binary: 必须指向生成这个性能分析数据的那个二进制可执行文件；</p><p>profile: 必须是该二进制可执行文件所生成的性能分析数据文件。</p><p>binary 和 profile 必须严格匹配。</p><p>我们来查看一下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool pprof ./demo4 profile</span></span><br><span class="line"></span><br><span class="line">File: demo4</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Mar 3, 2020 at 11:18pm (CST)</span><br><span class="line">Duration: 30.13s, Total samples = 6.27s (20.81%)</span><br><span class="line">Entering interactive mode (type "help" for commands, "o" for options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure><p>help可以查看一些指令,我么可以通过top来查看cpu的性能情况.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 8420ms, 84.79% of 9930ms total</span><br><span class="line">Dropped 116 nodes (cum &lt;= 49.65ms)</span><br><span class="line">Showing top 10 nodes out of 83</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    2190ms 22.05% 22.05%     4350ms 43.81%  math/rand.(*Rand).Int31n</span><br><span class="line">    1530ms 15.41% 37.46%     5880ms 59.21%  math/rand.(*Rand).Intn</span><br><span class="line">    1240ms 12.49% 49.95%     1240ms 12.49%  sync.(*Mutex).Unlock (inline)</span><br><span class="line">    1130ms 11.38% 61.33%     1170ms 11.78%  syscall.Syscall</span><br><span class="line">     610ms  6.14% 67.47%     2060ms 20.75%  math/rand.(*lockedSource).Int63</span><br><span class="line">     550ms  5.54% 73.01%     7500ms 75.53%  main.genSomeBytes</span><br><span class="line">     420ms  4.23% 77.24%      990ms  9.97%  bytes.(*Buffer).Write</span><br><span class="line">     280ms  2.82% 80.06%      280ms  2.82%  runtime.futex</span><br><span class="line">     240ms  2.42% 82.48%      240ms  2.42%  runtime.usleep</span><br><span class="line">     230ms  2.32% 84.79%      230ms  2.32%  runtime.memmove</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure><p>这里面有几列数据,需要说明一下.</p><p>● flat：当前函数占用CPU的耗时<br>● flat：:当前函数占用CPU的耗时百分比<br>● sun%：函数占用CPU的耗时累计百分比<br>● cum：当前函数加上调用当前函数的函数占用CPU的总耗时<br>● cum%：当前函数加上调用当前函数的函数占用CPU的总耗时百分比<br>● 最后一列：函数名称</p><p>通过结果我们可以看出, 该程序的大部分cpu性能消耗在 main.getSomeBytes()方法中,其中math/rand取随机数消耗比较大.</p><h5 id="C-通过go-tool-pprof得到profile文件"><a href="#C-通过go-tool-pprof得到profile文件" class="headerlink" title="C. 通过go tool pprof得到profile文件"></a>C. 通过go tool pprof得到profile文件</h5><p>我们上面的profile文件是通过web浏览器下载的,这个profile的经过时间是30s的,默认值我们在浏览器上修改不了,如果你想得到时间更长的cpu利用率,可以通过go tool pprof指令与程序交互来获取到</p><p>首先,我们先启动程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./demo4</span></span><br></pre></td></tr></table></figure><p>然后再打开一个终端</p><p>go tool pprof <a href="http://localhost:10000/debug/pprof/profile?seconds=60" target="_blank" rel="noopener">http://localhost:10000/debug/pprof/profile?seconds=60</a></p><p>这里制定了生成profile文件的时间间隔60s</p><p>等待60s之后, 终端就会有结果出来,我们继续使用top来查看.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool pprof &lt;http://localhost:10000/debug/pprof/profile?seconds=60&gt;</span></span><br><span class="line">Fetching profile over HTTP from &lt;http://localhost:10000/debug/pprof/profile?seconds=60&gt;</span><br><span class="line">Saved profile in /home/itheima/pprof/pprof.demo4.samples.cpu.005.pb.gz</span><br><span class="line">File: demo4</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Mar 3, 2020 at 11:59pm (CST)</span><br><span class="line">Duration: 1mins, Total samples = 12.13s (20.22%)</span><br><span class="line">Entering interactive mode (type "help" for commands, "o" for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 9940ms, 81.95% of 12130ms total</span><br><span class="line">Dropped 110 nodes (cum &lt;= 60.65ms)</span><br><span class="line">Showing top 10 nodes out of 56</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    2350ms 19.37% 19.37%     4690ms 38.66%  math/rand.(*lockedSource).Int63</span><br><span class="line">    1770ms 14.59% 33.97%     1770ms 14.59%  sync.(*Mutex).Unlock (inline)</span><br><span class="line">    1290ms 10.63% 44.60%     6040ms 49.79%  math/rand.(*Rand).Int31n</span><br><span class="line">    1110ms  9.15% 53.75%     1130ms  9.32%  syscall.Syscall</span><br><span class="line">     810ms  6.68% 60.43%     1860ms 15.33%  bytes.(*Buffer).Write</span><br><span class="line">     620ms  5.11% 65.54%     6660ms 54.91%  math/rand.(*Rand).Intn</span><br><span class="line">     570ms  4.70% 70.24%      570ms  4.70%  runtime.procyield</span><br><span class="line">     500ms  4.12% 74.36%     9170ms 75.60%  main.genSomeBytes</span><br><span class="line">     480ms  3.96% 78.32%      480ms  3.96%  runtime.memmove</span><br><span class="line">     440ms  3.63% 81.95%      440ms  3.63%  math/rand.(*rngSource).Uint64</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure><p>依然会得到cpu性能的结果, 我们发现这次的结果与上次30s的结果百分比类似.</p><h5 id="D-可视化查看"><a href="#D-可视化查看" class="headerlink" title="D.可视化查看"></a>D.可视化查看</h5><p>我们还是通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof ./demo4 profile</span><br></pre></td></tr></table></figure><p>进入profile文件查看,然后我们输入web指令.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool pprof ./demo4 profileFile: demo4</span></span><br><span class="line">Type: cpu</span><br><span class="line">Time: Mar 3, 2020 at 11:18pm (CST)</span><br><span class="line">Duration: 30.13s, Total samples = 6.27s (20.81%)</span><br><span class="line">Entering interactive mode (type "help" for commands, "o" for options)</span><br><span class="line">(pprof) web</span><br></pre></td></tr></table></figure><p>这里如果报找不到graphviz工具,需要安装一下</p><p>Ubuntu安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt-get install graphviz</span></span><br></pre></td></tr></table></figure><p>Mac安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure><p>windows安装</p><p>下载<a href="https://graphviz.gitlab.io/_pages/Download/Download_windows.html" target="_blank" rel="noopener">https://graphviz.gitlab.io/_pages/Download/Download_windows.html</a></p><p>将graphviz安装目录下的bin文件夹添加到Path环境变量中。 在终端输入dot -version查看是否安装成功。</p><p>然后我们得到一个svg的可视化文件在/tmp路径下</p><p>这样我们就能比较清晰的看到函数之间的调用关系,方块越大的表示cpu的占用越大.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.yuque.com/aceld/golang/ga6pb1" target="_blank" rel="noopener">最常用的调试 golang 的 bug 以及性能问题的实践方法</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 编程 </tag>
            
            <tag> 问题排查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单讲讲一次http请求中的网络流程</title>
      <link href="/2022/04/28/http%E8%AF%B7%E6%B1%82%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/04/28/http%E8%AF%B7%E6%B1%82%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>平时无论是生活，还是工作中。我们浏览网页都逃不开一个个的http请求，同时在面试上也经常会被问及：<strong>简单说说一次http请求的整个流程</strong>？下面也是基于这个点，结合已掌握的知识，这里把相关的流程简单讲一下。</p><a id="more"></a><h3 id="1-获取IP"><a href="#1-获取IP" class="headerlink" title="1. 获取IP"></a>1. 获取IP</h3><ul><li>静态配置</li><li>动态配置（DHCP）<br><img src="https://pic.fengyuwusong.cn/20220429105727.png" alt="DHCP流程"></li></ul><p>后续续约流程重复流程3、4即可。</p><h3 id="2-域名解析"><a href="#2-域名解析" class="headerlink" title="2. 域名解析"></a>2. 域名解析</h3><p>浏览器缓存-&gt;系统缓存【本地dns解析】-&gt;请求dns服务器</p><p><img src="https://pic.fengyuwusong.cn/20220429102332.png" alt="dns解析流程"></p><ul><li><p>思考题：</p></li><li><p>dns用途：</p><ul><li>域名解析</li><li>负载均衡【内部&amp;全局(GSLB)运营商+地域等】</li></ul></li><li><p>传统dns协议VS httpdns</p><ul><li>缓存问题</li><li>域名转发</li><li>出口NAT问题</li><li>域名更新</li><li>延迟问题<br><img src="https://pic.fengyuwusong.cn/20220429103748.png" alt="httpdns"></li></ul></li></ul><h3 id="3-判断目标机器是否在同一个局域网内"><a href="#3-判断目标机器是否在同一个局域网内" class="headerlink" title="3. 判断目标机器是否在同一个局域网内"></a>3. 判断目标机器是否在同一个局域网内</h3><ul><li><p>CIDR网络无类型域间选路（CIDR）<br>例如：10.100.122.2/24<br>网段：10.100.122.2 广播地址：10.100.122.255 子网掩码：255.255.255.0</p></li><li><p>思考题</p><ul><li>跨网段的请求，应该要怎么发起？<br>如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。</li></ul></li></ul><h3 id="4-获取网关MAC地址"><a href="#4-获取网关MAC地址" class="headerlink" title="4. 获取网关MAC地址"></a>4. 获取网关MAC地址</h3><p>ARP协议</p><p><img src="https://pic.fengyuwusong.cn/20220429110903.png" alt="arp协议"></p><ul><li>思考题：<ul><li>mac层用来解决什么问题的？</li><li>多个交换机arp会出现什么问题，怎么解决？【环路】</li></ul></li></ul><h3 id="5-TCP链接"><a href="#5-TCP链接" class="headerlink" title="5. TCP链接"></a>5. TCP链接</h3><p><img src="https://pic.fengyuwusong.cn/20220429111900.png" alt="三次握手流程"></p><ul><li>思考题：<ul><li>为什么需要三次握手？</li><li>握手除了建立连接，还做了哪个比较重要的事情？</li></ul></li></ul><h3 id="6-构建报文"><a href="#6-构建报文" class="headerlink" title="6. 构建报文"></a>6. 构建报文</h3><p>发起请求的第一步，应该是构建需要发出去的报文，基于<strong>网络5层协议</strong>，当我们准备发出一个HTTP报文的时候，整个报文的构建应该是基于网络协议自顶向下进行构建的。</p><p><img src="http://pic.fengyuwusong.cn/20220428225605.png" alt="报文构建过程"></p><p>以一个简单的http报文为例，首先他应该是先构建HTTP报文</p><ol><li>应用层：http请求报文构建</li></ol><p><img src="https://mdn.mozillademos.org/files/13687/HTTP_Request.png" alt="http报文"></p><ol start="2"><li>运输层：数据报</li></ol><p><img src="http://pic.fengyuwusong.cn/20220428231757.png" alt="tcp包"></p><ol start="3"><li><p>网络层：ip帧<br>``<br><img src="http://pic.fengyuwusong.cn/20220428231549.png" alt="ip帧"></p></li><li><p>数据链路层：MAC帧</p></li></ol><p><img src="http://pic.fengyuwusong.cn/20220428230749.png" alt="数据链路包"></p><ol start="5"><li>物理层：二进制流</li></ol><p>整体包：<br><img src="https://pic.fengyuwusong.cn/20220429114343.png" alt=""></p><h3 id="7-报文在网络中应该如何转发"><a href="#7-报文在网络中应该如何转发" class="headerlink" title="7. 报文在网络中应该如何转发"></a>7. 报文在网络中应该如何转发</h3><h4 id="无nat模式"><a href="#无nat模式" class="headerlink" title="- 无nat模式"></a>- 无nat模式</h4><p><img src="https://pic.fengyuwusong.cn/20220429113536.png" alt="无nat转发"></p><p>服务器A发送请求到服务器B包内容应依序为：</p><table><thead><tr><th>序号</th><th>源ip</th><th>源mac</th><th>目标ip</th><th>目标mac</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>192.168.1.101</td><td>服务器A的mac地址</td><td>192.168.4.101</td><td>网关192.168.1.1的mac地址</td><td>网段不同，修改mac地址发到网关</td></tr><tr><td>2</td><td>192.168.1.101</td><td>192.168.56.1的mac地址</td><td>192.168.4.101</td><td>网关192.168.56.2的mac地址</td><td>查询本机路由表，下一跳为192.168.56.2的交换机，arp查询该机器mac地址</td></tr><tr><td>3</td><td>192.168.1.101</td><td>网关192.168.4.1的mac地址</td><td>192.168.4.101</td><td>服务器B的mac地址</td><td>查询路由表或arp，转发到目标服务器B</td></tr></tbody></table><h4 id="有nat模式"><a href="#有nat模式" class="headerlink" title="- 有nat模式"></a>- 有nat模式</h4><p>局域网之间无协商，各定各的网段，存在ip段冲突。</p><p><img src="https://pic.fengyuwusong.cn/20220429113839.png" alt="有nat转发"></p><p>服务器A发送请求到服务器B包内容应依序为：</p><table><thead><tr><th>序号</th><th>源ip</th><th>源mac</th><th>目标ip</th><th>目标mac</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>192.168.1.101</td><td>服务器A的mac地址</td><td>192.168.56.2</td><td>网关192.168.1.1的mac地址</td><td>网段不同，修改mac地址发到网关</td></tr><tr><td>2</td><td>192.168.56.1</td><td>192.168.56.1的mac地址</td><td>192.168.56.2</td><td>网关192.168.56.2的mac地址</td><td>修改源ip，以交换机ip发送请求到网关192.168.56.2  <strong>nat过程中，网络包从局域网转发时，需要变更源ip，否则无法确认身份</strong></td></tr><tr><td>3</td><td>192.168.56.1</td><td>网关192.168.1.1的mac地址</td><td>192.168.1.101</td><td>服务器B的mac地址</td><td>网关根据NAT配置，来源ip是192.168.56.2的通通转发到服务器B</td></tr></tbody></table><ul><li>思考题：<ul><li>以上介绍的nat方式是使用中间局域网身份方式进行映射，那么存在ip耗尽的危险，目前是如何规避的呢？【NAPT】</li></ul></li></ul><h3 id="8-路由转发"><a href="#8-路由转发" class="headerlink" title="8. 路由转发"></a>8. 路由转发</h3><p>第7点关于路由跳转描述都是很简单的场景（仅一条映射关系），但是在实际的网络世界上要复杂很多，一旦出了网关，会面临很多的路由，需要如何选择更快速的通道？</p><ul><li>静态路由策略</li><li>动态路由策略<ul><li>距离矢量算法【维护到任意路由的距离路由表，定期广播所有路由表】（BGP：外网路由协议）<ul><li>收敛慢【包含路径解决】</li><li>发送需广播全部路由表【不适用于大型网络规模】</li></ul></li><li>链路状态路由算法【根据收包的方式计算临近路由距离,可维护一个完整的图，然后使用Dijkstra算法计算最短路径】（OSPF：内部网关协议）</li></ul></li></ul><h3 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h3><p>读完上文，大家对发起一个请求协议在网络中的流转流程应该有了大致的了解，那么这里再简单拓展一下提问：</p><ol><li>为什么有了ip还需要mac地址？</li><li>https应该加上哪些流程？</li><li>移动设备的ip怎么获取的？</li><li>有哪些技术是用于服务端相应提升的？</li><li>………….</li></ol><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>http协议文档: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP</a><br>极客时间课-趣谈网络协议：<a href="https://time.geekbang.org/column/intro/100007101" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/100007101</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ipad编程体验</title>
      <link href="/2021/12/25/ipad%E7%BC%96%E7%A8%8B%E4%BD%93%E9%AA%8C/"/>
      <url>/2021/12/25/ipad%E7%BC%96%E7%A8%8B%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于之前买的16寸mac太大太重了，同时看到有许多同事有使用ipad等平板设备进行办公，在这个念头的驱动下，摆脱又大又重的笔记本的想法越来越强烈，故在双十一一冲动则入手了ipad pro2021 11寸M1款，并且也上手在公司使用了一段时间，平时开会&amp;技术方案评审等表现都尚可，总体来说还是十分满意～</p><p>最近有些事情需要回家一趟，遂想着vscode本身也是基于Node.js与Chromium进行搭建的，故理论上应该能够在我的云服务器上搭建一个vscode服务器，同时使用浏览器进行访问使用vscode，在网上搜索了一下果不其然有相关的方案，故下面介绍一下vscode服务器版<code>code-server</code>的搭建以及在ipad上编码的感受～</p><a id="more"></a><h3 id="code-server官方介绍"><a href="#code-server官方介绍" class="headerlink" title="code-server官方介绍"></a>code-server官方介绍</h3><p><a href="https://github.com/coder/code-server" target="_blank" rel="noopener">code-server</a>是运行代码服务器的最佳场所，它在您的浏览器或桌面中提供 Visual Studio Code 作为渐进式 Web 应用程序。由数以万计的个人开发人员使用，代码服务器使在任何设备上的任何浏览器中运行 VS Code 成为可能——由任何规模的服务器提供支持。当打包在 Coder 工作区中时，代码服务器为开发团队提供无缝的 VS Code 体验，感觉像是原生的，并以您的云提供的速度和可扩展性为后盾。</p><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>搭建方式有多种，这里面简单介绍一下docker以及普通rpm部署。<br>安装文档：<a href="https://coder.com/docs/code-server/latest/install" target="_blank" rel="noopener">https://coder.com/docs/code-server/latest/install</a></p><h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -u root -p 18888:8080 --name code-server -v $CODE&#x2F;config.yaml:&#x2F;data&#x2F;apps&#x2F;docker&#x2F;code-server-data&#x2F;config.yaml codercom&#x2F;code-server</span><br></pre></td></tr></table></figure><p>docker部署后进入vscode使用的终端为docker内部bash，除非多人使用，否则不太推荐使用docker部署。</p><h4 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fOL https:&#x2F;&#x2F;github.com&#x2F;coder&#x2F;code-server&#x2F;releases&#x2F;download&#x2F;v3.12.0&#x2F;code-server-3.12.0-amd64.rpm</span><br><span class="line">sudo systemctl enable --now code-server@$USER</span><br><span class="line"># Now visit http:&#x2F;&#x2F;127.0.0.1:8080. Your password is in ~&#x2F;.config&#x2F;code-server&#x2F;config.yaml</span><br></pre></td></tr></table></figure><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>config.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bind-addr: 127.0.0.1:8080</span><br><span class="line">auth: password</span><br><span class="line">password: xxxx</span><br><span class="line">cert: false</span><br></pre></td></tr></table></figure><p>config.yaml文件为登录code-server网页需要的配置的密钥，映射好后登录后查看相关密码输入即可进入界面。</p><p>此时访问服务对应端口号应该就能进入到服务（没尝试过），但是为了达到ipad访问的目的，我们还需要通过nginx给服务设置反向代理,绑定域名以及证书进行访问，nginx location相关配置如下：</p><p>code-server.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#PROXY-START&#x2F;</span><br><span class="line">location ~* \.(gif|png|jpg|css|js|woff|woff2)$</span><br><span class="line">&#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">    expires 12h;</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">    </span><br><span class="line">    add_header X-Cache $upstream_cache_status;</span><br><span class="line">    </span><br><span class="line">    #Set Nginx Cache</span><br><span class="line">    proxy_ignore_headers Set-Cookie Cache-Control expires;</span><br><span class="line">    proxy_cache cache_one;</span><br><span class="line">    proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">    proxy_cache_valid 200 304 301 302 1m;</span><br><span class="line">    </span><br><span class="line">    # websocket config 此处需加wss配置，否则进入会提示websocket建立超时</span><br><span class="line">  proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">  proxy_set_header Connection upgrade;</span><br><span class="line">  proxy_set_header Accept-Encoding gzip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#PROXY-END&#x2F;</span><br></pre></td></tr></table></figure><h3 id="ipad使用技巧"><a href="#ipad使用技巧" class="headerlink" title="ipad使用技巧"></a>ipad使用技巧</h3><ul><li>使用safari浏览器打开对应code-server网页,点击右上角导出添加到主屏幕</li><li>键盘相关设置和输入法切换需要修改一下，否则一直会有下面横跳出现很难受</li></ul><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>环境机器负载并不大，对于个人使用上来说一定是满足的了，在编码体验上总的来说还是能勉强够用的，当网络条件不允许远程的情况下，使用这个vscode编码进行简单的学习和工作还是十分惬意，也满足了当前情况我对于这个ipad生产力的需求～</p><p>例如目前这篇文章就是在这个环境下进行的，感觉还是挺有意思的哈～以后如果是几天的假期应该是能完全摆脱mac和家里的台式机了。</p><ul><li><p>在家使用ipad写这个文章<br><img src="https://pic.fengyuwusong.cn/BE0567E1-4119-42D4-BDFF-28A05394CBD7.jpeg" alt="在家使用ipad写这个文章"></p></li><li><p>在高铁上编码<br><img src="https://pic.fengyuwusong.cn/D00CE826-FDC3-4DF3-ADA4-90B272BE578F.jpeg" alt="高铁编码"></p></li></ul><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>有些快捷键缺失，很影响编程感受，例如ctrol+tab切换tab</li><li>中文输出法无法使用快捷键</li><li>切换进程再切回vscode时，键盘输出有时不响应，需要切到其他tab或删除文本操作重新调出键盘才行</li><li>vscode用户无法登录，没办法同步配置</li><li>markdown无法侧边预览</li><li><a href="https://coder.com/docs/code-server/latest/ipad#using-the-code-server-progressive-web-app-pwa" target="_blank" rel="noopener">官网相关使用建议</a></li></ul><h3 id="相关设备及依赖"><a href="#相关设备及依赖" class="headerlink" title="相关设备及依赖"></a>相关设备及依赖</h3><ul><li>ipad pro</li><li>罗技k380键盘</li><li>罗技pabble无线鼠标</li><li>腾讯云服务2c4g</li></ul><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>看了下相关介绍，目前Jetbrains也有类似的产品<a href="https://jetbrains.github.io/projector-client/mkdocs/latest/ij_user_guide/jetbrains/#client-side" target="_blank" rel="noopener">Projector</a>支持，但是看使用体验上来说好像都是半斤八两，后续有机会再折腾一下试试，毕竟目前<code>goland</code>可是上班吃饭的家伙，如果能完美支持远程使用就好了～</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 折腾 </tag>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三亚旅游</title>
      <link href="/2021/04/27/%E4%B8%89%E4%BA%9A%E6%97%85%E6%B8%B8-2021/"/>
      <url>/2021/04/27/%E4%B8%89%E4%BA%9A%E6%97%85%E6%B8%B8-2021/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/009B6A2E-E44B-4617-96CA-995028B59DB1_1_105_c.jpeg" alt=""></p><p>由于公司有3k的旅游和两天的旅游假，所以在公司的组织下在意外中报名了去三亚旅游，总的来说也算是难的休闲了几天，下面记录一下那几天的游记做下备份~</p><a id="more"></a><h2 id="出发-（2021-04-22-周四）"><a href="#出发-（2021-04-22-周四）" class="headerlink" title="出发 （2021/04/22 周四）"></a>出发 （2021/04/22 周四）</h2><p>由于我们的机票是22号周四晚上7点20的，所以那天我们在4点就在公司附近集合准备去机场了，不得不说搭飞机真麻烦，需要提前三个多钟就出发（然而回来的经历告诉我这还算好的了🤣）</p><ul><li>前往三亚的机票</li></ul><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/20210427225510.png" alt="三亚机票" style="zoom: 25%;" /><ul><li>托运行李</li></ul><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/6A158A8B-2FF3-43DA-BD09-B03DF4B455A7_1_105_c.jpeg" alt="托运行李"  /><p>就这样我们抱着兴奋和期待的心情在9点半左右到达了三亚，于10点20分左右到达了居住的酒店- 这里我忘记拍照片了，所以这里没有记录，只能找下网上的图片凑合凑合了。</p><ul><li><p>三亚金莎唐酒店附近，从2016年的百度导航实景来看还是挺县城级别的（这里也算是三亚的郊区）😂</p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/20210427230950.png" style="zoom:150%;" /></li></ul><p>由于当晚去到太晚了，大家都没有吃东西，于是大家组队在外面逛了一下，本来想在外面找下大排档一块去吃，走了1.5公里左右都没找着，最后决定吃沙县小吃。（谁也没想到去到三亚吃的第一餐居然是沙县🤣）</p><ul><li>附近的沙县小吃（可以猜猜多少钱）</li></ul><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/04171AEA-6FDE-4E00-A712-EE7217237D9D_1_105_c.jpeg" style="zoom: 50%;" /><p>出人意料的是三亚还有挺多隆江猪脚饭，果然不努力就只有干不完的活和吃不完的隆江猪脚饭😅</p><h2 id="蜈支洲岛-（2021-04-23-周五）"><a href="#蜈支洲岛-（2021-04-23-周五）" class="headerlink" title="蜈支洲岛 （2021/04/23 周五）"></a>蜈支洲岛 （2021/04/23 周五）</h2><h3 id="早上"><a href="#早上" class="headerlink" title="早上"></a>早上</h3><p>第二天起床出阳台看了下酒店配套和风景还是很好的，看了下美团一晚400+左右。</p><ul><li>酒店阳台早上8点左右实拍</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/8A4E84DD-AB26-48CC-A2C8-9E221F783D42_1_105_c.jpeg" alt=""></p><ul><li>酒店自助早餐</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/19017D28-9953-4FA6-8092-C47DE724A59B_1_105_c.jpeg" alt=""></p><h3 id="上午-下午"><a href="#上午-下午" class="headerlink" title="上午-下午"></a>上午-下午</h3><p>洗漱完毕和用完早餐后，我们就继续乘坐约一个钟左右大巴车去三亚最出名的岛屿，蜈支洲岛了。以下是百度百科介绍：</p><hr><p>蜈支洲岛坐落在海南省<a href="https://baike.baidu.com/item/三亚市/9374780" target="_blank" rel="noopener">三亚市</a>北部的<a href="https://baike.baidu.com/item/海棠湾/6745024" target="_blank" rel="noopener">海棠湾</a>内，北面与<a href="https://baike.baidu.com/item/南湾猴岛/1528914" target="_blank" rel="noopener">南湾猴岛</a>遥遥相对，南邻美誉天下第一湾的<a href="https://baike.baidu.com/item/亚龙湾/1442509" target="_blank" rel="noopener">亚龙湾</a>。蜈支洲岛距海岸线2.7公里，方圆1.48平方公里，呈不规则的蝴蝶状，东西长1400米，南北宽1100米。</p><p>距三亚市30公里，<a href="https://baike.baidu.com/item/凤凰机场/4880237" target="_blank" rel="noopener">凤凰机场</a>38公里，紧靠<a href="https://baike.baidu.com/item/海口/5775" target="_blank" rel="noopener">海口</a>至三亚的高速公路，位置优越，交通便利。蜈支洲岛是海南岛周围为数不多的有<a href="https://baike.baidu.com/item/淡水资源/5878297" target="_blank" rel="noopener">淡水资源</a>和丰富植被的小岛，有二千多种植物，种类繁多。</p><hr><ul><li>排队上岛拍婚纱照的准新娘</li></ul><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/D62F0839-2D8E-43C1-9B18-7C6E7215E988_1_105_c.jpeg" style="zoom: 50%;" /><ul><li>排队上岛（由于旅行社的原因，上岛我们不需要排队）</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/3596FCB4-B593-4C1B-9563-DE578B02F47C_1_105_c.jpeg" alt=""></p><ul><li>登船，导游说没坐过船的要做后面，否则会晕船（上去的时候已经没位置选择了，只能坐前面，但好像也不咋的🤣）</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/DEC3013B-AD3B-4129-AAF9-02C1E98637F2_1_105_c.jpeg" alt=""></p><ul><li>上岛，非节假日还到处都是人😥</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/9541153C-894B-4E80-9CE6-1BF917A45D9D_1_105_c.jpeg" alt=""></p><p>上岛后，导游发了餐票并且带我们到餐厅后就是自由活动了，由于近视我没有玩海上项目，所以就只能在岛上到处逛，最后走完整个岛还剩半个钟就提前下岛等车回去了，总的来说不玩项目的话和普通公园差不多😂。</p><ul><li>海上项目价格表</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/D86E47BF-3C81-44CC-BAC0-C1F737681178_1_105_c.jpeg" alt=""></p><ul><li>排队吃自助餐（99元），吃的东西忘记拍了（人山人海🤣）</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/8A8B9585-718D-4A60-BD21-D5B94EA42142_1_105_c.jpeg" alt=""></p><ul><li>海上风景</li></ul><video id="video" controls="" preload="none" poster="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/DD1214ED-BAE6-4C16-A41E-3073C8F7B459_1_105_c.jpeg"><source id="mp4" src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/B5D97248-5569-4F85-96F9-84465A258638.mov" type="video/mp4"></video><p>因为这里曾被解放军征用作为战略防御的重点地区，所以环境之类的保护都还挺好。</p><ul><li>草泥马（我认为拍的最不错的一张照片之一哈哈😎）</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/0A5E8E8D-A265-482A-9911-FD8126712BF0_1_105_c.jpeg" alt=""></p><ul><li>海边拍照（难以想象几个直男在那拍照哈哈）</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/62F13D7C-CC35-495D-8A15-7290C135FB4B_1_105_c.jpeg" alt=""></p><ul><li>这张也不错🤣</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/D7736E55-7880-49A6-B31F-EAE224114E29_1_105_c.jpeg" alt=""></p><ul><li>拍婚纱照的情侣</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/2A219968-A7D8-4C5D-A672-84602D67A9B6_1_105_c.jpeg" alt=""></p><ul><li>下岛岸边</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/F515AB9D-D7DC-4429-9C77-79C4011AEC67_1_105_c.jpeg" alt=""></p><ul><li>一起拍集体照</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/4629A030-FE03-4F32-87D3-DEC2A9776A90_1_105_c.jpeg" alt=""></p><p>于是蜈支洲岛一天的行程大概这样就结束啦，总的来说去那边有机会还是体验一下海上项目，不然像我们这样干走还是挺无聊的~特别是对于我这个在海边长大的孩子没啥新奇感🤣</p><hr><h3 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h3><p>旅行社的预算分配好像有点问题，晚上的吃饭预算只有人均30，最后去了个小饭店做的菜不是很好吃，大家都没啥胃口吃😅，这里没拍到照片，大概就靠脑补吧~</p><p> 吃晚饭重新乘坐大巴车回到酒店已经是晚上了，和同事一块下酒店体验了一下酒店的泳池，游了一个钟左右，然后上去洗完澡又去海边逛了一下，于是就结束了在三亚的第二天~</p><ul><li>悠闲的三亚当地居民（感觉在那边生活应该挺不错，生活节奏特别慢~）</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/8FB3E7B1-CBBA-4431-BEA5-CD3044EEAAF7_1_102_a.jpeg" alt=""></p><ul><li>酒店边的海滩（与家乡里需要出海捕鱼的海滩相比保护的还是很好的）</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/8F510DAC-A5EF-4228-AAA7-98830252D5D5_1_102_a.jpeg" alt=""></p><ul><li>海的那边是敌人🤣</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/9F2A3F63-D09D-4D0D-AF0A-EBE47EB4DA25_1_105_c.jpeg" alt=""></p><ul><li>海边餐厅</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/58007499-C15E-40B0-AB97-8284441C024B_1_102_a.jpeg" alt=""></p><h2 id="大小洞天-三亚免税店（2021-04-24-周六）"><a href="#大小洞天-三亚免税店（2021-04-24-周六）" class="headerlink" title="大小洞天-三亚免税店（2021/04/24 周六）"></a>大小洞天-三亚免税店（2021/04/24 周六）</h2><h3 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h3><p>上午我们的行程是去三亚的知名景点-大小洞天，下面是百度百科的介绍：</p><hr><p>大小洞天风景区，原名海山奇观风景区，古称鳌山大小洞天，位于<a href="https://baike.baidu.com/item/海南省/533000" target="_blank" rel="noopener">海南省</a><a href="https://baike.baidu.com/item/三亚市/9374780" target="_blank" rel="noopener">三亚市</a>区以西40公里的南山西南隅，总<a href="https://baike.baidu.com/item/面积/100551" target="_blank" rel="noopener">面积</a>为22.5平方公里，景区已有800多年历史，是著名的道教文化风景区。</p><p>大小洞天风景区以其秀丽的海景、山景和石景号称琼崖第一山水名胜。风景区内仍有“小洞天”、“钓台”、“海山奇观”、“仙人足”、“试剑峰”等历代诗文摩崖石刻。山、海、林泉是构成一个旅游名胜必不可少的条件。这里，崖州湾弧弦百里，碧波万倾；鳌山云深林翠，岩奇洞幽；海岸遍布神工鬼斧，肖形状物之大小磊群；山海之间宛如一幅古朴雄壮的长卷画图。</p><hr><ul><li>门口景点，也有很多人在这拍婚纱照</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/7BC69E37-21E2-483B-A783-8BA4FAB12B31_1_105_c.jpeg" alt=""></p><ul><li>专业导游🤣</li></ul><video id="video" controls="" preload="none"><source id="mp4" src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/IMG_3951.MOV" type="video/mp4"></video><ul><li>景点自助餐（也不是很好吃，但是胜在不贵，好像是68块）</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/945D107E-2292-46F7-9F83-6670C1AC0E73_1_105_c.jpeg" alt=""></p><p>其他地方都是海了，也没啥好看的了~</p><hr><h3 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h3><p>下午去的是三亚免税店，看了电子产品还没有PDD便宜，PDD yyds好吧🤣</p><ul><li>免税店</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/3AA78FF5-175B-4144-99FF-5ACF31F90FE3_1_105_c.jpeg" alt=""></p><ul><li>帮忙排队，一堆购物单</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/3CF7295F-55B3-4B2F-805B-5C46F7A5A5C2_1_105_c.jpeg" alt=""></p><hr><h3 id="晚上-1"><a href="#晚上-1" class="headerlink" title="晚上"></a>晚上</h3><p>由于大家购物热情好像都不是很强烈，所以天还亮的时候就回到了别墅酒店入住了。这次入住的酒店是三亚半岭温泉海韵别墅度假酒店，6个人住一个三居别墅，给我的感觉就是进了B站那种别人带看的豪宅，有钱人的世界是真的丰富多彩😂穷人还是缺乏想象力了。</p><ul><li>不是我能住的起的价格🤣</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/8A200211-FF4A-43A9-A6AC-CA954F27A9B7_1_105_c.jpeg" alt=""></p><ul><li>大厅</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/0CAACE5E-51EC-4946-849E-D0A8BF561D29_1_105_c.jpeg" alt=""></p><ul><li>一楼庭院（泳池+温泉）</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/FA0256D5-3EF1-4112-A575-77ABC590B458_1_102_a.jpeg" alt=""></p><ul><li>大学毕业以后首次玩狼人杀</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/7336D04A-3668-4032-AACA-99649FF6F288_1_105_c.jpeg" alt=""></p><ul><li>一大早起床打王者的大佬🤣</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/65EEFDEC-11DB-4782-BC7A-8E826856A736_1_105_c.jpeg" alt=""></p><p>别墅部分就先到此为止~</p><hr><p>晚上我们还去吃了三亚当地的海鲜市场，吃到了当地地道的海鲜~这里需要感谢某位大佬的款待😇</p><ul><li>三亚海鲜套餐（没有吧石斑拍进去，疏忽了🤣）</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/D0A824E8-1297-435A-931A-AF7BBD225526_1_105_c.jpeg" alt=""></p><ul><li>回来的时候翻车了，打车打到了半岭温泉中心，距离住的地方还有2公里。最后还得走路加翻墙回去，真是一次难忘的旅程呢🤣</li></ul><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/00840EB4-9C63-4DA1-9120-B880F211B066_1_102_o.jpeg" style="zoom: 33%;" /><ul><li>小黄鸭翻车现场</li></ul><video id="video" controls="" preload="none"><source id="mp4" src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/IMG_1242.MOV" type="video/mp4"></video><h2 id="三亚不夜城-回家（2021-04-25-周日）"><a href="#三亚不夜城-回家（2021-04-25-周日）" class="headerlink" title="三亚不夜城-回家（2021/04/25 周日）"></a>三亚不夜城-回家（2021/04/25 周日）</h2><p>最后一天的行程原计划是直升机+去三亚不夜城豪生潜水，但是由于海南举办博鳌会议所以禁飞，就在酒店待到了中午在出发去不夜城潜水。</p><h3 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h3><p>中午的吃饭又是去了30块人均的地方吃饭，体验相当不好~特别是旁边卖鱼仔的服务源又重复了一次推销流程让我感觉像是游戏重新读了档，怀疑昨天还没过去</p><ul><li>人均30元的中午饭（很难想象旅游还能吃上这么便宜的饭菜，虽然特别难吃🤣）</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/C34318F4-72AE-47A4-AD05-AFAD3F646508_1_105_c.jpeg" alt=""></p><ul><li>潜水</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/20210428011224.png" alt=""></p><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/IMG_0739.JPG" alt=""></p><ul><li>同事的小孩，挺可爱的~</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/AE5E9F44-99A4-4881-960D-74237AD1001D_1_105_c.jpeg" alt=""></p><p>潜水的体验也不是很好，近视啥也看不清🤣救生员在旁边不停推销拍照片和视频，体验过后感觉也就那样了吧~</p><p>整个三亚不夜城没什么好玩的，不知道是不是白天过去的缘故，感觉人不多有点荒凉，最后在KFC坐了1个钟然后吃了椰子鸡就回家啦~</p><hr><h3 id="回程"><a href="#回程" class="headerlink" title="回程"></a>回程</h3><p>回去的时候由于旅行社没沟通好，最后大巴进不了机场，走了接近半个钟才找到大巴，2点才回到我的城中村小窝，也算是一种难得的体验啦~🤣</p><ul><li>飞机上</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/1292BC41-B990-4907-AB25-6A1FDEE3E7AE_1_105_c.jpeg" alt=""></p><ul><li>12点多在机场找大巴</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/8CE22F4D-CF5C-48F0-8ACE-43B48972CABC.jpeg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说三亚作为一个旅游景点，还是很适合没有经常见过大海的朋友的，像我这种在海边长大的孩子已经没感觉的到啥惊喜了~</p><p>所以整个行程只能说中规中矩，在意料之中吧~</p><p>整个旅程中居住的酒店都还不错算是加分项，但是那个30块人均的午餐是真的太难吃了🤣</p><p>三亚的海鲜还是很值得去试试的，价格来说也不算特别的贵吧。</p><p>说起来中间和司机唠叨才知道原来海南话就是我家乡那边的话，亲切感up+</p><p>在海南三亚生活的当地居民感觉挺幸福的，小日子过得特别悠闲，不像在大城市里面特别匆忙。希望以后自己也能过上这样的生活吧~</p><p>附带一下家乡的海哈哈~</p><ul><li>拍摄于2021年农历初一</li></ul><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/0494ABAA-A64B-4EEA-B4D7-A1DC39766608_1_105_c.jpeg" alt=""></p><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/DD1059D5-0FED-4D0F-9615-DA0FFECFAB82_1_105_c.jpeg" alt=""></p><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/0BC1FE62-3EDB-4933-A65E-D961E79494CD_1_105_c.jpeg" alt=""></p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/CB0008AB-19EE-460E-9A39-BE6058DD5FD9_1_105_c.jpeg" style="zoom: 67%;" /><p>这和三亚相比好像也差不了多少？🤣</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回到家后发现养的栀子花又开了一朵，幸福感up！</p><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/FA566156-4349-4F08-8E63-1E636777E774_1_201_a.jpeg" alt=""></p><p>回来第二天晚上去吃了老地方小排挡，同事说还是地道广东菜好吃，比酒店的好吃多了哈哈</p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/D269254E-CA7B-45DE-B696-DFCBB7697CCA_1_105_c.jpeg" style="zoom:33%;" />]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 三亚 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-15.3Sum</title>
      <link href="/2020/05/17/leetcode-15.-3Sum/"/>
      <url>/2020/05/17/leetcode-15.-3Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The solution set must not contain duplicate triplets.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/3sum</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1. 暴力解法"></a>1. 暴力解法</h4><p>假设三个数字分别为 x, y, z。 那么可知 x + y + z = 0，由此可以通过三层遍历依次确定每个数值即可（确保不会出现重复，需要将数组排序）。</p><p>需要注意的是每个解的三个数值必须不同， 当x ，y确定时， z符合目标的仅需遍历一次，x，y不可与上次符合的重复。</p><p>该解法不够优雅，特殊情况太多if判断，时间复杂度o(n^3)。</p><h4 id="2-利用hash表获取第三人"><a href="#2-利用hash表获取第三人" class="headerlink" title="2. 利用hash表获取第三人"></a>2. 利用hash表获取第三人</h4><p>由于 x + y + z = 0，那么我们可以维护一个hash表，确定需要的x值是否存在 =&gt; x = 0 - y -z，设为 hash[0 - y - z] = [y, z]， 不存在则 hash[x] = nil.</p><p>可以先通过二维遍历整个数组确定x、y值、以及维护一个hash表， 则可将时间复杂度降低为 O(n^2)。</p><h4 id="3-双指针"><a href="#3-双指针" class="headerlink" title="3. 双指针"></a>3. 双指针</h4><p>可以先对数组进行排序，然后取中间的任意一个数 x，那么有 x + y + z = 0可知（由于排序后， z &gt;= y &gt;= x）， 那么x必然在y左边，z必然在y右边。那么就可以通过双指针依次遍历即可得到解。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; nums[i]</span><br><span class="line"></span><br><span class="line">y =&gt; nums[i + 1] </span><br><span class="line"></span><br><span class="line">z =&gt; nums[len(nums)-1]</span><br></pre></td></tr></table></figure><p>当 x + y + z &gt; 0，说明 z 值过大，指针左移；</p><p>当 x + y + z &lt; 0，说明x值过小，指针右移。</p><p>当 两者相遇时退出 x = nums[i] 循环。</p><p><strong>优化点&amp;特殊情况考虑：</strong></p><ol><li>需考虑x值重复情况，例如 [0, 0 , 0, 10情况，x值取两次0必然会重复得出结果 [0, 0, 0]。</li><li>由于 x + y + z == 0，那么 x/y/z必然符号不可能相同（0除外）；</li><li>必然不存在 x &gt; 0 的情况。</li></ol><p>时间复杂度 O(nlogn)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="1-暴力解"><a href="#1-暴力解" class="headerlink" title="1. 暴力解"></a>1. 暴力解</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> x, y, z <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; x == nums[i] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">x = nums[i]</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">y = nums[j]</span><br><span class="line">z = <span class="number">0</span> - x - y</span><br><span class="line"><span class="keyword">for</span> k := j + <span class="number">1</span>; k &lt; <span class="built_in">len</span>(nums); k++ &#123;</span><br><span class="line"><span class="keyword">if</span> z == nums[k] &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, []<span class="keyword">int</span>&#123;x, y, z&#125;)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-hash表"><a href="#2-hash表" class="headerlink" title="2. hash表"></a>2. hash表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash表解法 不可ac 特殊情况未编写 如重复值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> hash[nums[j]] != <span class="literal">nil</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">append</span>(hash[nums[j]], nums[j]))</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hash表不存在则两个人x, y 组队</span></span><br><span class="line">hash[<span class="number">0</span>-nums[j]-nums[i]] = []<span class="keyword">int</span>&#123;nums[j], nums[i]&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-双指针-1"><a href="#3-双指针-1" class="headerlink" title="3. 双指针"></a>3. 双指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"><span class="comment">// x 值不可能大于0</span></span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">left := i + <span class="number">1</span></span><br><span class="line">right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// left &gt;= right  x z 不可能符号相同 时退出</span></span><br><span class="line"><span class="keyword">if</span> left &gt;= right || nums[i]*nums[right] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">data := nums[i] + nums[left] + nums[right]</span><br><span class="line"><span class="keyword">if</span> data == <span class="number">0</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, []<span class="keyword">int</span>&#123;nums[left], nums[i], nums[right]&#125;)</span><br><span class="line"><span class="comment">// 同一x值可能有不同结果 left + 1取其他情况</span></span><br><span class="line">left++</span><br><span class="line"><span class="keyword">for</span> left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>] &#123;</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> data &gt; <span class="number">0</span> &#123;</span><br><span class="line">right--</span><br><span class="line"><span class="keyword">for</span> right &gt; left &amp;&amp; nums[right] == nums[right+<span class="number">1</span>] &#123;</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left++</span><br><span class="line"><span class="keyword">for</span> left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>] &#123;</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去除x值重复值情况</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span> &amp;&amp; nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高效的学习</title>
      <link href="/2020/05/16/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/05/16/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>此文整理知乎回答<a href="https://www.zhihu.com/question/324702775/answer/1007956506" target="_blank" rel="noopener">怎么才能心无旁骛地学习？</a>，希望自己以后能够更好的调整学习状态，保持自己的学习进度。</p><p><img src="https://pic3.zhimg.com/80/v2-7005aabc8f98b324871693e8f2d94c37_1440w.jpg" alt="学习方法"></p><a id="more"></a><h4 id="1-学习场所很重要"><a href="#1-学习场所很重要" class="headerlink" title="1. 学习场所很重要"></a>1. 学习场所很重要</h4><p><strong>在图书馆学习、在家学习、在宿舍学习，这三种学习效果是呈直线式递减的。</strong>如果个人专注力较差，前期可以先去图书馆学习，通过外界因素约束自己。</p><h4 id="2-学习前准备很重要"><a href="#2-学习前准备很重要" class="headerlink" title="2. 学习前准备很重要"></a>2. 学习前准备很重要</h4><p>在学习前不应该长时间玩手机、娱乐等。应先让大脑进行缓冲5-10分钟后，准备好学习状态后在进行学习，否则会由于情绪太过兴奋而学不进去。</p><h4 id="3-排除一切外接干扰"><a href="#3-排除一切外接干扰" class="headerlink" title="3. 排除一切外接干扰"></a>3. 排除一切外接干扰</h4><p>学习前应排除一切外接干扰，如手机、游戏等，将一切干扰源排到最远。</p><h4 id="4-合理使用番茄时钟"><a href="#4-合理使用番茄时钟" class="headerlink" title="4. 合理使用番茄时钟"></a>4. 合理使用番茄时钟</h4><p>可使用番茄时钟25+5分钟的学习/休息时间，但是5分钟内最好不要接近诱惑干扰源。</p><h4 id="5-制定目标很重要"><a href="#5-制定目标很重要" class="headerlink" title="5. 制定目标很重要"></a>5. 制定目标很重要</h4><p>学习前可制定今天的学习目标，如某本书看到40%，刷x道题。这样会更加具备学习动力。</p><h4 id="6-交替学习"><a href="#6-交替学习" class="headerlink" title="6. 交替学习"></a>6. 交替学习</h4><p>可以交替的学习不同知识，比如在学习一项知识2个钟后可以转移学习另一门知识，提高学习新鲜感，降低学习疲劳程度。</p><h4 id="7-绘画掌握知识脑图"><a href="#7-绘画掌握知识脑图" class="headerlink" title="7. 绘画掌握知识脑图"></a>7. 绘画掌握知识脑图</h4><p>可以绘制个人掌握的知识思维脑图，了解自己的薄弱点，可以对已掌握知识做更好的总结。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-69. Sqrt(x)</title>
      <link href="/2020/03/08/leetcode-69.%20Sqrt(x)/"/>
      <url>/2020/03/08/leetcode-69.%20Sqrt(x)/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Implement int sqrt(int x).</span><br><span class="line"></span><br><span class="line">Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</span><br><span class="line"></span><br><span class="line">Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/sqrtx</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>使用二分法求其根，注意使用 x/res &gt; res 来进行比较，如使用res * res &gt;=x 有溢出风险。</p><p>需考虑代码健壮性排除0、1。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> easy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Implement int sqrt(int x).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 4</span></span><br><span class="line"><span class="comment">Output: 2</span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 8</span></span><br><span class="line"><span class="comment">Output: 2</span></span><br><span class="line"><span class="comment">Explanation: The square root of 8 is 2.82842..., and since</span></span><br><span class="line"><span class="comment">             the decimal part is truncated, 2 is returned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/sqrtx</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">min, max := <span class="number">0</span>, x</span><br><span class="line"><span class="keyword">for</span> max-min != <span class="number">1</span> &#123;</span><br><span class="line">res := (min + max) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> x/res &gt;= res &#123;</span><br><span class="line">min = res</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">max = res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMySqrt</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(mySqrt(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">println</span>(mySqrt(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">println</span>(mySqrt(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-67. Add Binary</title>
      <link href="/2020/03/08/leetcode-67.%20Add%20Binary/"/>
      <url>/2020/03/08/leetcode-67.%20Add%20Binary/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given two binary strings, return their sum (also a binary string).</span><br><span class="line"></span><br><span class="line">The input strings are both non-empty and contains only characters 1 or 0.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: a = "11", b = "1"</span><br><span class="line">Output: "100"</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: a = "1010", b = "1011"</span><br><span class="line">Output: "10101"</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/add-binary</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>根据题意解答即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> easy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given two binary strings, return their sum (also a binary string).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The input strings are both non-empty and contains only characters 1 or 0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: a = "11", b = "1"</span></span><br><span class="line"><span class="comment">Output: "100"</span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: a = "1010", b = "1011"</span></span><br><span class="line"><span class="comment">Output: "10101"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/add-binary</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addBinary</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">al := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line">bl := <span class="built_in">len</span>(b) - <span class="number">1</span></span><br><span class="line">needAdd := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> res <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> ; al &gt;= <span class="number">0</span> || bl &gt;= <span class="number">0</span>; al, bl = al<span class="number">-1</span>, bl<span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> al &gt;= <span class="number">0</span> &amp;&amp; bl &gt;= <span class="number">0</span> &#123;</span><br><span class="line">aRes := rune2int(a[al])</span><br><span class="line">bRes := rune2int(b[bl])</span><br><span class="line">na, tRes := cal(aRes + bRes + needAdd)</span><br><span class="line">needAdd = na</span><br><span class="line">res = tRes + res</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> al &lt; <span class="number">0</span> &#123;</span><br><span class="line">bRes := rune2int(b[bl])</span><br><span class="line">na, tRes := cal(bRes + needAdd)</span><br><span class="line">needAdd = na</span><br><span class="line">res = tRes + res</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">aRes := rune2int(a[al])</span><br><span class="line">na, tRes := cal(aRes + needAdd)</span><br><span class="line">needAdd = na</span><br><span class="line">res = tRes + res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> needAdd == <span class="number">1</span> &#123;</span><br><span class="line">res = <span class="string">"1"</span> + res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rune2int</span><span class="params">(r <span class="keyword">uint8</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r == <span class="string">'1'</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">needAdd := <span class="number">0</span></span><br><span class="line">res := <span class="string">"0"</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">res = <span class="string">"1"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">needAdd = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">needAdd = <span class="number">1</span></span><br><span class="line">res = <span class="string">"1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> needAdd, res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAddBinary</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(addBinary(<span class="string">"11"</span>, <span class="string">"1"</span>))</span><br><span class="line"><span class="built_in">println</span>(addBinary(<span class="string">"1010"</span>, <span class="string">"10110"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Plus One</title>
      <link href="/2020/03/08/leetcode-66-Plus%20One/"/>
      <url>/2020/03/08/leetcode-66-Plus%20One/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</span><br><span class="line"></span><br><span class="line">The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</span><br><span class="line"></span><br><span class="line">You may assume the integer does not contain any leading zero, except the number 0 itself.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br><span class="line">66</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/plus-one</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>依照题意解答即可，需注意当个位为<code>9</code>的时候，进位情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> easy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">You may assume the integer does not contain any leading zero, except the number 0 itself.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: [1,2,3]</span></span><br><span class="line"><span class="comment">Output: [1,2,4]</span></span><br><span class="line"><span class="comment">Explanation: The array represents the integer 123.</span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: [4,3,2,1]</span></span><br><span class="line"><span class="comment">Output: [4,3,2,2]</span></span><br><span class="line"><span class="comment">Explanation: The array represents the integer 4321.</span></span><br><span class="line"><span class="comment">66</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/plus-one</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(digits) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">digits[i]++</span><br><span class="line"><span class="keyword">if</span> digits[i] == <span class="number">10</span> &#123;</span><br><span class="line">digits[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开头为0 需进位</span></span><br><span class="line"><span class="keyword">if</span> digits[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">digits = <span class="built_in">append</span>(digits, <span class="number">0</span>)</span><br><span class="line">digits[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> digits</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPlusOne</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> plusOne([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> plusOne([]<span class="keyword">int</span>&#123;<span class="number">9</span>&#125;) &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-58-Length of Last Word</title>
      <link href="/2020/02/23/leetcode-58-Length%20of%20Last%20Word/"/>
      <url>/2020/02/23/leetcode-58-Length%20of%20Last%20Word/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word (last word means the last appearing word if we loop from left to right) in the string.</span><br><span class="line"></span><br><span class="line">If the last word does not exist, return 0.</span><br><span class="line"></span><br><span class="line">Note: A word is defined as a maximal substring consisting of non-space characters only.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: "Hello World"</span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/length-of-last-word</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>从尾到头进行遍历，当遇到单词的下一个空格时退出遍历即可。</p><h4 id="注意项"><a href="#注意项" class="headerlink" title="注意项"></a>注意项</h4><p>后置多个空格的情况，取最后一个单词长度作为返回。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> easy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word (last word means the last appearing word if we loop from left to right) in the string.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If the last word does not exist, return 0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Note: A word is defined as a maximal substring consisting of non-space characters only.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: "Hello World"</span></span><br><span class="line"><span class="comment">Output: 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/length-of-last-word</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLastWord</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> res <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">' '</span> &#123;</span><br><span class="line"><span class="keyword">if</span> res == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">res++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLengthOfLastWord</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(lengthOfLastWord(<span class="string">"Hello World"</span>))</span><br><span class="line">fmt.Println(lengthOfLastWord(<span class="string">"b a  "</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-53-Maximum Subarray</title>
      <link href="/2020/02/22/leetcode-53-Maximum-Subarray/"/>
      <url>/2020/02/22/leetcode-53-Maximum-Subarray/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/maximum-subarray</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>求最大子序列和。</p><h4 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1. 暴力法"></a>1. 暴力法</h4><p>双层for循环遍历所有子序列求和。时间复杂度<code>O(n^2)</code></p><h4 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h4><p>动态规划重点在于写出隐含的推导公式。dp指当前索引的最大值。时间复杂度<code>O(n)</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前节点最大值 = max(上一节点最大值 + 当前节点值, 当前节点值)</span></span><br><span class="line">Dp[i] = max(dp[i-1] +num[i], num[i])</span><br></pre></td></tr></table></figure><p>即当上一节点最大值为负数时，放弃之前节点，从当前节点开始。</p><h4 id="3-贪心法"><a href="#3-贪心法" class="headerlink" title="3. 贪心法"></a>3. 贪心法</h4><p>翻版动态规划，使用<code>max</code>变量记录最大值则无需<code>dp</code>数组。</p><h4 id="4-分治法"><a href="#4-分治法" class="headerlink" title="4. 分治法"></a>4. 分治法</h4><p>时间复杂度<code>O(nlog(n))</code></p><p>将数组分为<code>左右中</code>三部分，左右分别可以通过递归到单个元素解决。重点在于求中间数组的子序列最大值。</p><p>其值等于<strong>左边部分的最右边开始的最大值 + 右边部分的最左边开始的最大值（与单独贪心不同，求和值必须是连续的,因为计算的是中间开始的子串的最大值）</strong>。</p><h4 id="注意项"><a href="#注意项" class="headerlink" title="注意项"></a>注意项</h4><p>建壮性编写</p><ul><li>当数据为空时返回0</li><li>数组全是负数返回最小负数，初始化<code>max</code>使用负无穷或数组第一个元素。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> easy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given an integer array nums, find the contiguous subarray (containing at least one number)</span></span><br><span class="line"><span class="comment">which has the largest sum and return its sum.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: [-2,1,-3,4,-1,2,1,-5,4],</span></span><br><span class="line"><span class="comment">Output: 6</span></span><br><span class="line"><span class="comment">Explanation: [4,-1,2,1] has the largest sum = 6.</span></span><br><span class="line"><span class="comment">Follow up:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/maximum-subarray</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxInt</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划 重点为推导式 dp[i] = max(nums[i], dp[i-1] + nums[i]) dp为在每个位置上的最大子串和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">dp[i] = maxInt(nums[i], dp[i<span class="number">-1</span>]+nums[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历dp数组查找遍历到那个节点中值最大</span></span><br><span class="line">max := dp[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> dp &#123;</span><br><span class="line">max = maxInt(max, d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 贪心法 实际为动态规划 使用max记录数组中最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray2</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">sum, max := nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">sum = maxInt(nums[i], nums[i]+sum)</span><br><span class="line">max = maxInt(sum, max)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分治法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray3</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 递归出口</span></span><br><span class="line">numsLen := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">if</span> numsLen == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> numsLen == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归处理左边最大值</span></span><br><span class="line">leftMax := maxSubArray3(nums[:numsLen/<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 递归处理右边最大值</span></span><br><span class="line">rightMax := maxSubArray3(nums[numsLen/<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用贪心法处理中间最大值 分别从 中心向左右拓张查找最大值 符合分治思路</span></span><br><span class="line"><span class="comment">// 中心往左最大值</span></span><br><span class="line">leftStart := numsLen/<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">lSum, lMax := nums[leftStart], nums[leftStart]</span><br><span class="line"><span class="keyword">for</span> i := leftStart - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">lSum = nums[i] + lSum <span class="comment">// 此处应该直接相加 因为不能再从单前节点开始 中间往外拓展应是连续的</span></span><br><span class="line">lMax = maxInt(lSum, lMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中心往右最大值</span></span><br><span class="line">rightStart := numsLen / <span class="number">2</span></span><br><span class="line">rSum, rMax := nums[rightStart], nums[rightStart]</span><br><span class="line"><span class="keyword">for</span> i := rightStart + <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">rSum = nums[i] + rSum</span><br><span class="line">rMax = maxInt(rSum, rMax)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxInt(maxInt(leftMax, rightMax), lMax+rMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMaxSubArray</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(maxSubArray([]<span class="keyword">int</span>&#123;<span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span>&#125;))</span><br><span class="line">fmt.Println(maxSubArray([]<span class="keyword">int</span>&#123;<span class="number">-1</span>&#125;))</span><br><span class="line"></span><br><span class="line">fmt.Println(maxSubArray2([]<span class="keyword">int</span>&#123;<span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span>&#125;))</span><br><span class="line"></span><br><span class="line">fmt.Println(maxSubArray3([]<span class="keyword">int</span>&#123;<span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span>&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang包管理笔记</title>
      <link href="/2020/02/18/golang%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2020/02/18/golang%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1-go-get命令"><a href="#1-go-get命令" class="headerlink" title="1. go get命令"></a>1. go get命令</h3><p>go get 命令可以借助代码管理工具通过远程拉取或更新代码包及其依赖包到<code>gopath</code>路径下，并自动完成编译和安装。整个过程就像安装一个 App 一样简单。<br>example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure><p>如上命令则是将github上中的viper包下载到本地<code>gopath</code>路径，在对应目录<code>$gopath/src/github.com/sfp13/viper</code>即可看到对应代码。</p><p>这个命令可以动态获取远程代码包，目前支持的有 <code>BitBucket、GitHub、Google Code 和 Launchpad</code>。在使用 go get 命令前，需要安装与远程包匹配的代码管理工具，如 Git、SVN、HG 等，参数中需要提供一个包名。</p><p>这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行 go install。</p><p>下载源码包的 go 工具会自动根据不同的域名调用不同的源码工具，对应关系如下：</p><table><thead><tr><th align="left">名称</th><th align="left">主命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Mercurial</td><td align="left">hg</td><td align="left">Mercurial是一种轻量级分布式版本控制系统，采用Python语言实现，易于学习和使用，扩展性强。</td></tr><tr><td align="left">Git</td><td align="left">git</td><td align="left">Git最开始是Linux Torvalds为了帮助管理 Linux 内核开发而开发的一个开源的分布式版本控制软件。但现在已被广泛使用。它是被用来进行有效、高速的各种规模项目的版本管理。</td></tr><tr><td align="left">Subversion</td><td align="left">svn</td><td align="left">Subversion是一个版本控制系统，也是第一个将分支概念和功能纳入到版本控制模型的系统。但相对于Git和Mercurial而言，它只算是传统版本控制系统的一员。</td></tr><tr><td align="left">Bazaar</td><td align="left">bzr</td><td align="left">Bazaar是一个开源的分布式版本控制系统。但相比而言，用它来作为VCS的项目并不多。</td></tr></tbody></table><a id="more"></a><h4 id="1-1-常用参数"><a href="#1-1-常用参数" class="headerlink" title="1.1. 常用参数"></a>1.1. 常用参数</h4><table><thead><tr><th align="left">标记名称</th><th align="left">标记描述</th></tr></thead><tbody><tr><td align="left">-d</td><td align="left">让命令程序只执行下载动作，而不执行安装动作。</td></tr><tr><td align="left">-f</td><td align="left">仅在使用<code>-u</code>标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里Fork过来的，那么这样做就尤为重要了。</td></tr><tr><td align="left">-fix</td><td align="left">让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装。</td></tr><tr><td align="left">-insecure</td><td align="left">允许命令程序使用非安全的scheme（如HTTP）去下载指定的代码包。如果你用的代码仓库（如公司内部的Gitlab）没有HTTPS支持，可以添加此标记。请在确定安全的情况下使用它。</td></tr><tr><td align="left">-t</td><td align="left">让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。</td></tr><tr><td align="left">-u</td><td align="left">让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。</td></tr><tr><td align="left">-v</td><td align="left">打印出那些下载的代码包的名字</td></tr><tr><td align="left">-x</td><td align="left">打印出整个过程使用的命令</td></tr></tbody></table><h4 id="1-2-下载特定分支"><a href="#1-2-下载特定分支" class="headerlink" title="1.2. 下载特定分支"></a>1.2. 下载特定分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get 项目包路径@(分支名或提交id) # 默认go1版本 其次master</span><br></pre></td></tr></table></figure><h4 id="1-3-手动导入包"><a href="#1-3-手动导入包" class="headerlink" title="1.3. 手动导入包"></a>1.3. 手动导入包</h4><p>可手动到<code>$gopath/src</code>路径进行<code>git clone</code>等操作进行手动导入包。</p><h4 id="1-4-常见错误"><a href="#1-4-常见错误" class="headerlink" title="1.4 常见错误"></a>1.4 常见错误</h4><p>由于<code>http</code>协议使用<code>git</code>系列操作的时候，需要输入密码，但是由于go默认不进行交互，所以还是会导致最终结果失败。<br>错误如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get "xxx.fengyuwusong.cn/basic_dev_libs/go_template": found meta tag get.metaImport&#123;Prefix:"xxx.fengyuwusong.cn/basic_dev_libs/go_template", VCS:"git", RepoRoot:"http://xxx.fengyuwusong.cn/basic_dev_libs/go_template.git"&#125; at //xxx.fengyuwusong.cn/basic_dev_libs/go_template?go-get=1</span><br><span class="line">go get xxx.fengyuwusong.cn/basic_dev_libs/go_template: git ls-remote -q http://xxx.fengyuwusong.cn/basic_dev_libs/go_template.git in /Users/fengyuwusong/code/gopath/pkg/mod/cache/vcs/bf5a86f855b001622b2d2fe3a7b0447bf64efb8d09620ba2443dd04f7e0ffe44: exit status 128:</span><br><span class="line">        fatal: could not read Username for 'http://xxx.fengyuwusong.cn': terminal prompts disabled</span><br><span class="line">Confirm the import path was entered correctly.</span><br><span class="line">If this is a private repository, see https://golang.org/doc/faq#git_https for additional information.</span><br></pre></td></tr></table></figure><p>以上错误我们可以通过以下两种方式来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方案一</span><br><span class="line">临时解法：手动输入用户名密码</span><br><span class="line"></span><br><span class="line">env GIT_TERMINAL_PROMPT&#x3D;1 go get xxx.com&#x2F;xxx&#x2F;xxx</span><br><span class="line"></span><br><span class="line">方案二</span><br><span class="line">长期解法：使用已经配置好的git密钥</span><br><span class="line"></span><br><span class="line">以GITHUB为例</span><br><span class="line"></span><br><span class="line">git config --global --add url.&quot;git@github.com:&quot;.insteadOf &quot;https:&#x2F;&#x2F;github.com&#x2F;&quot;</span><br></pre></td></tr></table></figure><h3 id="2-govendor"><a href="#2-govendor" class="headerlink" title="2. govendor"></a>2. govendor</h3><p>golang工程的依赖包经常使用go get命令来获取，例如：go get github.com/kardianos/govendor ，会将依赖包下载到<code>GOPATH</code>的路径下。</p><p>常用的依赖包管理工具有<code>godep</code>，<code>govendor</code>等，在Golang1.5之后，Go提供了 <code>GO15VENDOREXPERIMENT</code> 环境变量(Go 1.6版本默认开启该环境变量)，用于将go build时的应用路径搜索调整成为 <code>当前项目目录/vendor</code> 目录方式。通过这种形式，我们可以实现类似于 <code>godep</code> 方式的项目依赖管理。</p><h4 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v github.com/kardianos/govendor</span><br></pre></td></tr></table></figure><h4 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2. 使用"></a>2.2. 使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入到项目目录</span></span><br><span class="line">cd /home/gopath/src/mytool</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">初始化vendor目录</span></span><br><span class="line">govendor init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看vendor目录</span></span><br><span class="line">[root@CC54425A mytool]# ls</span><br><span class="line">commands  main.go  vendor  mytool_test.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将GOPATH中本工程使用到的依赖包自动移动到vendor目录中</span></span><br><span class="line"><span class="meta">#</span><span class="bash">说明：如果本地GOPATH没有依赖包，先go get相应的依赖包</span></span><br><span class="line">govendor add +external</span><br><span class="line">或使用缩写： govendor add +e </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">Go 1.6以上版本默认开启 GO15VENDOREXPERIMENT 环境变量，可忽略该步骤。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">通过设置环境变量 GO15VENDOREXPERIMENT=1 使用vendor文件夹构建文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">可以选择 <span class="built_in">export</span> GO15VENDOREXPERIMENT=1 或 GO15VENDOREXPERIMENT=1 go build 执行编译</span></span><br><span class="line">export GO15VENDOREXPERIMENT=1</span><br></pre></td></tr></table></figure><h4 id="2-3-常用命令"><a href="#2-3-常用命令" class="headerlink" title="2.3. 常用命令"></a>2.3. 常用命令</h4><p>常见的命令如下，格式为 <code>govendor COMMAND</code>。</p><table><thead><tr><th align="left">命令</th><th>功能</th></tr></thead><tbody><tr><td align="left"><code>init</code></td><td>初始化 vendor 目录</td></tr><tr><td align="left"><code>list</code></td><td>列出所有的依赖包</td></tr><tr><td align="left"><code>add</code></td><td>添加包到 vendor 目录，如 govendor add +external 添加所有外部包</td></tr><tr><td align="left"><code>add PKG_PATH</code></td><td>添加指定的依赖包到 vendor 目录</td></tr><tr><td align="left"><code>update</code></td><td>从 $GOPATH 更新依赖包到 vendor 目录</td></tr><tr><td align="left"><code>remove</code></td><td>从 vendor 管理中删除依赖</td></tr><tr><td align="left"><code>status</code></td><td>列出所有缺失、过期和修改过的包</td></tr><tr><td align="left"><code>fetch</code></td><td>添加或更新包到本地 vendor 目录</td></tr><tr><td align="left"><code>sync</code></td><td>本地存在 vendor.json 时候拉去依赖包，匹配所记录的版本</td></tr><tr><td align="left"><code>get</code></td><td>类似 <code>go get</code> 目录，拉取依赖包到 vendor 目录</td></tr></tbody></table><p>包状态：</p><table><thead><tr><th>状态</th><th align="center">缩写状态</th><th>缩写含义</th></tr></thead><tbody><tr><td>+local</td><td align="center">l</td><td>本地包，项目自身的包组织</td></tr><tr><td>+external</td><td align="center">e</td><td>外部包，被<code>$GOPATH</code>管理，但不在vendor目录下</td></tr><tr><td>+vendor</td><td align="center">v</td><td>已被govendor管理的包，在vendor目录下</td></tr><tr><td>+std</td><td align="center">s</td><td>标准库的包</td></tr><tr><td>+unused</td><td align="center">u</td><td>未使用的包，即包在vendor目录下，但在项目中并没有使用</td></tr><tr><td>+missing</td><td align="center">m</td><td>代码应用了依赖包，但该包未找到</td></tr><tr><td>+program</td><td align="center">p</td><td>主程序包，可编译为执行文件</td></tr><tr><td>+outside</td><td align="center"></td><td>外部包或缺失的包</td></tr><tr><td>+all</td><td align="center"></td><td>所有包</td></tr></tbody></table><p>example：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将外部包打入vendor目录</span></span><br><span class="line">govendor add +e</span><br></pre></td></tr></table></figure><h3 id="3-go-mod"><a href="#3-go-mod" class="headerlink" title="3. go mod"></a>3. go mod</h3><p>从 Go1.11 开始，golang 官方支持了新的依赖管理工具<code>go mod</code>。</p><p>其本质为将包下载到<code>$gopath/pkg/mod</code>目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/code/gopath/pkg/mod: ls</span><br><span class="line">cache               github.com          go.uber.org         google.golang.org   honnef.co</span><br><span class="line">cloud.google.com    go.etcd.io          golang.org          gopkg.in</span><br></pre></td></tr></table></figure><h4 id="3-1-常用命令"><a href="#3-1-常用命令" class="headerlink" title="3.1. 常用命令"></a>3.1. 常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ go mod</span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line"> </span><br><span class="line">Note that support for modules is built into all the go commands,</span><br><span class="line">not just 'go mod'. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be done using 'go get'.</span><br><span class="line">See 'go help modules' for an overview of module functionality.</span><br><span class="line"> </span><br><span class="line">Usage:</span><br><span class="line"> </span><br><span class="line">go mod &lt;command&gt; [arguments]</span><br><span class="line"> </span><br><span class="line">The commands are:</span><br><span class="line"> </span><br><span class="line">download    download modules to local cache   下载包到本地缓存</span><br><span class="line">edit        edit go.mod from tools or scripts 编写go.mod 文件</span><br><span class="line">graph       print module requirement graph 打印依赖关系图</span><br><span class="line">init        initialize new module in current directory 初始化当前目录</span><br><span class="line">tidy        add missing and remove unused modules 添加丢失和移除无用的包</span><br><span class="line">vendor      make vendored copy of dependencies  打包vendor目录</span><br><span class="line">verify      verify dependencies have expected content 验证依赖内容</span><br><span class="line">why         explain why packages or modules are needed 解释为什么依赖此包</span><br><span class="line"> </span><br><span class="line">Use "go help mod &lt;command&gt;" for more information about a command.</span><br></pre></td></tr></table></figure><h4 id="3-2-使用"><a href="#3-2-使用" class="headerlink" title="3.2. 使用"></a>3.2. 使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">go mod init # 在项目目录下初始化 生成go.mod文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  build 和<span class="built_in">test</span>会自动编辑go.mod文件 导入依赖包</span></span><br><span class="line">go build xxx.go</span><br><span class="line">go test xxx.go</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ... 编辑go.mod文件 导入你需要的包然后执行</span></span><br><span class="line">go mod download</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或进行以下命令 添加missing包及移除无用包</span></span><br><span class="line">go mod tidy </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打包到本地并部署</span></span><br><span class="line">go mod vendor</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他命令</span></span><br><span class="line">go list -m all # 列出所有直接或间接使用的包的最终版本</span><br><span class="line">go list -u -m all # 查看所有可用于升级的补丁</span><br><span class="line">go get xxx # 导入需要的包 会自动编辑go.mod文件添加该包</span><br></pre></td></tr></table></figure><h4 id="3-3-使用代理"><a href="#3-3-使用代理" class="headerlink" title="3.3. 使用代理"></a>3.3. 使用代理</h4><p>由于一些总所周知的原因，在国内有一些包是无法下载的，所以这时候需要设置第三方代理来对包进行拉取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用代理</span></span><br><span class="line">go env -w GOPROXY="https://goproxy.cn"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 直连</span></span><br><span class="line">go env -w GOPROXY="direct"</span><br></pre></td></tr></table></figure><p>但是有一些包我们是存在自建仓库的，那么这时候需要设置<code>GOPRIVATE</code>跳过代理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPRIVATE="*.fengyuwusong.cn"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时导入该包将不会使用代理</span></span><br><span class="line">go get -u -v test.fengyuwusong.cn</span><br></pre></td></tr></table></figure><h4 id="3-4-go-mod"><a href="#3-4-go-mod" class="headerlink" title="3.4. go.mod"></a>3.4. go.mod</h4><ul><li><code>module</code> 语句指定包的名字（路径）</li><li><code>require</code> 语句指定的依赖项模块</li><li><code>replace</code> 语句可以替换依赖项模块</li><li><code>exclude</code> 语句可以忽略依赖项模块</li></ul><p><strong>go.mod 文件样例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module fengyuwusong.cn&#x2F;my&#x2F;thing &#x2F;&#x2F; 指明身份 模块中所有软件包导入前缀</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 依赖包列表 不指定版本时 依赖所需最小版本</span><br><span class="line">require (</span><br><span class="line">    github.com&#x2F;some&#x2F;dependency v1.2.3</span><br><span class="line">    github.com&#x2F;another&#x2F;dependency&#x2F;v4 v4.0.0 &#x2F;&#x2F; indirect 意为间接使用</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; replace 替换本地路径 当一些包不想上传远程或拉不下来的时候可以使用</span><br><span class="line">replace example.com&#x2F;some&#x2F;dependency &#x3D;&gt; example.com&#x2F;some&#x2F;dependency v1.2.3  &#x2F;&#x2F; 替换为其他地址</span><br><span class="line">replace example.com&#x2F;original&#x2F;import&#x2F;path &#x3D;&gt; &#x2F;your&#x2F;forked&#x2F;import&#x2F;path &#x2F;&#x2F; 替换为本地路径</span><br><span class="line"></span><br><span class="line">exclude xxx.xx.com&#x2F;test &#x2F;&#x2F; 忽略此项依赖 很少使用</span><br></pre></td></tr></table></figure><h4 id="3-5-http支持"><a href="#3-5-http支持" class="headerlink" title="3.5. http支持"></a>3.5. http支持</h4><p>目前<code>go mod</code>等导包相关操作并不支持<code>http</code>，但是有时公司的仓库并不支持<code>https</code>，这时候我们需要使用<code>go get -u -v -insecure xxx</code>导入此包。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/golang/go/wiki/Modules#when-should-i-use-the-replace-directive" target="_blank" rel="noopener">Go 1.11 Modules 官方文档</a></p><p><a href="http://c.biancheng.net/view/123.html" target="_blank" rel="noopener">go get命令——一键获取代码、编译并安装</a></p><p><a href="https://www.cnblogs.com/liuzhongchao/p/9233177.html" target="_blank" rel="noopener">Golang包管理工具之govendor的使用</a></p><p><a href="https://blog.csdn.net/jackgo73/article/details/90604180" target="_blank" rel="noopener">【Golang】go get报错：fatal: could not read Username … terminal prompts disabled</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> govendor </tag>
            
            <tag> go mod </tag>
            
            <tag> 包管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-38-Count and Say</title>
      <link href="/2020/02/16/leetcode-38-Count-and-Say/"/>
      <url>/2020/02/16/leetcode-38-Count-and-Say/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">The count-and-say sequence is the sequence of integers with the first five terms as following:</span><br><span class="line"></span><br><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">1 is read off as "one 1" or 11.</span><br><span class="line">11 is read off as "two 1s" or 21.</span><br><span class="line">21 is read off as "one 2, then one 1" or 1211.</span><br><span class="line"></span><br><span class="line">Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.</span><br><span class="line"></span><br><span class="line">Note: Each term of the sequence of integers will be represented as a string.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1</span><br><span class="line">Output: "1"</span><br><span class="line">Explanation: This is the base case.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: "1211"</span><br><span class="line">Explanation: For n = 3 the term was "21" in which we have two groups "2" and "1", "2" can be read as "12" which means frequency = 1 and value = 2, the same way "1" is read as "11", so the answer is the concatenation of "12" and "11" which is "1211".</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/count-and-say</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>先理解题意：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设函数为fn(x) 其本意为解释int类型每个数的个数和顺序</span></span><br><span class="line">fn(1) =&gt; "1"  # 固定值返回1</span><br><span class="line">fn(2) =&gt; fn(fn(1)) =&gt; fn("1") =&gt; "11" # 1个1</span><br><span class="line">fn(3) =&gt; fn(fn(2)) =&gt; fn("11") =&gt; "21" # 2个1</span><br><span class="line">fn(4) =&gt; fn(fn(3)) =&gt; fn("21") =&gt; "1211" # 1个2 1个1</span><br><span class="line">fn(5) =&gt; fn(fn(4)) =&gt; fn("1211") =&gt; "111221" # 1个1 1个2 2个1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>故明显需使用递归来进行，找到递归出口并按照规则返回即可。</p><p>golang注意语法，<code>string</code>进行切片本质为<code>[]rune{...}</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> easy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">The count-and-say sequence is the sequence of integers with the first five terms as following:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.     1</span></span><br><span class="line"><span class="comment">2.     11</span></span><br><span class="line"><span class="comment">3.     21</span></span><br><span class="line"><span class="comment">4.     1211</span></span><br><span class="line"><span class="comment">5.     111221</span></span><br><span class="line"><span class="comment">1 is read off as "one 1" or 11.</span></span><br><span class="line"><span class="comment">11 is read off as "two 1s" or 21.</span></span><br><span class="line"><span class="comment">21 is read off as "one 2, then one 1" or 1211.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Note: Each term of the sequence of integers will be represented as a string.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1</span></span><br><span class="line"><span class="comment">Output: "1"</span></span><br><span class="line"><span class="comment">Explanation: This is the base case.</span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 4</span></span><br><span class="line"><span class="comment">Output: "1211"</span></span><br><span class="line"><span class="comment">Explanation: For n = 3 the term was "21" in which we have two groups "2" and "1", "2" can be read as "12" which means frequency = 1 and value = 2, the same way "1" is read as "11", so the answer is the concatenation of "12" and "11" which is "1211".</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/count-and-say</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countAndSay</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">// 递归出口</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上一个递归结果</span></span><br><span class="line">lastRes := countAndSay(n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> sameTimes, lastIndex <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> res bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(lastRes); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> lastRes[i] == lastRes[lastIndex] &#123;</span><br><span class="line">sameTimes++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.WriteString(strconv.Itoa(sameTimes))</span><br><span class="line">res.WriteRune(<span class="keyword">rune</span>(lastRes[lastIndex]))</span><br><span class="line">sameTimes = <span class="number">1</span></span><br><span class="line">lastIndex = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sameTimes != <span class="number">0</span> &#123;</span><br><span class="line">res.WriteString(strconv.Itoa(sameTimes))</span><br><span class="line">res.WriteRune(<span class="keyword">rune</span>(lastRes[lastIndex]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCountAnySay</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(countAndSay(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-35-Search Insert Position</title>
      <link href="/2020/02/09/leetcode-35-Search%20Insert%20Position/"/>
      <url>/2020/02/09/leetcode-35-Search%20Insert%20Position/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</span><br><span class="line"></span><br><span class="line">You may assume no duplicates in the array.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/search-insert-position</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>遍历比较即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> easy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">You may assume no duplicates in the array.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: [1,3,5,6], 5</span></span><br><span class="line"><span class="comment">Output: 2</span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: [1,3,5,6], 2</span></span><br><span class="line"><span class="comment">Output: 1</span></span><br><span class="line"><span class="comment">Example 3:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: [1,3,5,6], 7</span></span><br><span class="line"><span class="comment">Output: 4</span></span><br><span class="line"><span class="comment">Example 4:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: [1,3,5,6], 0</span></span><br><span class="line"><span class="comment">Output: 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/search-insert-position</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> num == target &#123;</span><br><span class="line"><span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> num &gt; target &#123;</span><br><span class="line"><span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSearchInsert</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(searchInsert([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, <span class="number">7</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-28. Implement strStr()</title>
      <link href="/2020/02/08/leetcode-28-Implement%20strStr/"/>
      <url>/2020/02/08/leetcode-28-Implement%20strStr/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Implement strStr().</span><br><span class="line"></span><br><span class="line">Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: haystack = "hello", needle = "ll"</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: haystack = "aaaaa", needle = "bba"</span><br><span class="line">Output: -1</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">What should we return when needle is an empty string? This is a great question to ask during an interview.</span><br><span class="line"></span><br><span class="line">For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/implement-strstr</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>双循环暴力解法。</p><p>kmp解法：相较于暴力解法更聪明，遇到特定字符时不会完全从头开始，而是遵从pat生成的next数组规则（即确认有限自动状态机）。如下图所示：</p><p><img src="https://pic.leetcode-cn.com/74666053023d668f2007c84382a86930c1270807cdf2f4394165bf2b16336f72-file_1568963023167" alt="kmp解法图例"></p><p>主要任务在于构建<strong>确认有限自动状态机</strong>，即上图中的跳转规则。创建next数组如下图所示：</p><p><img src="https://pic.leetcode-cn.com/b3fe29e2c772df9eb04baae42b4be0a388d03a625cb3815de474868531768d9b-file_1568963023183" alt="next数组"></p><p>伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pat = pat;</span><br><span class="line">        <span class="keyword">int</span> M = pat.length();</span><br><span class="line">        <span class="comment">// dp[状态][字符] = 下个状态</span></span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[M][<span class="number">256</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        dp[<span class="number">0</span>][pat.charAt(<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 影子状态 X 初始为 0</span></span><br><span class="line">        <span class="keyword">int</span> X = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 构建状态转移图（稍改的更紧凑了）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">256</span>; c++) &#123;</span><br><span class="line">                <span class="comment">// 等于重置状态 x 值</span></span><br><span class="line">                dp[j][c] = dp[X][c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 步进状态</span></span><br><span class="line">            dp[j][pat.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新影子状态 等于为 dp[j][c] = dp[X][c]; 做下一步的映射准备</span></span><br><span class="line">            X = dp[X][pat.charAt(j)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = pat.length();</span><br><span class="line">        <span class="keyword">int</span> N = txt.length();</span><br><span class="line">        <span class="comment">// pat 的初始态为 0</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算 pat 的下一个状态</span></span><br><span class="line">            j = dp[j][txt.charAt(i)];</span><br><span class="line">            <span class="comment">// 到达终止态，返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没到达终止态，匹配失败</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">作者：labuladong</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> easy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Implement strStr().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: haystack = "hello", needle = "ll"</span></span><br><span class="line"><span class="comment">Output: 2</span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: haystack = "aaaaa", needle = "bba"</span></span><br><span class="line"><span class="comment">Output: -1</span></span><br><span class="line"><span class="comment">Clarification:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">What should we return when needle is an empty string? This is a great question to ask during an interview.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/implement-strstr</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 暴力解</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="keyword">string</span>, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 健壮性编写</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(needle) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(needle) &gt; <span class="built_in">len</span>(haystack) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(haystack); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">0</span>; j &lt; <span class="built_in">len</span>(needle); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> haystack[i+j] != needle[j] &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j == <span class="built_in">len</span>(needle) &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 剩余字符串长度小于needle长度则返回</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(haystack)-i<span class="number">-1</span> &lt; <span class="built_in">len</span>(needle) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStrStr</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(strStr(<span class="string">"hello"</span>, <span class="string">"ll"</span>))</span><br><span class="line"><span class="built_in">println</span>(strStr(<span class="string">"aaaaa"</span>, <span class="string">"bba"</span>))</span><br><span class="line"><span class="built_in">println</span>(strStr(<span class="string">"aaaaa"</span>, <span class="string">"aa"</span>))</span><br><span class="line"><span class="built_in">println</span>(strStr(<span class="string">"mississippi"</span>, <span class="string">"issipi"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-27-Remove Element</title>
      <link href="/2020/02/03/leetcode-26-Remove%20Element/"/>
      <url>/2020/02/03/leetcode-26-Remove%20Element/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums and a value val, remove all instances of that value in-place and return the new length.</span><br><span class="line"></span><br><span class="line">Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</span><br><span class="line"></span><br><span class="line">The order of elements can be changed. It doesn't matter what you leave beyond the new length.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn't matter what you leave beyond the returned length.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn't matter what values are set beyond the returned length.</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">Confused why the returned value is an integer but your answer is an array?</span><br><span class="line"></span><br><span class="line">Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</span><br><span class="line"></span><br><span class="line">Internally you can think of this:</span><br><span class="line"></span><br><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/remove-element</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>记录一个后置索引变量<code>lastIndex</code>, 当前序遍历到<code>val</code>时将该后置索引元素代替当前元素<code>i</code>，并后退<code>i</code>和<code>lastIndex</code>索引。当<code>i==lastIndex</code>时退出循环返回该变量即可。以下举例：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">val = <span class="number">2</span></span><br><span class="line">lastIndex = <span class="number">8</span> <span class="comment">// 初始化为数组长度 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次遍历</span></span><br><span class="line">i = <span class="number">0</span> <span class="comment">// 当前索引</span></span><br><span class="line">num = <span class="number">0</span> <span class="comment">// 当前元素</span></span><br><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">lastIndex = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次遍历</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次遍历</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">num = <span class="number">2</span> <span class="comment">// 与val相等 执行以下程序</span></span><br><span class="line"></span><br><span class="line">lastIndex--</span><br><span class="line">nums[i] = nums[lastIndex]</span><br><span class="line">i--</span><br><span class="line"></span><br><span class="line"><span class="comment">//  此时变量</span></span><br><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">lastIndex = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四次遍历</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">num = <span class="number">2</span> <span class="comment">// 与val相等 执行以下程序</span></span><br><span class="line"></span><br><span class="line">lastIndex--</span><br><span class="line">nums[i] = nums[lastIndex]</span><br><span class="line">i--</span><br><span class="line"></span><br><span class="line"><span class="comment">//  此时变量</span></span><br><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">lastIndex = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第五次遍历</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">num = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第六次遍历</span></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">num = <span class="number">2</span> <span class="comment">// 与val相等 执行以下程序</span></span><br><span class="line"></span><br><span class="line">lastIndex--</span><br><span class="line">nums[i] = nums[lastIndex]</span><br><span class="line">i--</span><br><span class="line"></span><br><span class="line"><span class="comment">//  此时变量</span></span><br><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">lastIndex = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第七次遍历</span></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第八次遍历</span></span><br><span class="line">i = <span class="number">4</span></span><br><span class="line">num = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第九次遍历</span></span><br><span class="line">i = <span class="number">5</span>  <span class="comment">// 与 lastIndex 相等 退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lastIndex <span class="comment">// 则可遍历结果为前5个 [0, 1, 4, 0, 3]</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> easy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lastIndex <span class="keyword">int</span> = <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="comment">// 跳出循环条件</span></span><br><span class="line"><span class="keyword">if</span> lastIndex == i &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相等则前后索引元素替换 lastIndex、i 后退重新遍历当前元素</span></span><br><span class="line"><span class="keyword">if</span> nums[i] == val &#123;</span><br><span class="line">lastIndex--</span><br><span class="line">nums[i] = nums[lastIndex]</span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lastIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRemoveElement</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="keyword">int</span>, length <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(length)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d=&gt;"</span>, nums[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>()</span><br><span class="line">&#125;</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line">length := removeElement(nums, <span class="number">2</span>)</span><br><span class="line">f(nums, length)</span><br><span class="line">nums = []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">length = removeElement(nums, <span class="number">1</span>)</span><br><span class="line">f(nums, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式学习笔记</title>
      <link href="/2020/01/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h3><p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p><a id="more"></a><h3 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h3><p>最基础的匹配方式，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;the&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><p>即可找出句子中the这个单词。<br>正则表达式大小写敏感，所以<code>The</code>不会匹配<code>the</code>。</p><h3 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h3><p>正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。<br>一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p><table><thead><tr><th align="center">元字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">实心点匹配任意单个字符除了换行符。</td></tr><tr><td align="center">[ ]</td><td align="center">字符种类。匹配方括号内的任意字符。</td></tr><tr><td align="center">[^ ]</td><td align="center">否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td align="center">*</td><td align="center">匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr><td align="center">+</td><td align="center">匹配&gt;=1个重复的+号前的字符。</td></tr><tr><td align="center">?</td><td align="center">标记?之前的字符为可选.</td></tr><tr><td align="center">{n,m}</td><td align="center">匹配num个大括号之间的字符 (n &lt;= num &lt;= m).</td></tr><tr><td align="center">(xyz)</td><td align="center">字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td align="center">|</td><td align="center">或运算符，匹配符号前或后的字符.</td></tr><tr><td align="center">\</td><td align="center">转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td></tr><tr><td align="center">^</td><td align="center">从开始行开始匹配.</td></tr><tr><td align="center">$</td><td align="center">从末端开始匹配</td></tr></tbody></table><p>下面开始举例说明。</p><h4 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a>2.1 点运算符 <code>.</code></h4><p><code>.</code>是元字符中最简单的例子。 <code>.</code>匹配任意单个字符，但不匹配换行符。 例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p><pre>".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h4 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集 []"></a>2.2 字符集 <code>[]</code></h4><p>字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中可使用连字符来指定字符集的范围。 在方括号中的字符集<strong>不关心顺序</strong>。 例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p><pre>“[Tt]he” => <a href="#2.2字符集">The</a> car parked in <a href="#2.2字符集">the</a> garage.</pre><p>方括号的句号就表示句号。 表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p><pre>"ar[.]" => A garage is a good place to park a c<a href="#2.2字符集">ar.</a></pre><h5 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集[^]"></a>2.2.1 否定字符集<code>[^]</code></h5><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p><pre>“[^car]" => The car <a href="#2.2.1">par</a>ked in the <a href="#2.2.1">gar</a>age.</pre><h4 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a>2.3 重复次数</h4><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。</p><h5 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 *号"></a>2.3.1 <code>*</code>号</h5><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。 例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p> <pre>"[a-z]*" => T<a href="#2.3.1">he</a> <a href="#2.3.1">car</a> <a href="#2.3.1">parked</a> <a href="#2.3.1">in</a> <a href="#2.3.1">the</a> <a href="#2.3.1">garage</a> #21.</pre><p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。 <code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p><pre>"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.</pre><h5 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a>2.3.3 <code>?</code> 号</h5><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。<br>例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p><pre>"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><pre>"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.</pre><h4 id="2-4-号"><a href="#2-4-号" class="headerlink" title="2.4 {} 号"></a>2.4 <code>{}</code> 号</h4><p>在正则表达式中 <code>{}</code> 是一个量词，常用来一个或一组字符可以重复出现的次数。<br>例如， 表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p><pre>"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p>我们可以省略第二个参数。<br>例如，<code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字。</p><pre>"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p>如果逗号也省略掉则表示重复固定的次数。<br>例如，<code>[0-9]{3}</code> 匹配3位数字</p><pre>"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.</pre><h4 id="2-5-特征标群"><a href="#2-5-特征标群" class="headerlink" title="2.5 (...) 特征标群"></a>2.5 <code>(...)</code> 特征标群</h4><p>特征标群是一组写在 <code>(...)</code> 中的子模式。例如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次。例如，表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。</p><p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p><pre>"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h4 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a>2.6 <code>|</code> 或运算符</h4><p>或运算符就表示或，用作判断条件。</p><p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p><pre>"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><h4 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a>2.7 转码特殊字符</h4><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p><p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p><pre>"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a></pre><h4 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a>2.8 锚点</h4><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p><h5 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a>2.8.1 <code>^</code> 号</h5><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p><p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p><pre>"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><pre>"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><h5 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a>2.8.2 <code>$</code> 号</h5><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p><p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p><pre>"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a></pre><pre>"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a></pre><h3 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h3><p>正则表达式提供一些常用的字符集简写。如下:</p><table><thead><tr><th align="center">简写</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">.</td><td align="left">除换行符外的所有字符</td></tr><tr><td align="center">\w</td><td align="left">匹配所有字母数字或下划线或汉字或希腊或俄文字符等，等同于 `[a-zA-Z0-9_]</td></tr><tr><td align="center">\W</td><td align="left">匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td align="center">\d</td><td align="left">匹配数字： <code>[0-9]</code></td></tr><tr><td align="center">\D</td><td align="left">匹配非数字： <code>[^\d]</code></td></tr><tr><td align="center">\s</td><td align="left">匹配所有空格字符，等同于： <code>[\t\n\f\r\v]</code></td></tr><tr><td align="center">\S</td><td align="left">匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td align="center">\f</td><td align="left">匹配一个换页符</td></tr><tr><td align="center">\n</td><td align="left">匹配一个换行符</td></tr><tr><td align="center">\r</td><td align="left">匹配一个回车符</td></tr><tr><td align="center">\t</td><td align="left">匹配一个制表符</td></tr><tr><td align="center">\v</td><td align="left">匹配一个垂直制表符</td></tr><tr><td align="center">\p</td><td align="left">匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><h3 id="4-零宽度断言（前后预查）"><a href="#4-零宽度断言（前后预查）" class="headerlink" title="4. 零宽度断言（前后预查）"></a>4. 零宽度断言（前后预查）</h3><p>先行断言和后发断言都属于<strong>非捕获簇</strong>（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。</p><p>例如，我们想要获得所有跟在 <code>$</code> 符号后的数字，我们可以使用正后发断言 <code>(?&lt;=\$)[0-9\.]*</code>。 这个表达式匹配 <code>$</code> 开头，之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次。</p><p>零宽度断言如下：</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>?=</td><td>正先行断言-存在</td></tr><tr><td>?!</td><td>负先行断言-排除</td></tr><tr><td>?&lt;=</td><td>正后发断言-存在</td></tr><tr><td>?&lt;!</td><td>负后发断言-排除</td></tr></tbody></table><h5 id="4-1-正先行断言"><a href="#4-1-正先行断言" class="headerlink" title="4.1 ?=... 正先行断言"></a>4.1 <code>?=...</code> 正先行断言</h5><p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p><p>返回结果只包含满足匹配条件的第一部分表达式。 <strong>定义一个正先行断言要使用 <code>()</code></strong>。在括号内部使用一个问号和等号： <code>(?=...)</code>。</p><p>正先行断言的内容写在括号中的等号后面。 例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>。</p><pre>"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><h5 id="4-2-负先行断言"><a href="#4-2-负先行断言" class="headerlink" title="4.2 ?!... 负先行断言"></a>4.2 <code>?!...</code> 负先行断言</h5><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。<br><code>正先行断言</code>  定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p><p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p><pre>"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><h5 id="4-3-lt-正后发断言"><a href="#4-3-lt-正后发断言" class="headerlink" title="4.3 ?&lt;= ... 正后发断言"></a>4.3 <code>?&lt;= ...</code> 正后发断言</h5><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。<br>例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code>。</p><pre>"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><h5 id="4-4-lt-负后发断言"><a href="#4-4-lt-负后发断言" class="headerlink" title="4.4 ?&lt;!... 负后发断言"></a>4.4 <code>?&lt;!...</code> 负后发断言</h5><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。<br>例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code>。</p><pre>"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.</pre><h3 id="5-标志"><a href="#5-标志" class="headerlink" title="5. 标志"></a>5. 标志</h3><p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。<br>这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p><table><thead><tr><th align="center">标志</th><th>描述</th></tr></thead><tbody><tr><td align="center">i</td><td>忽略大小写。</td></tr><tr><td align="center">g</td><td>全局搜索。</td></tr><tr><td align="center">m</td><td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td></tr></tbody></table><h4 id="5-1-忽略大小写（Case-Insensitive）"><a href="#5-1-忽略大小写（Case-Insensitive）" class="headerlink" title="5.1 忽略大小写（Case Insensitive）"></a>5.1 忽略大小写（Case Insensitive）</h4><p>修饰语 <code>i</code> 用于忽略大小写。<br>例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><pre>"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><h4 id="5-2-全局搜索（Global-search）"><a href="#5-2-全局搜索（Global-search）" class="headerlink" title="5.2 全局搜索（Global search）"></a>5.2 全局搜索（Global search）</h4><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。<br>例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+ <code>at</code>，并返回全部结果。</p><pre>"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.</pre><pre>"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><h4 id="5-3-多行修饰符（Multiline）"><a href="#5-3-多行修饰符（Multiline）" class="headerlink" title="5.3 多行修饰符（Multiline）"></a>5.3 多行修饰符（Multiline）</h4><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p><p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p><p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p><pre>"/.at(.)?$/" => The fat                cat sat                on the <a href="#learn-regex"><strong>mat.</strong></a></pre><pre>"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>                  cat <a href="#learn-regex"><strong>sat</strong></a>                  on the <a href="#learn-regex"><strong>mat.</strong></a></pre><h3 id="6-贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）"><a href="#6-贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）" class="headerlink" title="6. 贪婪匹配与惰性匹配（Greedy vs lazy matching）"></a>6. 贪婪匹配与惰性匹配（Greedy vs lazy matching）</h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><pre>"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre><pre>"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre><h3 id="简单实验"><a href="#简单实验" class="headerlink" title="简单实验"></a>简单实验</h3><h4 id="匹配所有正数和负数"><a href="#匹配所有正数和负数" class="headerlink" title="匹配所有正数和负数"></a>匹配所有正数和负数</h4><p>Example: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">123.2</span><br><span class="line">-123</span><br><span class="line">-123.1</span><br></pre></td></tr></table></figure><p>Regex:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-?\d+(\.\d+)?</span><br></pre></td></tr></table></figure><p><code>-?</code>匹配前面的负号， <code>\d+</code>表示必须带有数字，<code>(\.\d+)?</code>表示后面的点+小数位  ?代表不是必须</p><h4 id="匹配日期规则"><a href="#匹配日期规则" class="headerlink" title="匹配日期规则"></a>匹配日期规则</h4><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-1-1</span><br><span class="line">2019-12-12</span><br><span class="line">2020-01-01</span><br></pre></td></tr></table></figure><p>Regex:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[1-2]?\d&#123;1,3&#125;-(0?[1-9]|1[0-2])-(0?[1-9]|[12]\d|3[01])$</span><br></pre></td></tr></table></figure><h4 id="匹配邮箱地址"><a href="#匹配邮箱地址" class="headerlink" title="匹配邮箱地址"></a>匹配邮箱地址</h4><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cwyu123@qq.com</span><br><span class="line">901237niqd@163.cn</span><br><span class="line">fengyuwusong@fengyuwusong.cn</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; @前面必须有内容且只能是字母(大小写),数字,下划线,减号,点；</span><br><span class="line">&#x2F;&#x2F; @和最后一个点之间必须有内容且只能是字母(大小写),数字,点,减号,且两个点不能挨着；</span><br><span class="line">&#x2F;&#x2F; 最后一个点之后必须有内容且内容只能是字母(大小写),数字。长度为大于等于2,小于等于6。</span><br></pre></td></tr></table></figure><p>Regex:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z0-9_\-\.]+@[a-zA-Z0-9\-]*\.*[a-zA-Z0-9\-]+\.[a-zA-Z0-9]&#123;2,6&#125;$</span><br></pre></td></tr></table></figure><h4 id="匹配Html标签"><a href="#匹配Html标签" class="headerlink" title="匹配Html标签"></a>匹配Html标签</h4><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">从以下标签匹配:</span><br><span class="line">&lt;a&gt;wahaha&lt;&#x2F;a&gt;</span><br><span class="line">&lt;b&gt;banana&lt;&#x2F;b&gt;</span><br><span class="line">&lt;h1&gt;qqxing&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">内容:</span><br><span class="line">wahaha</span><br><span class="line">banana</span><br><span class="line">qqxing</span><br><span class="line"></span><br><span class="line">标签:</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">h1</span><br></pre></td></tr></table></figure><p>Regex:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内容:</span><br><span class="line">(?&lt;&#x3D;&gt;)\w+(?&#x3D;&lt;)</span><br><span class="line"></span><br><span class="line">&quot;&lt;a&gt;wahaha&lt;&#x2F;a&gt;&quot; &#x3D;&gt; &quot;wahaha&quot;</span><br><span class="line"></span><br><span class="line">标签:</span><br><span class="line">(?&lt;&#x3D;&lt;&#x2F;)\w+(?&#x3D;&gt;)</span><br><span class="line">&quot;&lt;a&gt;wahaha&lt;&#x2F;a&gt;&quot; &#x3D;&gt; &quot;a&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-26-Remove Duplicates from Sorted Array</title>
      <link href="/2020/01/28/leetcode-26-Remove%20Duplicates%20from%20Sorted%20Array/"/>
      <url>/2020/01/28/leetcode-26-Remove%20Duplicates%20from%20Sorted%20Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</span><br><span class="line"></span><br><span class="line">Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what you leave beyond the returned length.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what values are set beyond the returned length.</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">Confused why the returned value is an integer but your answer is an array?</span><br><span class="line"></span><br><span class="line">Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</span><br><span class="line"></span><br><span class="line">Internally you can think of this:</span><br><span class="line"></span><br><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>遍历数组即可即可，注意参数校验。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> easy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">lastNum := nums[<span class="number">0</span>]</span><br><span class="line">currentIndex := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> num &gt; lastNum &#123;</span><br><span class="line">nums[currentIndex] = num</span><br><span class="line">currentIndex++</span><br><span class="line">lastNum = num</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currentIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRemoveDuplicates</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">numsLen := removeDuplicates(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numsLen; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"=&gt;%v"</span>, nums[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-21-Merge Two Sorted Lists</title>
      <link href="/2020/01/27/leetcode-21-Merge%20Two%20Sorted%20Lists/"/>
      <url>/2020/01/27/leetcode-21-Merge%20Two%20Sorted%20Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/merge-two-sorted-lists</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>遍历即可，注意参数校验。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="keyword">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历合并即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="comment">// 参数健壮性编写</span></span><br><span class="line"><span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mergeList *ListNode</span><br><span class="line"><span class="keyword">var</span> currentNode *ListNode</span><br><span class="line"><span class="comment">// 选取头结点 复用 l1 l2 地址</span></span><br><span class="line"><span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">mergeList = l1</span><br><span class="line">l1 = l1.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mergeList = l2</span><br><span class="line">l2 = l2.Next</span><br><span class="line">&#125;</span><br><span class="line">currentNode = mergeList</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 退出循环条件</span></span><br><span class="line"><span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">currentNode.Next = l2</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">currentNode.Next = l1</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较大小</span></span><br><span class="line"><span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">currentNode.Next = l1</span><br><span class="line">l1 = l1.Next</span><br><span class="line">currentNode = currentNode.Next</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">currentNode.Next = l2</span><br><span class="line">currentNode = currentNode.Next</span><br><span class="line">l2 = l2.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mergeList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMergeTwoLists</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">l5 := &amp;ListNode&#123;<span class="number">16</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">l4 := &amp;ListNode&#123;<span class="number">8</span>, l5&#125;</span><br><span class="line">l3 := &amp;ListNode&#123;<span class="number">4</span>, l4&#125;</span><br><span class="line">l2 := &amp;ListNode&#123;<span class="number">2</span>, l3&#125;</span><br><span class="line">l1 := &amp;ListNode&#123;<span class="number">1</span>, l2&#125;</span><br><span class="line"></span><br><span class="line">ll3 := &amp;ListNode&#123;<span class="number">6</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">ll2 := &amp;ListNode&#123;<span class="number">3</span>, ll3&#125;</span><br><span class="line">ll1 := &amp;ListNode&#123;<span class="number">1</span>, ll2&#125;</span><br><span class="line">res := mergeTwoLists(l1, ll1)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> res == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"=&gt;%v"</span>, res.Val)</span><br><span class="line">res = res.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-20-Valid Parentheses</title>
      <link href="/2020/01/27/leetcode-20-Valid%20Parentheses/"/>
      <url>/2020/01/27/leetcode-20-Valid%20Parentheses/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Given a string containing just the characters '(', ')', '&#123;', '&#125;', '[' and ']', determine if the input string is valid.</span><br><span class="line"></span><br><span class="line">An input string is valid if:</span><br><span class="line"></span><br><span class="line">Open brackets must be closed by the same type of brackets.</span><br><span class="line">Open brackets must be closed in the correct order.</span><br><span class="line">Note that an empty string is also considered valid.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: "()"</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: "()[]&#123;&#125;"</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: "(]"</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line">Input: "([)]"</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Example 5:</span><br><span class="line">Input: "&#123;[]&#125;"</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/valid-parentheses</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>可使用栈的特点进行解答。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用栈的思路进行解答</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> stack []<span class="keyword">string</span> <span class="comment">// 自定义栈</span></span><br><span class="line">   <span class="keyword">for</span> _, str := <span class="keyword">range</span> s &#123;</span><br><span class="line">      <span class="keyword">switch</span> str &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">         <span class="keyword">fallthrough</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">         <span class="keyword">fallthrough</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">         <span class="comment">// 入栈</span></span><br><span class="line">         stack = <span class="built_in">append</span>(stack, <span class="keyword">string</span>(str))</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">         <span class="comment">// 查看是否相等并出栈</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         ch := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">         <span class="keyword">if</span> ch == <span class="string">"("</span> &#123;</span><br><span class="line">            <span class="comment">// 出栈</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">1</span> &#123;</span><br><span class="line">               stack = stack[<span class="number">0</span> : <span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               stack = stack[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">         <span class="comment">// 查看是否相等并出栈</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         ch := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">         <span class="keyword">if</span> ch == <span class="string">"&#123;"</span> &#123;</span><br><span class="line">            <span class="comment">// 出栈</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">1</span> &#123;</span><br><span class="line">               stack = stack[<span class="number">0</span> : <span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               stack = stack[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">         <span class="comment">// 查看是否相等并出栈</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         ch := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">         <span class="keyword">if</span> ch == <span class="string">"["</span> &#123;</span><br><span class="line">            <span class="comment">// 出栈</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">1</span> &#123;</span><br><span class="line">               stack = stack[<span class="number">0</span> : <span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               stack = stack[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIsValid</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   <span class="built_in">println</span>(isValid(<span class="string">"[&#123;&#123;&#125;&#125;]"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年个人总结</title>
      <link href="/2020/01/20/2019-summary/"/>
      <url>/2020/01/20/2019-summary/</url>
      
        <content type="html"><![CDATA[<p>每年都能看到师兄有在写博客的年终总结，列出一整年下来的收获与感悟，看了之后觉得很不错，自己也得到了许多的收获与感想。</p><p>于是乎便也有了想法想把自己每年的经历和想法记录下来，但是每次都是一打开草稿就不知从何下笔，毕竟距离上一次写作文好像是高考了吧🤣。</p><p>这次终于下定决心，无论写的再糟也要尝试一下，那么接下来就开始好好的对这一年进行总结梳理吧。</p><a id="more"></a><h3 id="复盘总结"><a href="#复盘总结" class="headerlink" title="复盘总结"></a>复盘总结</h3><h5 id="去年目标"><a href="#去年目标" class="headerlink" title="去年目标"></a>去年目标</h5><p>由于去年没有好好进行总结和立下<code>flag</code>，所以没有一个特别好的参照标准，仔细想了想，去年这时候的我应该最迫切的想要实现的目标有这几个吧~</p><ul><li><input checked="" disabled="" type="checkbox"> 好好做好实习工作, 努力转正</li><li><input checked="" disabled="" type="checkbox"> 减肥</li><li><input checked="" disabled="" type="checkbox"> 大学最后一年拿到奖学金</li><li><input disabled="" type="checkbox"> 学会游泳 <strong><em>70%</em></strong></li><li><input disabled="" type="checkbox"> 毕业前来一次毕业旅行</li><li><input disabled="" type="checkbox"> 通过英语六级</li><li><input disabled="" type="checkbox"> 坚持写博客  <strong><em>5%</em></strong></li></ul><h5 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h5><p>遗憾的是除了前三项后面的都没怎么好好完成~具体细节在下面在仔细说下吧。</p><h3 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h3><p>往年都是参加师兄师姐的毕业典礼，和他们一块拍毕业照。如今终于也轮到了自己，回顾大学的四年时光（其实感觉也就待了两年半，大三后半学期+大四一年基本都是在实习中度过的），感觉自己并没有好好珍惜这几年下来的人与事，最起码在大学期间我们宿舍四个人都没一起出去吃过一次饭😓。</p><p>其中值得纪念的有两件事：</p><ol><li>在大学的最后一年生涯里，还是成功拿到了一次二等奖学金（前几年都是差一点~），成功薅到了一点学费的羊毛回来😂也是大学生涯里面为数不多的闪光点了吧；</li><li>在快要离开学校的最后一个月里和同学学了游泳（然而还是半吊子，并不能很长距离的换气游🤣），当时就特别后悔在大学仅能报四次的体育课里为啥没有学游泳，而是打了三个学期的乒乓球 + 一个学期的羽毛球，还好最后还是稍微弥补了这点遗憾。</li></ol><p>而遗憾的事情就特别多了，比如没有好好学习英语，总是给自己找这个那个借口，买的英语六级试卷都没有好好做几篇，最后连六级的考试都没有回学校参加考试了；还有人际关系的维护和性格不成熟等等等…</p><p>最后一天离开学校</p><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/CFFB8A7E-7D34-4BF5-A924-E6753AD681DB_1_105_c.jpeg" alt="离开学校"></p><p>星空十周年：</p><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/4DA45AF4-2249-4E26-91D7-3566C9720785_1_105_c.jpeg" alt="星空十周年"></p><p>感谢一路上来给予过我帮助的老师同学，还有<strong>星空</strong>这个大家庭，虽然大三和大四两年里没有接着任职，但是还是非常感谢它带我走入了编程的大门，认识了许多一起共事有趣的灵魂和可以作为人生道路学习榜样的师兄。谢谢你们👏</p><h3 id="实习生到正式员工"><a href="#实习生到正式员工" class="headerlink" title="实习生到正式员工"></a>实习生到正式员工</h3><p>从18年6月到WPS进行实习，到19年7月转正，再到现在的2020年1月，满打满算其实已经在WPS里工作有一年半多了（当然实习的时候中间有很多时间回学校处理毕业相关事宜了），中间也经历了几个公司比较重要的节点，例如公司30周年、科创板上市成功。总的来说对公司和大佬们的领导也是具有归属和认同感的，感激公司和大佬的悉心栽培，在里面学到了很多技术知识和为人处世之道。最后也很感激大佬的信任和器重，拿到了卓越实习生并且最后成功转正。从实习生到正式员工，感觉自己肩上的担子也变重了，以后也会加倍努力不辜负大佬们的信任~</p><p>新员工培训合照</p><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/FAFE9709-B533-4942-A5D7-467D15E414DB_1_105_c.jpeg" alt="新员工培训合照"></p><p>优秀实习生</p><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/C6196958-B711-4B7F-A1D4-6C52DC9BBF09_1_105_c.jpeg" alt="优秀实习生"></p><p>园区海滩，又安静人又少，超适合居住（我才一点都不羡慕呢~🍋🍋🍋）</p><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/72220382-6A5D-47C1-9D89-859D20833D00_1_105_c.jpeg" alt="园区海滩"></p><h3 id="减肥（跑步-keep-游泳）"><a href="#减肥（跑步-keep-游泳）" class="headerlink" title="减肥（跑步+keep+游泳）"></a>减肥（跑步+keep+游泳）</h3><p>减肥的话其实是在下半年才算是开始认真对待起来，虽然上半年也偶尔有进行跑步，但是总的来说还是摄入比消耗的多，而且其实在上半年直到新员工培训的时候还是特别胖的，那个时间段朋友圈好友也还都评论胖的都不认识了😂，直到下半年国庆回家亲戚好友才说瘦了些，当时培训的小伙伴也说认不出我了（可能变丑了吧🤣）。 </p><p>下半年很高兴认识了一块跑步锻炼的小伙伴，通过每天下班后约跑，还有晚饭少吃或不吃（直接吃水果代替，因为公司有下午茶，晚上有时候其实不是特别的饿，不太推荐不吃），所以整体下来还是比较有成效的，从19年1月算起到19年12月最后一天，一整年下来一共跑了109次，所以说做什么事其实都还是要靠毅力和持之以恒的决心。</p><p>中间也有做过一段时间的keep，下班回家也有做健身环大冒险，还有周末偶尔继续去游泳。生活上改变饮食习惯。目前还是有点小肚子，明年还是需要继续努力👏还有就是非常感谢超哥大佬，虽然我经常毒舌调侃你🤣</p><p>目前体重</p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/8D2A2ECF-2D73-43B5-AF4F-C1AF7C786B9A_1_105_c.jpeg" alt="目前体重" style="zoom:50%;" /><p>去年体重</p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/IMG_725D15749B22-1.jpeg" style="zoom:30%;" /><h3 id="数码产品"><a href="#数码产品" class="headerlink" title="数码产品"></a>数码产品</h3><p>今年终于从实习生转为了正式员工，手里终于也再也不用紧巴巴的过日子了（可能还没经过社会主义的毒打），于是便大手大脚的购入了一堆设备🤣，真的是半毛钱都攒不下来，哎🙃</p><p>设备清单：</p><table><thead><tr><th align="center">设备名</th><th align="center">价格</th><th align="center">入手时间</th><th align="center">使用感想</th></tr></thead><tbody><tr><td align="center">iPad 2018 32GB</td><td align="center">2288</td><td align="center">2018/06/01</td><td align="center">第一个入手的苹果设备，当初的使用感想忘记了，目前觉得有点鸡肋。现在还好可以使用mac的随航作为副屏来使用，偶尔追追剧看看PDF文档还是不错的。</td></tr><tr><td align="center">apple pencil 亚太版</td><td align="center">608</td><td align="center">2018/06/10</td><td align="center">当时入手主要是想培养画画的兴趣爱好，还有阅读PDF文档做笔记，可能当时在学校还是挺有用的，工作之后几乎没怎么使用了。</td></tr><tr><td align="center">iPhone XR 128GB</td><td align="center">6399</td><td align="center">2018/12/12</td><td align="center">由于宿舍三个都是用苹果手机，并且当时在体验到ipad的流畅程度之后，决心下一步手机入手iphone的，使用上来说的确无可挑剔，到现在也算使用了一年多一些了，也没有啥毛病，算是我用过时间算比较久的一台手机了🤣美中不足的是买完没多久苹果就价格大跳水，直接亏了好多。9月份给老妈也买了一台，4k多就能买到了，真是心碎~</td></tr><tr><td align="center">AirPods2</td><td align="center">1099</td><td align="center">2019/07/05</td><td align="center">最满意的电子设备之一，几乎无可挑剔。在苹果的生态之下完美切换各种设备，就是用了几个月价格也跳水了🤣</td></tr><tr><td align="center">Appl Watch Series 5</td><td align="center">2999</td><td align="center">2019/10/08</td><td align="center">当时跑步满了一百天，买给自己的一个礼物。功能上的确很不错，但是价格偏贵，而且一天一充，经常运动的人可以考虑，不大推荐。这个设备还买了AC+，怕不小心摔坏了，真是败家🙃</td></tr><tr><td align="center">2019 16寸 MacBook Pro</td><td align="center">15513</td><td align="center">2019/12/07</td><td align="center">目前买过的最贵的电子设备，刚开始不太习惯mac的操作逻辑，后面习惯了之后觉得还好，目前还在适应中，由于公司配了电脑所以使用频率稍低，后续会带到公司辅助使用。</td></tr><tr><td align="center">港版Switch续航加强版</td><td align="center">1899</td><td align="center">2019/11/12</td><td align="center">当时PDD折扣入手的，想着不买mbp买这个好了，最后还是没忍住，哎☹️不是现充非常不推荐入手，一个人玩单机游戏绝对会自闭的，没错，说的就是我😪适合过年过节回家和家人一块玩。考虑年后出手。</td></tr><tr><td align="center">其他一堆游戏卡</td><td align="center">xxxx</td><td align="center">xxxxx</td><td align="center">手头中的游戏中最值得推荐的游戏有两个。1.「健身环大冒险」真正做到了娱乐和锻炼一起并行的游戏，非常适合一个人在家下班后锻炼，也适合全家一起玩小游戏 2.「塞尔达传说 荒野之息」游戏细节丰富，即使是两年后热度仍不减，不愧IGN 2017最佳游戏。</td></tr></tbody></table><h4 id="聊一聊苹果生态"><a href="#聊一聊苹果生态" class="headerlink" title="聊一聊苹果生态"></a>聊一聊苹果生态</h4><p>为什么会入了苹果的坑？主要是身边有一堆果吹，三个舍友用的都是iPhone，并且在这之前用的都是Android手机，所以想换一下看看是不是有他们吹的这么神奇，其结果就是入了几个设备之后就入了坑了😓目前也算是集齐了一套生态设备了，在这可以以我的使用角度简单聊一聊使用体验，首先隔空投递、handoff、随航的体验都非常不错，你在手机拍的一张照片、复制的一段文字，都可以无缝在mac上进行裁切、编辑。airpods可以对你手上的任何设备无缝切换。这种使用体验在之前的android阵营是从来没有体验过的。主要和最大的缺点就是贵，可能这是我的缺点吧☹️</p><p>晒一张全家福：</p><p><img src="https://blog-1251737177.cos.ap-guangzhou.myqcloud.com/6BE81D30-54C9-40D1-968C-16FB2F102FE7_1_105_c.jpeg" alt="电子设备全家福"></p><h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>想了很久怎么描述，最后还是「遗憾」一词概况吧。</p><h3 id="生活日常"><a href="#生活日常" class="headerlink" title="生活日常"></a>生活日常</h3><p>一个人在外工作之后经常多愁善感，虽然平时老是嘻嘻哈哈的，其实我内心还是一个极度悲观的人。所幸的是遇到许多积极乐观的小伙伴，才不至于这么自闭吧（ 不过好像也逐渐被我传染了🤣）。</p><p>印象深刻的是一次感冒发烧，以为睡一下觉就会好，强行撑到了周日晚上最后实在没办法了才去看。一个人在外还是多照顾好自己吧。</p><p>下半年的时候还培养了另一个习惯，记账。记录了自己的消费习惯和主要开销，以后再接再厉继续保持。</p><h3 id="明年Flag"><a href="#明年Flag" class="headerlink" title="明年Flag"></a>明年Flag</h3><ul><li>完全学会游泳，保持锻炼身体，减掉肚子的肥肉。早睡早起；</li><li>多读书，少刷B站（占用太多时间了）；</li><li>写Blog，坚持至少一周一篇；</li><li>坚持技术学习，如读开源项目源码&amp;学习热门知识的使用等，工作上更加努力；</li><li>来一次旅游，目前计划和舍友去看LOL S赛；</li><li>攒钱&amp;理财&amp;理性消费 (今年应该是不会再买任何电子设备了~)；</li><li>多积攒人际关系&amp;减少自己性格的恶劣点(毒舌&amp;yygq等~)；</li><li>培养列举计划清单习惯，规划好自己的时间。</li></ul><p>以上计划会列出量化指标，例如减肥具体到减多少斤、读书读多少本等，希望在明年的年末总结的时候通通都能实现吧😋</p><h3 id="2020年冲冲冲，奥利给！"><a href="#2020年冲冲冲，奥利给！" class="headerlink" title="2020年冲冲冲，奥利给！"></a>2020年冲冲冲，奥利给！</h3>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日leetcode-13-罗马数字转整数</title>
      <link href="/2019/12/17/%E6%AF%8F%E6%97%A5leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/2019/12/17/%E6%AF%8F%E6%97%A5leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。<br>同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure><p>题目地址：<a href="https://leetcode-cn.com/problems/roman-to-integer" target="_blank" rel="noopener">两数之和</a></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>依题意解即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line">ints := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">v := string2int(<span class="keyword">string</span>(value))</span><br><span class="line">ints[index] = v</span><br><span class="line">sum += v</span><br><span class="line"><span class="comment">// 左边比右边小则进行 sum - 2 * ints[index-1]</span></span><br><span class="line"><span class="keyword">if</span> index != <span class="number">0</span> &amp;&amp; ints[index<span class="number">-1</span>] &lt; v &#123;</span><br><span class="line">sum -= <span class="number">2</span> * ints[index<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2int</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"I"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"V"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"X"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"L"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"D"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">500</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"M"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_romanToInt</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(romanToInt(<span class="string">"MCMXCIV"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 每日训练 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日leetcode-回文数-9</title>
      <link href="/2019/12/16/%E6%AF%8F%E6%97%A5leetcode-%E5%9B%9E%E6%96%87%E6%95%B0-9/"/>
      <url>/2019/12/16/%E6%AF%8F%E6%97%A5leetcode-%E5%9B%9E%E6%96%87%E6%95%B0-9/</url>
      
        <content type="html"><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 121</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br><span class="line">进阶:</span><br><span class="line"></span><br><span class="line">你能不将整数转为字符串来解决这个问题吗？</span><br></pre></td></tr></table></figure><p>题目地址：<a href="https://leetcode-cn.com/problems/palindrome-number" target="_blank" rel="noopener">两数之和</a></p><a id="more"></a><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>同整数回转, 取目标数的每位并回转判断。负数及对10求余等于0的数（不包括0）表示最后一为一定为0, 必不可能是回文数。</p><p>最佳解法只要反转一半数字再判断是否相等，就知道是不是回文数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">而当x小于保存的数时，即表示已经到达中间了</span><br><span class="line">e.g. x:12321 res:0 -&gt; x:12321 res:1 -&gt; x:1232 res:12 -&gt; x:123 &#x3D;&gt; res &#x3D; x&#x2F;10</span><br><span class="line">此时x&lt;&#x3D;res则跳出循环去判断，分奇数和偶数两种情况，奇数时res要整除10</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">pre_x := x</span><br><span class="line">reverseNum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; ; &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">reverseNum = reverseNum * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">x /= <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre_x == reverseNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_isPalindrome</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(isPalindrome(<span class="number">123321</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最佳解"><a href="#最佳解" class="headerlink" title="最佳解"></a>最佳解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 只要是负数，肯定不是回文数</span></span><br><span class="line"><span class="comment">// 若对十求余数为0，表明最后一位是0，肯定不是回文数</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="comment">// 只要反转一半数字再判断是否相等，就知道是不是回文数</span></span><br><span class="line"><span class="comment">// 而当x小于保存的数时，即表示已经到达中间了</span></span><br><span class="line"><span class="comment">// e.g. x:12321 res:0 -&gt; x:12321 res:1 -&gt; x:1232 res:12 -&gt; x:123 =&gt; res = x/10</span></span><br><span class="line"><span class="comment">// 此时x&lt;=res则跳出循环去判断，分奇数和偶数两种情况，奇数时res要整除10</span></span><br><span class="line"><span class="keyword">for</span> x &gt; res &#123;</span><br><span class="line">tmp := x % <span class="number">10</span></span><br><span class="line">x /= <span class="number">10</span></span><br><span class="line">res = res*<span class="number">10</span> + tmp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x == res || x == res / <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 每日训练 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日leetcode-整数翻转-7</title>
      <link href="/2019/12/14/%E6%AF%8F%E6%97%A5leetcode-%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC-7/"/>
      <url>/2019/12/14/%E6%AF%8F%E6%97%A5leetcode-%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC-7/</url>
      
        <content type="html"><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><p><strong><em>注意:</em></strong><br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-integer" target="_blank" rel="noopener">点击这里~</a></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>循环求得每位数值并乘以反转后的指数即可, 注意数据范围溢出。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> res <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">res = res*<span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">x /= <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据补码 最大值为除首位全是1 先取全1后右移首位为0  需转换为int类型 否则后续计算数值时不检验首位</span></span><br><span class="line"><span class="keyword">const</span> INT32_MAX = <span class="keyword">int</span>(^<span class="keyword">uint32</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 除首位外全是0 取最大值反码即可</span></span><br><span class="line"><span class="keyword">const</span> INT32_MIN = ^INT32_MAX</span><br><span class="line"><span class="built_in">println</span>(INT32_MAX)</span><br><span class="line"><span class="built_in">println</span>(INT32_MIN)</span><br><span class="line"><span class="keyword">if</span> res &lt; INT32_MIN || res &gt; INT32_MAX &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_reverseNumber</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(reverse(<span class="number">123</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 每日训练 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日leetcode-两数之和-1</title>
      <link href="/2019/12/09/%E6%AF%8F%E6%97%A5leetcode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-1/"/>
      <url>/2019/12/09/%E6%AF%8F%E6%97%A5leetcode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-1/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line"></span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p>题目地址：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></p><a id="more"></a><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基于数组建立value-index 的hash表， 循环遍历判断 <code>hashmap[target - num]</code> 是否存在即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> easy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 以 value, index 建立哈希表</span></span><br><span class="line"><span class="comment">// 初始化时建立可避免重复值问题 如 [3, 3] 6</span></span><br><span class="line">hashMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 循环哈希表查看是否存在对应索引</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> nums &#123;</span><br><span class="line">otherKey := target - value</span><br><span class="line"><span class="keyword">if</span> otherIndex, has := hashMap[otherKey]; has &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;otherIndex, index&#125;</span><br><span class="line">&#125;</span><br><span class="line">hashMap[value] = index</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_main</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, twoSum([]<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">3</span>&#125;, <span class="number">6</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 每日训练 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日leetcode-翻转字符串里的单词</title>
      <link href="/2019/01/15/%E6%AF%8F%E6%97%A5leetcode-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
      <url>/2019/01/15/%E6%AF%8F%E6%97%A5leetcode-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;,</span><br><span class="line">输出: &quot;blue is sky the&quot;.</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>无空格字符构成一个单词。</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><p><strong>进阶:</strong> 请选用C语言的用户尝试使用 <em>O</em>(1) 空间复杂度的原地解法。</p><p>题目地址：<a href="https://leetcode-cn.com/explore/interview/card/bytedance/242/string/1011/" target="_blank" rel="noopener">这里~</a></p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>java暴力破解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 翻转字符串里的单词 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 健壮性判空</span></span><br><span class="line">        <span class="keyword">if</span> (s.trim().isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String[] ss = s.split(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ss.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ss[i].isEmpty())&#123;</span><br><span class="line">                sb.append(ss[i]).append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除最后添加的空格</span></span><br><span class="line">        <span class="keyword">return</span> sb.deleteCharAt(sb.length()-<span class="number">1</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(reverseWords(<span class="string">"     "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意特殊值的判断。</p><h2 id="官方最佳答案："><a href="#官方最佳答案：" class="headerlink" title="官方最佳答案："></a>官方最佳答案：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">char</span>[] ch=s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] res=<span class="keyword">new</span> <span class="keyword">char</span>[ch.length];</span><br><span class="line">        <span class="keyword">int</span> len=helper(ch,ch.length-<span class="number">1</span>,res,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(res,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] ch,<span class="keyword">int</span> r,<span class="keyword">char</span>[] res,<span class="keyword">int</span> l,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;=<span class="number">0</span>&amp;&amp;ch[r]==<span class="string">' '</span>)&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>)<span class="keyword">return</span> Math.max(<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> rigth=r;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;=<span class="number">0</span>&amp;&amp;ch[r]!=<span class="string">' '</span>)&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        len+=rigth-r+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=r+<span class="number">1</span>;left&lt;=rigth;left++,l++)&#123;</span><br><span class="line">            res[l]=ch[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;res.length)&#123;</span><br><span class="line">            res[l++]=<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(ch,r,res,l,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 每日训练 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日leetcode-字符串相乘</title>
      <link href="/2018/12/27/%E6%AF%8F%E6%97%A5leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
      <url>/2018/12/27/%E6%AF%8F%E6%97%A5leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><code>num1</code> 和 <code>num2</code> 的长度小于110。</li><li><code>num1</code> 和 <code>num2</code> 只包含数字 <code>0-9</code>。</li><li><code>num1</code> 和 <code>num2</code> 均不以零开头，除非是数字 0 本身。</li><li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li></ol><p>题目链接：<a href="https://leetcode-cn.com/explore/interview/card/bytedance/242/string/1015/" target="_blank" rel="noopener">点击这里~</a></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于 <code>num1</code> 和 <code>num2</code> 长度最大为 <strong><em>110</em></strong>，故两数相乘的长度最大 <code>110 * 110</code>  位，<code>long</code> 为8字节 所能表示的最大长度为 2^64，所能表示最大长度远远小于目标位数，故 将字符串转为int类型后在做运算在转回字符串的方法行不通。</p><p>研究乘法计算发现规律， 以 <code>123 *456 = 56088</code> 举例：</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">*</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center">4</td><td align="center">5</td><td align="center">6</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center">1 * 6 = 6</td><td align="center">2 * 6 = 12</td><td align="center">3 * 6 = 18</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td>1 * 5 = 5</td><td align="center">2 * 5 = 10</td><td align="center">3 * 5 = 15</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">4 * 1 = 4</td><td>4 * 2 = 8</td><td align="center">4 * 3 = 12</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">4</td><td>5 + 8 = 13</td><td align="center">6 + 10 + 12 = 28</td><td align="center">12 + 15 =27</td><td align="center">18</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">40000</td><td>10000 + 3000</td><td align="center">2000 + 800</td><td align="center">200 + 70</td><td align="center">10 + 8</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">40000 + 10000</td><td>3000 +2000</td><td align="center">800 + 200</td><td align="center">70 + 10</td><td align="center">8</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">5</td><td>6</td><td align="center">0</td><td align="center">8</td><td align="center">8</td></tr></tbody></table><p>则可以通过逐位相乘在相加的形式完成大数的乘法运算。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = num1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = num2.length();</span><br><span class="line">        <span class="comment">// 获得最大位数建立数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + len2];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历计算每位对应的数值 从最低位开始</span></span><br><span class="line">        <span class="keyword">int</span> n1, n2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            n1 = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                n2 = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                res[i + j + <span class="number">1</span>] += n1 * n2;</span><br><span class="line">                <span class="comment">// 如果大于10则向前进位</span></span><br><span class="line">                <span class="keyword">if</span>(res[i + j + <span class="number">1</span>] &gt;= <span class="number">10</span> )&#123;</span><br><span class="line">                    res[i + j] += res[i + j + <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">                    res[i + j + <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将int数组转为字符串</span></span><br><span class="line">        StringBuilder stringBuffer = <span class="keyword">new</span> StringBuilder(len1 + len2);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : res)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuffer.append(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuffer.toString().isEmpty() ? <span class="string">"0"</span> : stringBuffer.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难点：注意进位问题</p><h2 id="官方最佳解答"><a href="#官方最佳解答" class="headerlink" title="官方最佳解答"></a>官方最佳解答</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String multiply(String num1, String num2) &#123;</span><br><span class="line">if(num1.isEmpty() || num2.isEmpty() </span><br><span class="line">           ||(num1.length() &#x3D;&#x3D; 1 &amp;&amp; num1.charAt(0) &#x3D;&#x3D; &#39;0&#39;) </span><br><span class="line">           || (num2.length() &#x3D;&#x3D; 1 &amp;&amp; num2.charAt(0) &#x3D;&#x3D; &#39;0&#39;))</span><br><span class="line">return &quot;0&quot;;</span><br><span class="line">int len1 &#x3D; num1.length();</span><br><span class="line">int len2 &#x3D; num2.length();</span><br><span class="line">int[] ans &#x3D; new int[len1 + len2 + 1];</span><br><span class="line">for(int i &#x3D; 0 ; i &lt; len1;i++) &#123;</span><br><span class="line">int a &#x3D; num1.charAt(i) - &#39;0&#39;;</span><br><span class="line">for(int j &#x3D; 0; j &lt; len2; j++) &#123;</span><br><span class="line">int b &#x3D; num2.charAt(j) - &#39;0&#39;;</span><br><span class="line">ans[len1 + len2 - i - j - 2] +&#x3D; a * b ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">StringBuffer res &#x3D; new StringBuffer();</span><br><span class="line">for(int i &#x3D; 0; i &lt; len1 + len2   ;i++) &#123;</span><br><span class="line">res.append(ans[i] % 10);</span><br><span class="line">ans[i + 1] +&#x3D; ans[i] &#x2F; 10;</span><br><span class="line">&#125;</span><br><span class="line">String result &#x3D; res.reverse().toString();</span><br><span class="line">if(result.startsWith(&quot;0&quot;))</span><br><span class="line">result &#x3D; result.substring(1, len1 + len2);</span><br><span class="line">return result;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 每日训练 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习入门(4)-降低损失</title>
      <link href="/2018/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-4-%E9%99%8D%E4%BD%8E%E6%8D%9F%E5%A4%B1/"/>
      <url>/2018/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-4-%E9%99%8D%E4%BD%8E%E6%8D%9F%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<h4 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h4><p>上一节有提到<strong>损失</strong>用于表示模型对于单个样本预测准确程度的一个数值，那么问题就转移到了我们该如何降低损失呢？</p><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p><img src="https://pic.fengyuwusong.cn/MPic/20181219/53LXBTUXHElx.png" alt="mark"></p><p><strong>图 1. 用于训练模型的迭代方法。</strong></p><a id="more"></a><p>在机器学习中，迭代方法的应用十分的普遍，他的逻辑是通过不停的尝试来降低损失值。</p><p>例如对于线性回归公式<br>$$<br>y’=b+w_1x_1<br>$$<br><strong>b *<em>和 *</em>w1</strong>的初始值应该设置为什么比较好呢？</p><p>事实证明初始值并不重要。我们可以随机选择值，不过我们还是选择采用以下这些无关紧要的值：</p><ul><li>b= 0</li><li>w1 = 0</li></ul><p>假设第一个特征值是 10。将该特征值代入预测函数会得到以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y&#39; &#x3D; 0 + 0(10)</span><br><span class="line">y&#39; &#x3D; 0</span><br></pre></td></tr></table></figure><p>图中的“计算损失”部分是模型将要使用的<a href="https://developers.google.cn/machine-learning/crash-course/descending-into-ml/training-and-loss" target="_blank" rel="noopener">损失函数</a>。假设我们使用平方损失函数。损失函数将采用两个输入值：</p><ul><li>y’：模型对特征 x 的预测</li><li>y：特征 x 对应的正确标签。</li></ul><p>这时需要进行的是图一中的 <strong>计算参数更新</strong>， 具体是计算该 b 和 w1 下的损失值，然后再生成新的 b 和 w1。 这个过程会持续迭代，直至算法发现损失可能是最低的模型参数。</p><p><strong>收敛</strong>： 当在不断迭代的情况下，损失值不变或十分缓慢，这时可以说该模型已经收敛。</p><h2 id="该怎么进行计算参数？"><a href="#该怎么进行计算参数？" class="headerlink" title="该怎么进行计算参数？"></a>该怎么进行计算参数？</h2><p>在上面的迭代方法中，最重要的一步就是计算参数更新。那么该怎么计算参数直至模型收敛呢？</p><p>对于回归问题而言，所产生的损失和 <strong>w1</strong> 的关系是个凸形的，即只有一个斜率为0的位置：</p><p><img src="https://pic.fengyuwusong.cn/MPic/20181219/73H0L044vBuC.png" alt="mark"> </p><p><strong>图 2. 回归问题产生的损失与权重图为凸形。</strong></p><p>该斜率为 0 的地方即损失函数的收敛之处。</p><h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p>梯度下降法的第一个阶段是为 w1 选择一个起始值（起点）。起点并不重要；因此很多算法就直接将 w1 设为 0 或随机选择一个值。下图显示的是我们选择了一个稍大于 0 的起点：</p><p><img src="https://pic.fengyuwusong.cn/MPic/20181219/F7JPHnUY4IuD.png" alt="mark"></p><p><strong>图 3. 梯度下降法的起点。</strong></p><p>然后，梯度下降法算法会计算损失曲线在起点处的梯度。简而言之，<strong>梯度</strong>是偏导数的矢量；它可以让您了解哪个方向距离目标“更近”或“更远”。请注意，损失相对于单个权重的梯度（如图 3 所示）就等于导数。</p><p>主要的数学理论之后再写博客介绍，此处涉及的有 <strong><em>导数、偏导数、梯度</em></strong>。</p><p>请注意，梯度是一个矢量，因此具有以下两个特征：</p><ul><li>方向</li><li>大小</li></ul><p>梯度始终指向损失函数中增长最为迅猛的方向。梯度下降法算法会沿着负梯度的方向走一步，以便尽快降低损失。</p><p><img src="https://pic.fengyuwusong.cn/MPic/20181219/vTnBdkhvlMir.png" alt="mark"></p><p><strong>图 4. 梯度下降法依赖于负梯度。</strong></p><p>为了确定损失函数曲线上的下一个点，梯度下降法算法会将梯度大小的一部分与起点相加，如下图所示：</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1545230013329.png" alt="1545230013329"></p><p><strong>图 5. 一个梯度步长将我们移动到损失曲线上的下一个点。</strong></p><p>然后，梯度下降法会重复此过程，逐渐接近最低点。</p><h2 id="学习速率"><a href="#学习速率" class="headerlink" title="学习速率"></a>学习速率</h2><p><strong>学习速率</strong>： 决定迭代中下一个点的位置， 一般是梯度乘以学习速率。</p><p><strong>超参数</strong>：编程人员在机器学习算法中用于调整的旋钮</p><p>学习速率不宜过大或过小。</p><p><img src="https://pic.fengyuwusong.cn/MPic/20181219/pq7kOK0KzpPp.png" alt="mark"></p><h2 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h2><p><strong>批量</strong>： 用于在单次迭代中计算梯度的样本总数。</p><p><strong>随机梯度下降法</strong> (<strong>SGD</strong>) ： 每次只迭代计算一个随机样本的损失值，减少计算量。</p><p><strong>小批量随机梯度下降法</strong>（<strong>小批量 SGD</strong>）： 每次只迭代计算小批量随机样本的损失值，小批量通常包含 10-1000 个随机选择的样本。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 损失 </tag>
            
            <tag> 迭代方法， 学习速率， 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习入门(3)-线性回归&amp;训练与损失</title>
      <link href="/2018/12/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-3-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E8%AE%AD%E7%BB%83%E4%B8%8E%E6%8D%9F%E5%A4%B1/"/>
      <url>/2018/12/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-3-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E8%AE%AD%E7%BB%83%E4%B8%8E%E6%8D%9F%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<p>人们早就知晓，相比凉爽的天气，蟋蟀在较为炎热的天气里鸣叫更为频繁。数十年来，专业和业余昆虫学者已将每分钟的鸣叫声和温度方面的数据编入目录。Ruth 阿姨将她喜爱的蟋蟀数据库作为生日礼物送给您，并邀请您自己利用该数据库训练一个模型，从而预测鸣叫声与温度的关系。</p><p><img src="https://pic.fengyuwusong.cn/MPic/20181218/wimobUtyqSDn.png" alt="图1"></p><p><strong>图 1. 每分钟的鸣叫声与温度（摄氏度）的关系。</strong></p><a id="more"></a><p>毫无疑问，此曲线图表明温度随着鸣叫声次数的增加而上升。鸣叫声与温度之间的关系是线性关系吗？是的，您可以绘制一条直线来近似地表示这种关系，如下所示：</p><p><img src="https://pic.fengyuwusong.cn/MPic/20181218/tmJtKu9fePCq.png" alt="图2"></p><p><strong>图 2. 线性关系。</strong></p><p>事实上，虽然该直线并未精确无误地经过每个点，但针对我们拥有的数据，清楚地显示了鸣叫声与温度之间的关系。只需运用一点代数知识，您就可以将这种关系写下来，如下所示：<br>$$<br>y=mx+b<br>$$<br>即一元一次方程。</p><p>其中：</p><ul><li>y 指的是温度（以摄氏度表示），即我们试图预测的值。</li><li>m 指的是直线的斜率。</li><li>x 指的是每分钟的鸣叫声次数，即输入特征的值。</li><li>b 指的是 y 轴截距。</li></ul><p>按照机器学习的惯例，您需要写一个存在细微差别的模型方程式：<br>$$<br>y′=b+w_1x_1<br>$$<br>其中：</p><ul><li>y`指的是预测<a href="https://developers.google.cn/machine-learning/crash-course/framing/ml-terminology#labels" target="_blank" rel="noopener">标签</a>（理想输出值）。</li><li>b 指的是偏差（y 轴截距）。而在一些机器学习文档中，它称为 w0。</li><li>w1 指的是特征 1 的权重。权重与上文中用 m 表示的“斜率”的概念相同。</li><li>x1 指的是<a href="https://developers.google.cn/machine-learning/crash-course/framing/ml-terminology#features" target="_blank" rel="noopener">特征</a>（已知输入项）。</li></ul><p>要根据新的每分钟的鸣叫声值 x1 <strong>推断</strong>（预测）温度 y′，只需将 x1 值代入此模型即可。</p><p>下标（例如 w1 和 x1）预示着可以用多个特征来表示更复杂的模型。例如，具有三个特征的模型可以采用以下方程式：<br>$$<br>y′=b+w1x1+w2x2+w3x3<br>$$</p><h2 id="训练与损失"><a href="#训练与损失" class="headerlink" title="训练与损失"></a>训练与损失</h2><p><strong>训练模型</strong>：通过有标签样本来学习（确定）所有权重和偏差的理想值。</p><p><strong>损失</strong>： 一个表示对于单个样本而言模型预测的准确程度。如果模型完全准确，则损失为0，反之则越大。</p><p><strong>经验风险最小化</strong>： 检查多个样本并尝试找出可最大限度地减少损失的模型。</p><p>训练模型的目的是从所有样本中找到一组平均损失“较小”的权重和偏差。</p><p>例如：</p><p><img src="https://pic.fengyuwusong.cn/MPic/20181218/jsbb5En4Hhz1.png" alt="图 3"></p><p><strong>图 3. 左侧模型的损失较大；右侧模型的损失较小。</strong></p><h4 id="那么我们该如何定义损失呢？"><a href="#那么我们该如何定义损失呢？" class="headerlink" title="那么我们该如何定义损失呢？"></a>那么我们该如何定义损失呢？</h4><p>一般都是通过创建一个损失函数，以有意义的方式汇总个损失。</p><h5 id="平方损失："><a href="#平方损失：" class="headerlink" title="平方损失："></a>平方损失：</h5><p>接下来我们要看的线性回归模型使用的是一种称为<strong>平方损失</strong>（又称为 <strong>L2 损失</strong>）的损失函数。单个样本的平方损失如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D; (实际值 - 预测值）^2</span><br></pre></td></tr></table></figure><p><strong>均方误差</strong> (<strong>MSE</strong>) 指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量：<br>$$<br>MSE=\frac{1}{N}\sum_{(x,y)∈D}(y−prediction(x))<br>$$<br>其中：</p><ul><li>(x,y)指的是样本，其中<ul><li>x 指的是模型进行预测时使用的特征集（例如，温度、年龄和交配成功率）。</li><li>y 指的是样本的标签（例如，每分钟的鸣叫次数）。</li></ul></li><li>prediction(x) 指的是权重和偏差与特征集 x 结合的函数。</li><li>D 指的是包含多个有标签样本（即 (x,y)）的数据集。</li><li>N 指的是 D 中的样本数量。</li></ul><p>虽然 MSE 常用于机器学习，但它既不是唯一实用的损失函数，也不是适用于所有情形的最佳损失函数。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性回归 </tag>
            
            <tag> 损失 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日leetcode-最长公共前缀</title>
      <link href="/2018/12/14/%E6%AF%8F%E6%97%A5leetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
      <url>/2018/12/14/%E6%AF%8F%E6%97%A5leetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>所有输入只包含小写字母 <code>a-z</code> 。</p><p>题目链接：<a href="https://leetcode-cn.com/explore/interview/card/bytedance/242/string/1014/" target="_blank" rel="noopener">点击这里~</a></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>该题可直接暴力破解，有横向和纵向两种思路：</p><ol><li>先记录第一个字符串，然后以第一个字符串的值去匹配剩下的字符串，遇到不同的则截取匹配下一个。例如：字符串数组为 <code>[&quot;abcde&quot;, &quot;abced&quot;, &quot;abbcde&quot;]</code> 。则当第一个去匹配第二个字符串的时候遇到<code>e</code>和第一个值<code>d</code>不同。故截取剩余<code>abc</code>，同理<code>abc</code>与<code>abb</code>截取后得到<code>ab</code>。</li><li>依次取每个字符串的相同位置字符作对比，不同则返回。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>采用横向对比解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 最长公共前缀 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代码健壮性判断</span></span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String res = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)&#123;</span><br><span class="line">            len = Math.min(res.length(), strs[i].length());</span><br><span class="line">            <span class="comment">// 避免aa 和 a 的情况</span></span><br><span class="line">            res = res.substring(<span class="number">0</span>, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[<span class="number">0</span>].charAt(j)!=strs[i].charAt(j)) &#123;</span><br><span class="line">                    res = res.substring(<span class="number">0</span>, j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(longestCommonPrefix(<span class="keyword">new</span> String[]&#123;<span class="string">"aa"</span>, <span class="string">"a"</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>需要做好代码健壮性，例如输入为 <code>String[]{}</code>。</li><li>特殊情况，例如 <strong><em>aa</em></strong> 和 <strong><em>a</em></strong> 的公共前缀为 <strong><em>a</em></strong>。需取最小值。</li></ol><h2 id="官方最佳答案"><a href="#官方最佳答案" class="headerlink" title="官方最佳答案"></a>官方最佳答案</h2><p>采用了横向对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> shortest = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            shortest = Math.min(shortest, strs[i].length());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shortest; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[j].charAt(i) != ch) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 每日训练 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习入门(2)-机器学习主要术语</title>
      <link href="/2018/12/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-2-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%BB%E8%A6%81%E6%9C%AF%E8%AF%AD/"/>
      <url>/2018/12/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-2-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%BB%E8%A6%81%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h4 id="监督式机器学习"><a href="#监督式机器学习" class="headerlink" title="监督式机器学习"></a>监督式机器学习</h4><p>机器学习系统通过学习如何组合输入信息来对从未见过的数据做出有用的预测。</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p><strong>标签</strong>是要预测的事物，即线性回归中的 <code>y</code> 变量。例如未来某个股票的涨跌，图片的动物品种。</p><p>简单的说即你想要机器预测的内容。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p><strong>特征</strong>是输入变量，即简单线性回归中的 <code>x</code> 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征，按如下方式指定：<br>$$<br>{ x_1, x_2, … x_n }<br>$$<br>举例在识别垃圾邮件的时候，特征变量可能是：</p><ul><li>电子邮件的内容</li><li>发件人地址</li><li>发件时段</li><li>标志词</li></ul><p>等等…</p><a id="more"></a><h4 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h4><p><strong>样本</strong>是指数据的特定实例：<strong>x</strong>。（我们采用粗体 <strong>x</strong> 表示它是一个矢量。）我们将样本分为以下两类：</p><ul><li>有标签样本</li><li>无标签样本</li></ul><p><strong>有标签样本</strong>即同时包含标签和特征。即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labeled examples: &#123;features, label&#125;: (x, y)</span><br></pre></td></tr></table></figure><p>我们使用有标签样本来<strong>训练</strong>模型。</p><p><strong>无标签样本</strong>即只包含特征，没有具体标签的样本，我们需要使用训练好的模型来预测该样本的特征。</p><p>举例在识别垃圾邮件中， 我们明确知道是垃圾邮件或正常邮件的为有标签样本，不知道的为无标签样本。</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>模型定义了特征与标签之间的关系。例如，垃圾邮件检测模型可能会将某些特征与“垃圾邮件”紧密联系起来。我们来重点介绍一下模型生命周期的两个阶段：</p><ul><li><strong>训练</strong>表示创建或<strong>学习</strong>模型。也就是说，您向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。</li><li><strong>推断</strong>表示将训练后的模型应用于无标签样本。也就是说，您使用训练后的模型来做出有用的预测 (<code>y&#39;</code>)。例如，在推断期间，您可以针对新的无标签样本预测其标签。</li></ul><h4 id="回归与分类"><a href="#回归与分类" class="headerlink" title="回归与分类"></a>回归与分类</h4><p><strong>回归</strong>模型可预测连续值。例如，回归模型做出的预测可回答的问题如下：</p><ul><li>加利福尼亚州一栋房产的价值是多少？</li><li>用户点击此广告的概率是多少？</li></ul><p><strong><em>回归模型可以回答确切数值</em></strong></p><p><strong>分类</strong>模型可预测离散值。例如分类模型做出的预测可回答：</p><ul><li>某个指定电子邮件是垃圾邮件还是非垃圾邮件？</li><li>这是一张狗、猫还是仓鼠图片？</li></ul><p><strong><em>分类模型可以回答二分问题</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 术语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日leetcode-无重复字符的最长子串</title>
      <link href="/2018/12/09/%E6%AF%8F%E6%97%A5leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/2018/12/09/%E6%AF%8F%E6%97%A5leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串 <strong>s1</strong> 和 <strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1</strong> 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例1:</span><br><span class="line">输入: s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br><span class="line"></span><br><span class="line">示例2:</span><br><span class="line">输入: s1&#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidboaoo&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10,000] 之间</li></ol><p>题目地址：<a href="https://leetcode-cn.com/explore/interview/card/bytedance/242/string/1016/" target="_blank" rel="noopener">这里~</a></p><a id="more"></a><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于字符串的长度最长为 10000， 故列出所有排列关系时间复杂度过高，我们需要转换思路，寻找其他办法。</p><p>由于排列的规则是任意字符串的随意排列，例如<strong><em>abb</em></strong>可以是<strong><em>abb、bab、bba</em></strong>， 那么我们可以观察发现只要</p><p><strong>*字符串长度相等且每个字符的个数一致，则该字符串为原串的排列之一。</strong> 通过这个原则我们只需要计算 <strong><em>s1</em></strong> 字符串的长度及每个字母的个数即可。然后在 <strong><em>s2</em></strong> 中建立滑动窗口扫描符合的字符串。则该题的问题则变为实现一个滑动窗口。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 字符串的排列 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">        <span class="comment">// 建立字典并初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] dict1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dict2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录s1中每个字符的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> s : s1.toCharArray()) &#123;</span><br><span class="line">            dict1[s - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滑动窗口遍历s2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">            <span class="comment">// 由于是从0开始，故相等时窗口已经超出len1大小</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= len1)</span><br><span class="line">                <span class="comment">// 将窗口外的记录去除</span></span><br><span class="line">                dict2[s2.charAt(i - len1) - <span class="string">'a'</span>]--;</span><br><span class="line">            <span class="comment">// 将新加入的纳入字典</span></span><br><span class="line">            dict2[s2.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="comment">// 判断两数组是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(dict1, dict2))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="官方最佳解法"><a href="#官方最佳解法" class="headerlink" title="官方最佳解法"></a>官方最佳解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] hash = &#123;<span class="number">77886</span>, <span class="number">51044</span>, <span class="number">75120</span>, <span class="number">93338</span>, <span class="number">63245</span>, <span class="number">84866</span>, <span class="number">70301</span>, <span class="number">19244</span>,</span><br><span class="line">                <span class="number">37029</span>, <span class="number">95036</span>, <span class="number">62918</span>, <span class="number">79389</span>, <span class="number">52211</span>, <span class="number">69968</span>, <span class="number">14003</span>, <span class="number">56270</span>, <span class="number">20747</span>, <span class="number">64639</span>, <span class="number">26711</span>, <span class="number">95751</span>, <span class="number">32553</span>,</span><br><span class="line">                <span class="number">14959</span>, <span class="number">81792</span>, <span class="number">41986</span>, <span class="number">75273</span>, <span class="number">99929</span>,&#125;;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1.equals(s2)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] map1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] map2 = s2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cs1Hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cs2Hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); ++i) &#123;</span><br><span class="line">            cs1Hash += hash[map1[i] - <span class="string">'a'</span>];</span><br><span class="line">            cs2Hash += hash[map2[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cs1Hash == cs2Hash) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = s2.length() - s1.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            cs2Hash += hash[map2[i + s1.length()] - <span class="string">'a'</span>] - hash[map2[i] - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span> (cs1Hash == cs2Hash) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的hash值应该是 <strong>任意个相加后不能相等与其中的一个值的（类似于加法的质数）</strong>，然后就可以以这个值代替字典的遍历比较，从而使用int进行对比，进一步节省了时间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 每日训练 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日leetcode-无重复字符的最长子串</title>
      <link href="/2018/12/09/%E6%AF%8F%E6%97%A5leetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2018/12/09/%E6%AF%8F%E6%97%A5leetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>题目链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">点击这里~</a></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用Hash表建立一个简单的滑动窗口，并尽量扩大滑动窗口的长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h5 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h5><ul><li>res 最大长度</li><li>left 上一次重复位置</li><li>data 哈希表 记录每个字符出现的位置</li><li>t 记录字符对应的ascii值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最大值 上一次起点</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录上一次出现的位置, 如没出现则为0</span></span><br><span class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 该字符对应的ascii码</span></span><br><span class="line">            <span class="keyword">int</span> t = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (data[t] == <span class="number">0</span> || data[t] &lt; left) &#123;</span><br><span class="line">                <span class="comment">// 由于记录从1开始所以当前位置到起点大小为i-left+1 例如123456 总共有6-1+1个字符</span></span><br><span class="line">                res = Math.max(res, i - left + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 出现重复，重新记录left值</span></span><br><span class="line">                left = data[t];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从1开始</span></span><br><span class="line">            data[t] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>难点：</strong></p><ol><li>Hash表用于记录每个字符出现的位置，如还没出现设为0。</li><li>Hash表需建立256位的空间，因为Ascii表功能表示256个字节，所以建立这么大才可以记录所有的字符。</li><li>需设定res, left两个变量来进行标记，res负责记录最大的值，left记录上一次出现重复的位置。</li><li>res增加的条件不单只是data[t] == 0 (尚未出现)， 还存在上次出现但是在left前面，所以并不算的情况，因此需加上判断<strong><em>data[t]&lt;left</em></strong>，例如<em>abbca*，假设不加判断那么当 *i == 4</em> 时， 由于a在data中已经存在值，故不会进入 <em>if</em> 中， 而是会进入<em>else</em>。</li></ol><h2 id="官方最佳答案"><a href="#官方最佳答案" class="headerlink" title="官方最佳答案"></a>官方最佳答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; <span class="comment">// current index of character</span></span><br><span class="line">        <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            i = Math.max(index[s.charAt(j)], i);</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            index[s.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将if-else更改为<strong><em>i = Math.max(index[s.charAt(j)], i);</em></strong>既达到效果也更加美观。</p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>为什么要开始进行这个训练呢，其实是有挺多目的：</p><ol><li>想通过这个方法保持每天写一点东西。</li><li>并且也掌握多一点面试算法相关的，好进行春招的准备。</li><li>多进行一些算法相关的学习也能保持住脑子的活跃，不用每天为了业务奔波。</li><li>等等。。。</li></ol><p>于是就这么愉快的决定了，以后如果没什么事的话尽量每天做一道leetcode的题。</p><p>备注：关于算法的题目以后应该都会用Java来进行。由于时间紧迫，所以题目大多会采取直接看答案思路并自己编码。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 每日训练 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习入门(1)-pandas库的使用</title>
      <link href="/2018/12/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8(1)-pandas%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/12/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8(1)-pandas%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="http://pandas.pydata.org/" target="_blank" rel="noopener"><em>pandas</em></a> 是一种列存数据分析 API。它是用于处理和分析输入数据的强大工具，很多机器学习框架都支持将 <em>pandas</em> 数据结构作为输入。</p><p>官方文档：<a href="http://pandas.pydata.org/pandas-docs/stable/index.html" target="_blank" rel="noopener">点这里~</a></p><p><strong><em>该系列机器学习是实践 <a href="https://developers.google.cn/machine-learning/crash-course/" target="_blank" rel="noopener">谷歌机器学习教程</a>做的笔记。</em></strong></p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用pip即可进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas</span><br></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(pandas.__version__)</span><br></pre></td></tr></table></figure><p>输出：<strong>0.23.4</strong></p><h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><ul><li><strong>DataFrame</strong>: 关系型数据表格，包含多个行和已命名的列。（及类似关系型数据库或excel表）</li><li><strong>Series</strong>: 单一列。<em>DataFrame</em> 中包含一个或多个 <em>Series<em>，每个</em>Series</em> 均有一个名称。</li></ul><h4 id="创建Series、DataFrame对象"><a href="#创建Series、DataFrame对象" class="headerlink" title="创建Series、DataFrame对象"></a>创建Series、DataFrame对象</h4><ul><li>以list、dict 的方式创建：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">city_names = pd.Series([<span class="string">'San Francisco'</span>, <span class="string">'San Jose'</span>, <span class="string">'Sacramento'</span>])</span><br><span class="line">population = pd.Series([<span class="number">852469</span>, <span class="number">1015785</span>, <span class="number">485199</span>])</span><br><span class="line"><span class="comment"># 将两个series对象整合到dataframe中，如两个series长度不一致则会以NA/NaN填充</span></span><br><span class="line">pd.DataFrame(&#123;<span class="string">'city_name'</span>: city_names, <span class="string">'population'</span>: population&#125;)</span><br></pre></td></tr></table></figure><ul><li>直接读取文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式2 直接读取文件</span></span><br><span class="line">california_housing_dataframe = pd.read_csv(<span class="string">"https://download.mlcc.google.cn/mledu-datasets/california_housing_train.csv"</span>, sep=<span class="string">","</span>)</span><br></pre></td></tr></table></figure><h4 id="访问数据"><a href="#访问数据" class="headerlink" title="访问数据"></a>访问数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(pd.__version__)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建series、dataframe对象</span></span><br><span class="line">    <span class="comment"># 方式1 以list，dict的方式构建</span></span><br><span class="line">    city_names = pd.Series([<span class="string">'San Francisco'</span>, <span class="string">'San Jose'</span>, <span class="string">'Sacramento'</span>])</span><br><span class="line">    population = pd.Series([<span class="number">852469</span>, <span class="number">1015785</span>, <span class="number">485199</span>])</span><br><span class="line">    <span class="comment"># 将两个series对象整合到dataframe中，如两个series长度不一致则会以NA/NaN填充</span></span><br><span class="line">    california_housing_dataframe = pd.DataFrame(&#123;<span class="string">'city_name'</span>: city_names, <span class="string">'population'</span>: population&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式2 直接读取文件</span></span><br><span class="line">    <span class="comment"># california_housing_dataframe = pd.read_csv("https://download.mlcc.google.cn/mledu-datasets/california_housing_train.csv", sep=",")</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========显示统计数据========"</span>)</span><br><span class="line">    print(california_housing_dataframe.describe())</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========显示前几个记录========"</span>)</span><br><span class="line">    print(california_housing_dataframe.head())</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========显示中值分布========"</span>)</span><br><span class="line">    print(california_housing_dataframe.hist(<span class="string">'population'</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0.23.4</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;显示统计数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">         population</span><br><span class="line">count  3.000000e+00</span><br><span class="line">mean   7.844843e+05</span><br><span class="line">std    2.717477e+05</span><br><span class="line">min    4.851990e+05</span><br><span class="line">25%    6.688340e+05</span><br><span class="line">50%    8.524690e+05</span><br><span class="line">75%    9.341270e+05</span><br><span class="line">max    1.015785e+06</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;显示前几个记录&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">       city_name  population</span><br><span class="line">0  San Francisco      852469</span><br><span class="line">1       San Jose     1015785</span><br><span class="line">2     Sacramento      485199</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;显示中值分布&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000594CBA8&gt;]]</span><br></pre></td></tr></table></figure><h2 id="访问数据-1"><a href="#访问数据-1" class="headerlink" title="访问数据"></a>访问数据</h2><p>直接以 <strong><em>dict/list</em></strong> 的方式 访问数据即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">access_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    访问数据</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    city_names = [<span class="string">'San Francisco'</span>, <span class="string">'San Jose'</span>, <span class="string">'Sacramento'</span>]</span><br><span class="line">    population = [<span class="number">852469</span>, <span class="number">1015785</span>, <span class="number">485199</span>]</span><br><span class="line">    cities = pd.DataFrame(&#123;<span class="string">'City name'</span>: city_names, <span class="string">'Population'</span>: population&#125;)</span><br><span class="line">    <span class="comment"># 直接以list/dict的操作即可</span></span><br><span class="line">    print(type(cities[<span class="string">'City name'</span>]))</span><br><span class="line">    print(cities[<span class="string">'City name'</span>])</span><br><span class="line"></span><br><span class="line">    print(type(cities[<span class="string">"City name"</span>][<span class="number">1</span>]))</span><br><span class="line">    print(cities[<span class="string">"City name"</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#39;pandas.core.series.Series&#39;&gt;</span><br><span class="line">0    San Francisco</span><br><span class="line">1         San Jose</span><br><span class="line">2       Sacramento</span><br><span class="line">Name: City name, dtype: object</span><br><span class="line">&lt;class &#39;str&#39;&gt;</span><br><span class="line">San Jose</span><br></pre></td></tr></table></figure><h2 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a>操作数据</h2><p>可直接对 <strong><em>Series/DataFrame</em></strong> 运算。或应用<strong><em>Series.apply()</em></strong>方法，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operate_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    操作数据</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    city_names = pd.Series([<span class="string">'San Francisco'</span>, <span class="string">'San Jose'</span>, <span class="string">'Sacramento'</span>])</span><br><span class="line">    population = pd.Series([<span class="number">852469</span>, <span class="number">1015785</span>, <span class="number">485199</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可直接向Series应用python基本运算命令</span></span><br><span class="line">    print(population / <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可应用于Numpy做参数运算</span></span><br><span class="line">    print(np.log(population))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Series.apply函数 参数 接受lambda函数</span></span><br><span class="line">    <span class="comment"># 例如 创建一个population超过100000的新Series</span></span><br><span class="line">    new_series = population.apply(<span class="keyword">lambda</span> val: val &gt; <span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改DataFrames对象</span></span><br><span class="line">    cities = dict()</span><br><span class="line">    cities[<span class="string">'Population'</span>] = population</span><br><span class="line">    cities[<span class="string">'Area square miles'</span>] = pd.Series([<span class="number">46.87</span>, <span class="number">176.53</span>, <span class="number">97.92</span>])</span><br><span class="line">    cities[<span class="string">'Population density'</span>] = cities[<span class="string">'Population'</span>] / cities[<span class="string">'Area square miles'</span>]</span><br><span class="line">    print(cities)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0     852.469</span><br><span class="line">1    1015.785</span><br><span class="line">2     485.199</span><br><span class="line">dtype: float64</span><br><span class="line">0    13.655892</span><br><span class="line">1    13.831172</span><br><span class="line">2    13.092314</span><br><span class="line">dtype: float64</span><br><span class="line">&#123;&#39;Population&#39;: 0     852469</span><br><span class="line">1    1015785</span><br><span class="line">2     485199</span><br><span class="line">dtype: int64, &#39;Area square miles&#39;: 0     46.87</span><br><span class="line">1    176.53</span><br><span class="line">2     97.92</span><br><span class="line">dtype: float64, &#39;Population density&#39;: 0    18187.945381</span><br><span class="line">1     5754.177760</span><br><span class="line">2     4955.055147</span><br><span class="line">dtype: float64&#125;</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><strong><em>Series</em></strong> 和 <strong><em>DataFrame</em></strong> 对象也定义了 <strong><em>index</em></strong> 属性，该属性会向每个 <strong><em>Series</em></strong> 项或 <strong><em>DataFrame</em></strong> 行赋一个标识符值。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    数据索引demo</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 模拟创建cities对象</span></span><br><span class="line">    temp = dict()</span><br><span class="line">    temp[<span class="string">'Population'</span>] = pd.Series([<span class="number">852469</span>, <span class="number">1015785</span>, <span class="number">485199</span>])</span><br><span class="line">    temp[<span class="string">'Area square miles'</span>] = pd.Series([<span class="number">46.87</span>, <span class="number">176.53</span>, <span class="number">97.92</span>])</span><br><span class="line">    temp[<span class="string">'Name'</span>] = pd.Series([<span class="string">'San Francisco'</span>, <span class="string">'San Jose'</span>, <span class="string">'Sacramento'</span>])</span><br><span class="line">    cities = pd.DataFrame(temp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认情况下，在构造时，pandas 会赋可反映源数据顺序的索引值。索引值在创建后是稳定的</span></span><br><span class="line">    <span class="comment"># 也就是说，它们不会因为数据重新排序而发生改变。</span></span><br><span class="line">    print(cities[<span class="string">'Name'</span>].index)</span><br><span class="line">    print(cities.index)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可使用reindex方法手动重新排序</span></span><br><span class="line">    print(cities.reindex([<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 利用numpy random.permutation方法重新随机排序</span></span><br><span class="line">    print(cities.reindex(np.random.permutation(cities.index)))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RangeIndex(start&#x3D;0, stop&#x3D;3, step&#x3D;1)</span><br><span class="line">RangeIndex(start&#x3D;0, stop&#x3D;3, step&#x3D;1)</span><br><span class="line">   Population  Area square miles           Name</span><br><span class="line">2      485199              97.92     Sacramento</span><br><span class="line">0      852469              46.87  San Francisco</span><br><span class="line">1     1015785             176.53       San Jose</span><br><span class="line">   Population  Area square miles           Name</span><br><span class="line">2      485199              97.92     Sacramento</span><br><span class="line">1     1015785             176.53       San Jose</span><br><span class="line">0      852469              46.87  San Francisco</span><br></pre></td></tr></table></figure><h2 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h2><p>通过添加一个新的布尔值列（当且仅当以下<em>两项</em>均为 True 时为 True）修改 <code>cities</code> 表格：</p><ul><li>城市以圣人命名。</li><li>城市面积大于 50 平方英里。</li></ul><p><strong>注意：</strong>布尔值 <code>Series</code> 是使用“按位”而非传统布尔值“运算符”组合的。例如，执行<em>逻辑与</em>时，应使用 <code>&amp;</code>，而不是 <code>and</code>。</p><p><strong>提示：</strong>“San” 在西班牙语中意为 “saint”。</p><p>答案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exe_1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    练习 1</span></span><br><span class="line"><span class="string">    通过添加一个新的布尔值列（当且仅当以下两项均为 True 时为 True）修改 cities 表格：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    城市以San命名。</span></span><br><span class="line"><span class="string">    城市面积大于 50 平方英里。</span></span><br><span class="line"><span class="string">    注意：布尔值 Series 是使用“按位”而非传统布尔值“运算符”组合的。例如，执行逻辑与时，应使用 &amp;，而不是 and。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    提示："San" 在西班牙语中意为 "saint"。</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 模拟创建cities对象</span></span><br><span class="line">    temp = dict()</span><br><span class="line">    temp[<span class="string">'Population'</span>] = pd.Series([<span class="number">852469</span>, <span class="number">1015785</span>, <span class="number">485199</span>])</span><br><span class="line">    temp[<span class="string">'Area square miles'</span>] = pd.Series([<span class="number">46.87</span>, <span class="number">176.53</span>, <span class="number">97.92</span>])</span><br><span class="line">    temp[<span class="string">'Name'</span>] = pd.Series([<span class="string">'San Francisco'</span>, <span class="string">'San Jose'</span>, <span class="string">'Sacramento'</span>])</span><br><span class="line">    cities = pd.DataFrame(temp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用apply函数创建该列</span></span><br><span class="line">    cities[<span class="string">"wide and with san"</span>] = cities[<span class="string">'Name'</span>].apply(<span class="keyword">lambda</span> name: name.startswith(<span class="string">'San'</span>)) &amp; (cities[<span class="string">'Area square miles'</span>] &gt; <span class="number">50</span>)</span><br><span class="line">    print(cities)</span><br></pre></td></tr></table></figure><p><strong>注意点</strong>： (cities[‘Area square miles’] &gt; 50) 必须要用括号包起来，不然判别就变成 <em>cities[‘Name’].apply(lambda name: name.startswith(‘San’)) &amp; cities[‘Area square miles’] &gt; 50</em> 导致错误。</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   Population        ...          wide and with san</span><br><span class="line">0      852469        ...                      False</span><br><span class="line">1     1015785        ...                       True</span><br><span class="line">2      485199        ...                      False</span><br><span class="line"></span><br><span class="line">[3 rows x 4 columns]</span><br></pre></td></tr></table></figure><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习 2"></a>练习 2</h2><p><code>reindex</code> 方法允许使用未包含在原始 <code>DataFrame</code> 索引值中的索引值。请试一下，看看如果使用此类值会发生什么！您认为允许此类值的原因是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exe_2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    练习 2</span></span><br><span class="line"><span class="string">    reindex 方法允许使用未包含在原始 DataFrame 索引值中的索引值。</span></span><br><span class="line"><span class="string">    请试一下，看看如果使用此类值会发生什么！您认为允许此类值的原因是什么？</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 模拟创建cities对象</span></span><br><span class="line">    temp = dict()</span><br><span class="line">    temp[<span class="string">'Population'</span>] = pd.Series([<span class="number">852469</span>, <span class="number">1015785</span>, <span class="number">485199</span>])</span><br><span class="line">    temp[<span class="string">'Area square miles'</span>] = pd.Series([<span class="number">46.87</span>, <span class="number">176.53</span>, <span class="number">97.92</span>])</span><br><span class="line">    temp[<span class="string">'Name'</span>] = pd.Series([<span class="string">'San Francisco'</span>, <span class="string">'San Jose'</span>, <span class="string">'Sacramento'</span>])</span><br><span class="line">    cities = pd.DataFrame(temp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 目前只有三组数据索引: 0 1 2，假设操作索引 2 以上的数据</span></span><br><span class="line">    print(cities.reindex([<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   Population  Area square miles           Name</span><br><span class="line">4         NaN                NaN            NaN</span><br><span class="line">0    852469.0              46.87  San Francisco</span><br><span class="line">1   1015785.0             176.53       San Jose</span><br><span class="line">3         NaN                NaN            NaN</span><br></pre></td></tr></table></figure><p>解释：</p><p>如果您的 <code>reindex</code> 输入数组包含原始 <code>DataFrame</code> 索引值中没有的值，<code>reindex</code> 会为此类“丢失的”索引添加新行，并在所有对应列中填充 <code>NaN</code> 值。</p><p>这种行为是可取的，因为索引通常是从实际数据中提取的字符串（请参阅 <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.reindex.html" target="_blank" rel="noopener"><em>pandas</em> reindex 文档</a>，查看索引值是浏览器名称的示例）。</p><p>在这种情况下，如果允许出现“丢失的”索引，您将可以轻松使用外部列表重建索引，因为您不必担心会将输入清理掉。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> pandas </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2018/12/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/12/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么要重新搭建博客"><a href="#为什么要重新搭建博客" class="headerlink" title="为什么要重新搭建博客"></a>为什么要重新搭建博客</h4><p>其实在之前就已经有自己用java写过一个的<a href="https://github.com/fengyuwusong/blog" target="_blank" rel="noopener">博客系统</a>，并且也有在csdn中写博客。<br>但是发现还是这个比较方便美观，所以还是决定迁移到这里来啦。</p><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p>每周至少写一篇博客吧~</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
