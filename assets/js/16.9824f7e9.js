(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{355:function(l,i,n){"use strict";n.r(i);var e=n(0),t=Object(e.a)({},(function(){var l=this,i=l._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[i("h1",{attrs:{id:"builtin"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#builtin"}},[l._v("#")]),l._v(" builtin")]),l._v(" "),i("div",{staticClass:"language-shell line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-shell"}},[i("code",[l._v("Package "),i("span",{pre:!0,attrs:{class:"token builtin class-name"}},[l._v("builtin")]),l._v(" provides documentation "),i("span",{pre:!0,attrs:{class:"token keyword"}},[l._v("for")]),l._v(" Go"),i("span",{pre:!0,attrs:{class:"token string"}},[l._v("'s predeclared identifiers.\nThe items documented here are not actually in package builtin\nbut their descriptions here allow godoc to present documentation\nfor the language'")]),l._v("s special identifiers.\n\n\n"),i("span",{pre:!0,attrs:{class:"token builtin class-name"}},[l._v("builtin")]),l._v(" 包为Go的预声明标识符提供了文档。\n此处列出的条目其实并不在builtin 包中，对它们的描述只是为了让 godoc 给该语言的特殊标识符提供文档。\n")])]),l._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[l._v("1")]),i("br"),i("span",{staticClass:"line-number"},[l._v("2")]),i("br"),i("span",{staticClass:"line-number"},[l._v("3")]),i("br"),i("span",{staticClass:"line-number"},[l._v("4")]),i("br"),i("span",{staticClass:"line-number"},[l._v("5")]),i("br"),i("span",{staticClass:"line-number"},[l._v("6")]),i("br"),i("span",{staticClass:"line-number"},[l._v("7")]),i("br"),i("span",{staticClass:"line-number"},[l._v("8")]),i("br")])]),i("h2",{attrs:{id:"基本类型"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#基本类型"}},[l._v("#")]),l._v(" 基本类型")]),l._v(" "),i("ul",[i("li",[l._v("bool")]),l._v(" "),i("li",[l._v("uint8")]),l._v(" "),i("li",[l._v("uint16")]),l._v(" "),i("li",[l._v("uint32")]),l._v(" "),i("li",[l._v("uint64")]),l._v(" "),i("li",[l._v("int8")]),l._v(" "),i("li",[l._v("int16")]),l._v(" "),i("li",[l._v("int32")]),l._v(" "),i("li",[l._v("int64")]),l._v(" "),i("li",[l._v("float32")]),l._v(" "),i("li",[l._v("float64")]),l._v(" "),i("li",[l._v("complex64")]),l._v(" "),i("li",[l._v("complex128")]),l._v(" "),i("li",[l._v("string\n"),i("ul",[i("li",[l._v("8位bit序列字符构成的字符串集合，约定但不必须是utf-8编码的文本。字符串可以为空但不能是nil，其值不可变。")])])]),l._v(" "),i("li",[l._v("int")]),l._v(" "),i("li",[l._v("uint")]),l._v(" "),i("li",[l._v("uintptr")])]),l._v(" "),i("h2",{attrs:{id:"内置常量-类型"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#内置常量-类型"}},[l._v("#")]),l._v(" 内置常量&类型")]),l._v(" "),i("ul",[i("li",[l._v("byte\n"),i("ul",[i("li",[l._v("uint8的别称")])])]),l._v(" "),i("li",[l._v("rune\n"),i("ul",[i("li",[l._v("int32 的别称")])])]),l._v(" "),i("li",[l._v("iota\n"),i("ul",[i("li",[l._v("iota是一个预定义的标识符，代表顺序按行增加的无符号整数，每个const声明单元（被括号括起来）相互独立，分别从0开始。")])])]),l._v(" "),i("li",[l._v("nil\n"),i("ul",[i("li",[l._v("nil 是一个预声明的零值用于 pointer、channel、func、interface、map、slice")])])]),l._v(" "),i("li",[l._v("Type\n"),i("ul",[i("li",[l._v("int 的别称，用于定义表示 go 的不同类型")])])]),l._v(" "),i("li",[l._v("Type1\n"),i("ul",[i("li",[l._v("同 Type，没被使用，预留字段")])])]),l._v(" "),i("li",[l._v("IntegerType\n"),i("ul",[i("li",[l._v("用于表示任何 integer 类型")])])]),l._v(" "),i("li",[l._v("FloatType\n"),i("ul",[i("li",[l._v("用于表示任何 float 类型")])])]),l._v(" "),i("li",[l._v("ComplexType\n"),i("ul",[i("li",[l._v("用于表示任何 complex 类型")])])])]),l._v(" "),i("h2",{attrs:{id:"内置方法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#内置方法"}},[l._v("#")]),l._v(" 内置方法")]),l._v(" "),i("ul",[i("li",[l._v("func append(slice []Type, elems ...Type) []Type\n"),i("ul",[i("li",[l._v("用于往 slice 后面增加元素，并返回新增元素有的 slice，如果 slice 没有足够容量，则会分配新的数组用于添加。方法返回更改后的数组，因此有必要存储添加后的结果，经常用更改后的值来替换原来的变量。")])])]),l._v(" "),i("li",[l._v("func copy(dst, src []Type) int\n"),i("ul",[i("li",[l._v("用于从 src slice 复制元素到 dst slice。（作为一个特殊的场景，也可以用于从一个 string 拷贝 bytes 到另一个 bytes slice）src 和 dest slice 可能不相等，方法返回多少个元素被拷贝，值位于区间[len(src), len(dst)]")])])]),l._v(" "),i("li",[l._v("func delete(m map[Type]Type1, key Type)\n"),i("ul",[i("li",[l._v("用于删除map[key]中指定的元素, 无任何返回")])])]),l._v(" "),i("li",[l._v("func len(v Type) int\n"),i("ul",[i("li",[l._v("用于返回以下类型的长度\n"),i("ul",[i("li",[l._v("Array：v 的元素数量")]),l._v(" "),i("li",[l._v("Pointer to array：*v 数组的长度，如果 v == nil，那么返回 0")]),l._v(" "),i("li",[l._v("Slice/map：v 的元素数量，如果 v == nil，那么返回 0")]),l._v(" "),i("li",[l._v("Channel：channel buffer 的 queued 中未读的元素数量，如果 v == nil，那么返回 0")])])]),l._v(" "),i("li",[l._v("对于同样的参数，例如 string 或 array 表达式，返回会是一个常量")])])]),l._v(" "),i("li",[l._v("func cap(v Type) int\n"),i("ul",[i("li",[l._v("返回 v 的容量，支持以下类型\n"),i("ul",[i("li",[l._v("Array：v 的元素个数")]),l._v(" "),i("li",[l._v("Pointer to array：*v 的元素个数")]),l._v(" "),i("li",[l._v("Slice：slice 能被扩容的最大值，如果 v == nil，那么返回 0")]),l._v(" "),i("li",[l._v("Channel：channel buffer 的容量，如果 v == nil，那么返回 0")])])]),l._v(" "),i("li",[l._v("对于同样的参数，例如 string 或 array 表达式，返回会是一个常量")])])]),l._v(" "),i("li",[l._v("func make(t Type, size ...IntegerType) Type")])])])}),[],!1,null,null,null);i.default=t.exports}}]);