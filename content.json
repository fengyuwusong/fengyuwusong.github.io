{"meta":{"title":"风雨雾凇","subtitle":null,"description":null,"author":"风雨雾凇","url":"https://fengyuwsuong.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2022-08-26T08:54:09.904Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"404.html","permalink":"https://fengyuwsuong.cn/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2022-08-26T08:54:09.908Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"about/index.html","permalink":"https://fengyuwsuong.cn/about/index.html","excerpt":"","text":"技术渣渣, 后续追加~"},{"title":"所有分类","date":"2022-08-26T08:54:09.908Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"categories/index.html","permalink":"https://fengyuwsuong.cn/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-08-26T08:54:09.908Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"friends/index.html","permalink":"https://fengyuwsuong.cn/friends/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-26T08:54:09.908Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"mylist/index.html","permalink":"https://fengyuwsuong.cn/mylist/index.html","excerpt":"","text":"结果就是筛选出所有文章中type: mylist的文章。"},{"title":"所有标签","date":"2022-08-26T08:54:09.908Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"tags/index.html","permalink":"https://fengyuwsuong.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"从事务到分布式事务","slug":"从事务到分布式事务","date":"2022-08-26T03:05:39.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2022/08/26/从事务到分布式事务/","link":"","permalink":"https://fengyuwsuong.cn/2022/08/26/%E4%BB%8E%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"前置知识CAPCAP理论是分布式系统、特别是分布式存储领域中被讨论的最多的理论。其中C代表一致性 (Consistency)，A代表可用性 (Availability)，P代表分区容错性 (Partition tolerance)。CAP理论告诉我们C、A、P三者不能同时满足，最多只能满足其中两个。 Consistency（一致性）一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。所有节点访问同一份最新的数据。 Availability（可用性）对数据更新具备高可用性，请求能够及时处理，不会一直等待，即使出现节点失效。 Partition tolerance（分区性容错性）能容忍网络分区，在网络断开的情况下，被分隔的节点仍能正常对外提供服务。 思考题：对CAP的理解（为什么只能满足两个？）假设放弃P，考虑CA。 现有系统符合的种类CA: 不需要分区的数据库（单机mysql、mongo等）CP: 需要分区和强一致性而放弃了可用性的系统（ACID强事务型数据库）AP: 需要分区和高可用而放弃了可用性的系统（非事务型数据库、大多数互联网应用） BASE Basically Available（基本可用）分布式系统在出现不可预知故障的时候，允许损失部分可用性 Soft state（软状态）软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时 Eventually consistent（最终一致性）最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性 BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），更具体地说，是对 CAP 中 AP 方案的一个补充。其基本思路就是：通过业务，牺牲强一致性而获得可用性，并允许数据在一段时间内是不一致的，但是最终达到一致性状态。 数据库事务定义把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。 ACID Atomicity（原子性）：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 Consistency（一致性）：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。 Isolation（隔离性）：一个事务所做的修改在最终提交以前，对其它事务是不可见的。 Durability（持久性）：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。 思考题：如何实现原子性和持久性的回滚和丢失恢复？Undo Log、Redo Log 并发一致性问题 丢失修改 读脏数据 不可重复读 幻影读 事务隔离级别 不同隔离级别实现原理未提交读：一直读最新数据提交读、可重复读：MVCC可串行化隔离级别需要对所有读取的行都加锁（Next-Key Locks），单纯使用 MVCC 无法实现。 MVCCTODO Next-Key LocksTODO 封锁 读写锁、意向锁： TODO 封锁协议：TODO 本地事务本地事务是指仅操作单一事务资源的、不需要全局事务管理器进行协调的事务。 实现原理数据库本身支持事务。 应用场景单个服务使用单个数据源的场景。例如最简单的单机单数据源多表转账服务。 全局事务定义与本地事务相对的是全局事务（Global Transaction）全局事务被限定为一种适用于单个服务使用多个数据源场景的事务解决方案。 实现原理 思考题：以下代码有什么问题？ 1234567891011121314151617public void buyBook(PaymentBill bill) &#123; userTransaction.begin(); warehouseTransaction.begin(); businessTransaction.begin(); try &#123; userAccountService.pay(bill.getMoney()); warehouseService.deliver(bill.getItems()); businessAccountService.receipt(bill.getMoney()); userTransaction.commit(); warehouseTransaction.commit(); businessTransaction.commit(); &#125; catch(Exception e) &#123; userTransaction.rollback(); warehouseTransaction.rollback(); businessTransaction.rollback(); &#125;&#125; XAXA是由X/Open组织提出的分布式事务的规范，XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如mysql在XA中扮演的是RM角色。 2PC 准备阶段：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。这里所说的准备操作跟人类语言中通常理解的准备并不相同，对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。提交阶段：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载的操作。 2PC存在的问题 单点问题 性能问题 一致性风险 3PC增加CanCommit询问阶段，增加成功概率，一定程度解决单点和性能问题。 共享事务定义共享事务（Share Transaction）是指多个服务共用同一个数据源。 实现原理 多个服务共享数据库链接（新增应用用于串行化执行多个微服务对于数据库的操作） 使用消息队列 分布式锁 应用场景目前软总线服务上多个微服务同时读写设备表。 分布式事务 思考题：以下流程存在什么问题？ 1234567场景事例Fenix&#39;s Bookstore 是一个在线书店。每当一本书被成功售出时，需要确保以下三件事情被正确地处理：用户的账号扣减相应的商品款项。商品仓库中扣减库存，将商品标识为待配送状态。商家的账号增加相应的商品款项。 定义多个服务同时访问多个数据源的事务处理机制，目前仅支持柔性事务。 刚性事务：达到实现强一致性的事务（目前无法实现，具体参考：https://www.dtm.pub/practice/theory.html#%E6%97%A0%E6%B3%95%E5%BC%BA%E4%B8%80%E8%87%B4） 柔性事务：达到实现最终一致性的事务 解决方案 最大努力交付/通知（接收方保证一致性） 本地/事务消息表消息表（消息队列保证） AT XA 二阶段消息 Workflow SAGA TCC 本地消息表 SAGA TCC XA 二阶消息 如何选择合适的模式 二阶段消息模式: 适合不需要回滚的场景 saga模式: 适合需要回滚的场景 tcc事务模式: 适合一致性要求较高的场景 xa事务模式: 适合并发要求不高，没有数据库行锁争抢的场景 应用场景https://dtm.pub/app/intro.html NPC问题定义 网络延迟 进程暂停 时钟漂移 异常分类 空补偿 悬挂 幂等 解决方案https://www.dtm.pub/practice/barrier.html 最佳实践https://github.com/nivin-studio/go-zero-mall 参考链接凤凰架构：http://icyfenix.cn/architect-perspective/general-architecture/transaction/数据库系统原理：https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E4%B8%80%E4%BA%8B%E5%8A%A1DTM官网：https://www.dtm.pub/","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"事务","slug":"学习笔记/事务","permalink":"https://fengyuwsuong.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1/"},{"name":"分布式","slug":"学习笔记/事务/分布式","permalink":"https://fengyuwsuong.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"分布式事务","slug":"分布式事务","permalink":"https://fengyuwsuong.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"}]},{"title":"Golang垃圾回收","slug":"Golang垃圾回收","date":"2022-05-18T11:09:15.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2022/05/18/Golang垃圾回收/","link":"","permalink":"https://fengyuwsuong.cn/2022/05/18/Golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","excerpt":"","text":"垃圾回收是什么？垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。 Go V1.3之前的标记-清除(mark and sweep)算法 暂停程序，分析当前程序可达的对象 对于所有可达的对象做上标记 清除未标记的对象 停止暂停，程序业务逻辑继续运行，然后重复该过程。 缺点 stw：gc时程序需要暂停 标记需要扫描整个heap 清楚数据会产生heap碎片 gov1.3版本将步骤4提前到步骤3，即sweep清楚时，并不需要暂停整个程序 Go V1.5的三色并发标记法 每次新创建的对象，默认的颜色都是标记为“白色” 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合【遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层】 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合【遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层】 重复第三步, 直到灰色中无任何对象 回收所有白色对象 没STW的三色标记法当三色标记法同时出现以下两种情况时，会出现对象丢失： 一个白色对象被黑色对象引用(白色被挂在黑色下) 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色) 屏障机制为了避免不使用STW，同时不存在对象丢失的情况，于是设计了屏障机制。 通过上述描述发现，当GC回收期满足以下两种情形之一时，即可不丢失对象。 “强-弱” 三色不变式 强三色不变式：不存在黑色对象引用到白色对象的指针。 弱三色不变式：所有被黑色对象引用的白色对象都处于灰色保护状态。【灰色对象直接引用或它的链路上游存在灰色对象】 为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们分别是：“插入屏障”, “删除屏障”。 插入屏障 具体操作：当黑色对象引用白色对象时，白色对象被标记为灰色。满足：强三色不变式 伪代码： 1234567添加下游对象(当前下游对象slot, 新下游对象ptr) &#123; //1 标记灰色(新下游对象ptr) //2 当前下游对象slot = 新下游对象ptr&#125; 场景： 黑色对象直接添加下游对象 黑色对象替换下游引用对象 适用情况：这段伪码逻辑就是写屏障, 黑色对象的内存槽有两种位置, 栈和堆.栈空间的特点是容量小, 但是要求相应速度快, 因此栈空间内并不使用，仅适用于堆 删除屏障 具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断) 伪代码： 123456789添加下游对象(当前下游对象slot， 新下游对象ptr) &#123; //1 if (当前下游对象slot是灰色 || 当前下游对象slot是白色) &#123; 标记灰色(当前下游对象slot) //slot为被删除对象， 标记为灰色 &#125; //2 当前下游对象slot = 新下游对象ptr&#125; 场景： A.添加下游对象(B, nil) //A对象，删除B对象的引用。 B被A删除，被标记为灰(如果B之前为白) A.添加下游对象(B, C) //A对象，更换下游B变成C。 B被A删除，被标记为灰(如果B之前为白) 适用情况：一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。 插入写屏障和删除写屏障的短板 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活； 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。 Go V1.8 混合写屏障Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。 混合写屏障规则 具体操作 1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)2、GC期间，任何在栈上创建的新对象，均为黑色。3、被删除的对象标记为灰色。4、被添加的对象标记为灰色。 满足: 变形的弱三色不变式. 伪代码 12345678910添加下游对象(当前下游对象slot, 新下游对象ptr) &#123; //1 标记灰色(当前下游对象slot) //只要当前下游对象被移走，就标记灰色 //2 标记灰色(新下游对象ptr) //3 当前下游对象slot = 新下游对象ptr&#125; 注意点 屏障技术是不在栈上应用的，因为要保证栈的运行效率 场景 对象被一个堆对象删除引用，成为栈对象的下游【堆对象删除引用置为灰】 对象被一个栈对象删除引用，成为另一个栈对象的下游【栈对象删除引用，不变色】 对象被一个堆对象删除引用，成为另一个堆对象的下游【堆对象删除引用、被另一个堆对象添加引用，置为灰】 对象从一个栈对象删除引用，成为另一个堆对象的下游【栈对象本身为黑，堆对象转移引用，删除引用的堆对象置为灰】 总结Golang中的混合写屏障满足弱三色不变式，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后添加的对象始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。 总结GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。 GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通。 GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。 引用Golang三色标记混合写屏障GC模式全分析","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"go","slug":"go","permalink":"https://fengyuwsuong.cn/tags/go/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://fengyuwsuong.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]},{"title":"prometheus学习笔记","slug":"prometheus学习笔记","date":"2022-05-12T08:04:59.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2022/05/12/prometheus学习笔记/","link":"","permalink":"https://fengyuwsuong.cn/2022/05/12/prometheus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"Markmap * { margin: 0; padding: 0; } # mindmap { display: block; width: 100vw; height: 100vh; } (r => { setTimeout(r); })(() => { const { markmap, mm } = window; const toolbar = new markmap.Toolbar(); toolbar.attach(mm); const el = toolbar.render(); el.setAttribute('style', 'position:absolute;bottom:20px;right:20px'); document.body.append(el); })((getMarkmap, getOptions, root, jsonOptions) => { const markmap = getMarkmap(); window.mm = markmap.Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(markmap, jsonOptions), root); })(() => window.markmap,(markmap, jsonOptions) => markmap.deriveOptions(jsonOptions),{\"type\":\"heading\",\"depth\":1,\"payload\":{\"lines\":[1,2]},\"content\":\"prometheus相关实践\",\"children\":[{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[3,4]},\"content\":\"docker部署prometheus和grafana\",\"children\":[{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[5,6]},\"content\":\"启动node-exporter\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"docker run -d -p 9100:9100 \\\\\\n --name node-exporter \\\\\\n --restart=always \\\\\\n -v /data/apps/docker/node-exporter-data/proc:/host/proc:ro \\\\\\n -v /data/apps/docker/node-exporter-data/sys:/host/sys:ro \\\\\\n -v /data/apps/docker/node-exporter-data:/rootfs:ro \\\\\\n prom/node-exporter\\n\\n\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[17,18]},\"content\":\"编写prometheus.yml\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"global:\\n scrape_interval: 60s\\n evaluation_interval: 60s\\n\\nscrape_configs:\\n - job_name: prometheus\\n static_configs:\\n - targets:\\n - 192.168.0.104:9090\\n\\n - job_name: node-exporter\\n static_configs:\\n - targets:\\n - 192.168.0.104:9100\\n - job_name: jenkins\\n scheme: http\\n metrics_path: prometheus\\n bearer_token: bearer_token\\n static_configs:\\n - targets:\\n - 192.168.57.242:8080\\n\\n\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[43,44]},\"content\":\"启动promethus\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"docker run -d \\\\\\n --name prometheus \\\\\\n --restart=always \\\\\\n -u root \\\\\\n -p 9090:9090 \\\\\\n -v /data/apps/docker/prometheus-data/prometheus.yml:/etc/prometheus/prometheus.yml \\\\\\n -v /data/apps/docker/prometheus-data:/prometheus \\\\\\n -v /data/apps/docker/prometheus-data/conf:/etc/prometheus/conf \\\\\\n prom/prometheus --web.enable-lifecycle\\n\\n\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[57,58]},\"content\":\"启动grafana\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"docker run -d \\\\\\n -p 3000:3000 \\\\\\n --restart=always \\\\\\n --name=grafana \\\\\\n -u root \\\\\\n -v /data/apps/docker/grafana-data:/var/lib/grafana \\\\\\n grafana/grafana\\n\\n\"}]}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[71,72]},\"content\":\"Metric指标\",\"children\":[{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[73,74]},\"content\":\"数据模型\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[79,80]},\"content\":\"指标名和指标标签集合：metric_name{&lt;label1=v1&gt;,&lt;label2=v2&gt;....}，指标名：表示这个指标是监控哪一方面的状态，比如 http_request_total 表示：请求数量；指标标签，描述这个指标有哪些维度，比如 http_request_total 这个指标，有请求状态码 code = 200/400/500，请求方式：method = get/post 等，实际上指标名称实际上是以标签的形式保存，这个标签是name，即：name=。\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[80,81]},\"content\":\"时间戳：描述当前时间序列的时间，单位：毫秒。\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[81,82]},\"content\":\"样本值：当前监控指标的具体数值，比如 http_request_total 的值就是请求数是多少。\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[83,84]},\"content\":\"指标类型\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[85,86]},\"content\":\"Counter 计数器\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[86,87]},\"content\":\"Gauge 仪表盘\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[87,88]},\"content\":\"Histogram 直方图\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[88,89]},\"content\":\"Summary 摘要\"}]}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[90,91]},\"content\":\"PromQL\",\"children\":[{\"type\":\"bullet_list\",\"depth\":3,\"payload\":{\"lines\":[94,99]},\"content\":\"\",\"children\":[{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[94,95]},\"content\":\"字符串：只作为某些内置函数的参数出现\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[95,96]},\"content\":\"标量：单一的数字值，可以是函数参数，也可以是函数的返回结果\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[96,97]},\"content\":\"瞬时向量：某一时刻的时序数据\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[97,98]},\"content\":\"区间向量：某一时间区间内的时序数据集合\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[99,100]},\"content\":\"瞬时查询\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"# 直接查询\\ngo_gc_duration_seconds_count\\n# 筛选\\ngo_gc_duration_seconds_count{instance=\\\"127.0.0.1:9600\\\"}\\n# 正则\\ngo_gc_duration_seconds_count{instance=~\\\"localhost.*\\\"}\\n\\n\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[112,113]},\"content\":\"范围查询\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"# d：天，h：小时，m：分钟，ms：毫秒，s：秒，w：周，y：年\\ngo_gc_duration_seconds_count{}[5m]\\n# 偏移\\ngo_gc_duration_seconds_count{}[5m] offset 1d\\n\\n\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[123,124]},\"content\":\"内置函数\",\"children\":[{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[125,126]},\"content\":\"rate\",\"children\":[{\"type\":\"fence\",\"depth\":5,\"content\":\"rate函数=时间区间前后两个点的差 / 时间范围\\n\\n\"},{\"type\":\"fence\",\"depth\":5,\"content\":\"rate(demo_api_request_duration_seconds_count[1m])/60\\n\\n\"}]},{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[141,142]},\"content\":\"irate\",\"children\":[{\"type\":\"fence\",\"depth\":5,\"content\":\"irate = 时间区间内最后两个样本点的差 / 最后两个样本点的时间差\\n\\n\"}]},{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[147,148]},\"content\":\"聚合函数：Sum() by() without()\",\"children\":[{\"type\":\"fence\",\"depth\":5,\"content\":\"# 将多个服务多个接口的请求聚合\\nsum(rate(demo_api_request_duration_seconds_count{job=\\\"demo\\\", method=\\\"GET\\\", status=\\\"200\\\"}[5m]))\\n\\n# 根据请求接口标签分组\\nsum(rate(demo_api_request_duration_seconds_count{job=\\\"demo\\\", method=\\\"GET\\\", status=\\\"200\\\"}[5m])) by(path)\\n\\n# 不根据接口路径分组\\nsum(rate(demo_api_request_duration_seconds_count{job=\\\"demo\\\", method=\\\"GET\\\", status=\\\"200\\\"}[5m])) without(path)\\n\\n\"}]},{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[160,161]},\"content\":\"histogram_quantile\",\"children\":[{\"type\":\"fence\",\"depth\":5,\"content\":\"# 用来统计百分位数：第一个参数是百分位，第二个 histogram 指标，这样计算出来的就是中位数，即 P50\\nhistogram_quantile(0.5,go_gc_pauses_seconds_total_bucket)\\n\\n\"}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[167,168]},\"content\":\"其他\",\"children\":[{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[169,170]},\"content\":\"prometheus配置动态动态更新\",\"children\":[{\"type\":\"list_item\",\"depth\":6,\"payload\":{\"lines\":[171,172]},\"content\":\"启动时需带上参数 prometheus --config.file=/usr/local/etc/prometheus.yml --web.enable-lifecycle\"},{\"type\":\"list_item\",\"depth\":6,\"payload\":{\"lines\":[172,173]},\"content\":\"更新prometheus.yml配置\"},{\"type\":\"list_item\",\"depth\":6,\"payload\":{\"lines\":[173,174]},\"content\":\"通过post的方式请求接口curl -v --request POST 'http://localhost:9090/-/reload'\"}]},{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[175,176]},\"content\":\"指标抓取和存储\",\"children\":[{\"type\":\"fence\",\"depth\":5,\"content\":\"global:\\n scrape_interval: 15s\\n\\n\"}]},{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[186,187]},\"content\":\"prometheus分位数坑点\"}]}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[194,195]},\"content\":\"参考\",\"children\":[{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[196,197]},\"content\":\"一文带你了解 Prometheus\"}]}]},{})","text":"Markmap * { margin: 0; padding: 0; } # mindmap { display: block; width: 100vw; height: 100vh; } (r => { setTimeout(r); })(() => { const { markmap, mm } = window; const toolbar = new markmap.Toolbar(); toolbar.attach(mm); const el = toolbar.render(); el.setAttribute('style', 'position:absolute;bottom:20px;right:20px'); document.body.append(el); })((getMarkmap, getOptions, root, jsonOptions) => { const markmap = getMarkmap(); window.mm = markmap.Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(markmap, jsonOptions), root); })(() => window.markmap,(markmap, jsonOptions) => markmap.deriveOptions(jsonOptions),{\"type\":\"heading\",\"depth\":1,\"payload\":{\"lines\":[1,2]},\"content\":\"prometheus相关实践\",\"children\":[{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[3,4]},\"content\":\"docker部署prometheus和grafana\",\"children\":[{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[5,6]},\"content\":\"启动node-exporter\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"docker run -d -p 9100:9100 \\\\\\n --name node-exporter \\\\\\n --restart=always \\\\\\n -v /data/apps/docker/node-exporter-data/proc:/host/proc:ro \\\\\\n -v /data/apps/docker/node-exporter-data/sys:/host/sys:ro \\\\\\n -v /data/apps/docker/node-exporter-data:/rootfs:ro \\\\\\n prom/node-exporter\\n\\n\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[17,18]},\"content\":\"编写prometheus.yml\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"global:\\n scrape_interval: 60s\\n evaluation_interval: 60s\\n\\nscrape_configs:\\n - job_name: prometheus\\n static_configs:\\n - targets:\\n - 192.168.0.104:9090\\n\\n - job_name: node-exporter\\n static_configs:\\n - targets:\\n - 192.168.0.104:9100\\n - job_name: jenkins\\n scheme: http\\n metrics_path: prometheus\\n bearer_token: bearer_token\\n static_configs:\\n - targets:\\n - 192.168.57.242:8080\\n\\n\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[43,44]},\"content\":\"启动promethus\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"docker run -d \\\\\\n --name prometheus \\\\\\n --restart=always \\\\\\n -u root \\\\\\n -p 9090:9090 \\\\\\n -v /data/apps/docker/prometheus-data/prometheus.yml:/etc/prometheus/prometheus.yml \\\\\\n -v /data/apps/docker/prometheus-data:/prometheus \\\\\\n -v /data/apps/docker/prometheus-data/conf:/etc/prometheus/conf \\\\\\n prom/prometheus --web.enable-lifecycle\\n\\n\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[57,58]},\"content\":\"启动grafana\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"docker run -d \\\\\\n -p 3000:3000 \\\\\\n --restart=always \\\\\\n --name=grafana \\\\\\n -u root \\\\\\n -v /data/apps/docker/grafana-data:/var/lib/grafana \\\\\\n grafana/grafana\\n\\n\"}]}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[71,72]},\"content\":\"Metric指标\",\"children\":[{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[73,74]},\"content\":\"数据模型\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[79,80]},\"content\":\"指标名和指标标签集合：metric_name{&lt;label1=v1&gt;,&lt;label2=v2&gt;....}，指标名：表示这个指标是监控哪一方面的状态，比如 http_request_total 表示：请求数量；指标标签，描述这个指标有哪些维度，比如 http_request_total 这个指标，有请求状态码 code = 200/400/500，请求方式：method = get/post 等，实际上指标名称实际上是以标签的形式保存，这个标签是name，即：name=。\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[80,81]},\"content\":\"时间戳：描述当前时间序列的时间，单位：毫秒。\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[81,82]},\"content\":\"样本值：当前监控指标的具体数值，比如 http_request_total 的值就是请求数是多少。\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[83,84]},\"content\":\"指标类型\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[85,86]},\"content\":\"Counter 计数器\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[86,87]},\"content\":\"Gauge 仪表盘\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[87,88]},\"content\":\"Histogram 直方图\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[88,89]},\"content\":\"Summary 摘要\"}]}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[90,91]},\"content\":\"PromQL\",\"children\":[{\"type\":\"bullet_list\",\"depth\":3,\"payload\":{\"lines\":[94,99]},\"content\":\"\",\"children\":[{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[94,95]},\"content\":\"字符串：只作为某些内置函数的参数出现\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[95,96]},\"content\":\"标量：单一的数字值，可以是函数参数，也可以是函数的返回结果\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[96,97]},\"content\":\"瞬时向量：某一时刻的时序数据\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[97,98]},\"content\":\"区间向量：某一时间区间内的时序数据集合\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[99,100]},\"content\":\"瞬时查询\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"# 直接查询\\ngo_gc_duration_seconds_count\\n# 筛选\\ngo_gc_duration_seconds_count{instance=\\\"127.0.0.1:9600\\\"}\\n# 正则\\ngo_gc_duration_seconds_count{instance=~\\\"localhost.*\\\"}\\n\\n\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[112,113]},\"content\":\"范围查询\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"# d：天，h：小时，m：分钟，ms：毫秒，s：秒，w：周，y：年\\ngo_gc_duration_seconds_count{}[5m]\\n# 偏移\\ngo_gc_duration_seconds_count{}[5m] offset 1d\\n\\n\"}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[123,124]},\"content\":\"内置函数\",\"children\":[{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[125,126]},\"content\":\"rate\",\"children\":[{\"type\":\"fence\",\"depth\":5,\"content\":\"rate函数=时间区间前后两个点的差 / 时间范围\\n\\n\"},{\"type\":\"fence\",\"depth\":5,\"content\":\"rate(demo_api_request_duration_seconds_count[1m])/60\\n\\n\"}]},{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[141,142]},\"content\":\"irate\",\"children\":[{\"type\":\"fence\",\"depth\":5,\"content\":\"irate = 时间区间内最后两个样本点的差 / 最后两个样本点的时间差\\n\\n\"}]},{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[147,148]},\"content\":\"聚合函数：Sum() by() without()\",\"children\":[{\"type\":\"fence\",\"depth\":5,\"content\":\"# 将多个服务多个接口的请求聚合\\nsum(rate(demo_api_request_duration_seconds_count{job=\\\"demo\\\", method=\\\"GET\\\", status=\\\"200\\\"}[5m]))\\n\\n# 根据请求接口标签分组\\nsum(rate(demo_api_request_duration_seconds_count{job=\\\"demo\\\", method=\\\"GET\\\", status=\\\"200\\\"}[5m])) by(path)\\n\\n# 不根据接口路径分组\\nsum(rate(demo_api_request_duration_seconds_count{job=\\\"demo\\\", method=\\\"GET\\\", status=\\\"200\\\"}[5m])) without(path)\\n\\n\"}]},{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[160,161]},\"content\":\"histogram_quantile\",\"children\":[{\"type\":\"fence\",\"depth\":5,\"content\":\"# 用来统计百分位数：第一个参数是百分位，第二个 histogram 指标，这样计算出来的就是中位数，即 P50\\nhistogram_quantile(0.5,go_gc_pauses_seconds_total_bucket)\\n\\n\"}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[167,168]},\"content\":\"其他\",\"children\":[{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[169,170]},\"content\":\"prometheus配置动态动态更新\",\"children\":[{\"type\":\"list_item\",\"depth\":6,\"payload\":{\"lines\":[171,172]},\"content\":\"启动时需带上参数 prometheus --config.file=/usr/local/etc/prometheus.yml --web.enable-lifecycle\"},{\"type\":\"list_item\",\"depth\":6,\"payload\":{\"lines\":[172,173]},\"content\":\"更新prometheus.yml配置\"},{\"type\":\"list_item\",\"depth\":6,\"payload\":{\"lines\":[173,174]},\"content\":\"通过post的方式请求接口curl -v --request POST 'http://localhost:9090/-/reload'\"}]},{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[175,176]},\"content\":\"指标抓取和存储\",\"children\":[{\"type\":\"fence\",\"depth\":5,\"content\":\"global:\\n scrape_interval: 15s\\n\\n\"}]},{\"type\":\"heading\",\"depth\":4,\"payload\":{\"lines\":[186,187]},\"content\":\"prometheus分位数坑点\"}]}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[194,195]},\"content\":\"参考\",\"children\":[{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[196,197]},\"content\":\"一文带你了解 Prometheus\"}]}]},{}) prometheus相关实践docker部署prometheus和grafana启动node-exporter1234567docker run -d -p 9100:9100 \\ --name node-exporter \\ --restart=always \\ -v /data/apps/docker/node-exporter-data/proc:/host/proc:ro \\ -v /data/apps/docker/node-exporter-data/sys:/host/sys:ro \\ -v /data/apps/docker/node-exporter-data:/rootfs:ro \\ prom/node-exporter 编写prometheus.yml123456789101112131415161718192021global: scrape_interval: 60s evaluation_interval: 60sscrape_configs: - job_name: prometheus static_configs: - targets: - 192.168.0.104:9090 - job_name: node-exporter static_configs: - targets: - 192.168.0.104:9100 - job_name: jenkins scheme: http metrics_path: prometheus bearer_token: bearer_token static_configs: - targets: - 192.168.57.242:8080 启动promethus123456789docker run -d \\ --name prometheus \\ --restart=always \\ -u root \\ -p 9090:9090 \\ -v /data/apps/docker/prometheus-data/prometheus.yml:/etc/prometheus/prometheus.yml \\ -v /data/apps/docker/prometheus-data:/prometheus \\ -v /data/apps/docker/prometheus-data/conf:/etc/prometheus/conf \\ prom/prometheus --web.enable-lifecycle 启动grafana1234567docker run -d \\ -p 3000:3000 \\ --restart=always \\ --name=grafana \\ -u root \\ -v /data/apps/docker/grafana-data:/var/lib/grafana \\ grafana/grafana grafana账号密码默认admin Metric指标数据模型 Prometheus 采集的所有指标都是以时间序列的形式进行存储，每一个时间序列有三部分组成： 指标名和指标标签集合：metric_name{&lt;label1=v1&gt;,&lt;label2=v2&gt;….}，指标名：表示这个指标是监控哪一方面的状态，比如 http_request_total 表示：请求数量；指标标签，描述这个指标有哪些维度，比如 http_request_total 这个指标，有请求状态码 code = 200/400/500，请求方式：method = get/post 等，实际上指标名称实际上是以标签的形式保存，这个标签是name，即：name=。 时间戳：描述当前时间序列的时间，单位：毫秒。 样本值：当前监控指标的具体数值，比如 http_request_total 的值就是请求数是多少。 指标类型 Counter 计数器 Gauge 仪表盘 Histogram 直方图 Summary 摘要 PromQLPromQL 是 Prometheus 为我们提供的函数式的查询语言，查询表达式有四种类型： 字符串：只作为某些内置函数的参数出现 标量：单一的数字值，可以是函数参数，也可以是函数的返回结果 瞬时向量：某一时刻的时序数据 区间向量：某一时间区间内的时序数据集合 瞬时查询直接通过指标名即可进行查询，查询结果是当前指标最新的时间序列，比如查询 Gc 累积消耗的时间： 123456# 直接查询go_gc_duration_seconds_count# 筛选go_gc_duration_seconds_count&#123;instance=\"127.0.0.1:9600\"&#125;# 正则go_gc_duration_seconds_count&#123;instance=~\"localhost.*\"&#125; 范围查询范围查询的结果集就是区间向量，可以通过[]指定时间来做范围查询，查询 5 分钟内的 Gc 累积消耗时间： 1234# d：天，h：小时，m：分钟，ms：毫秒，s：秒，w：周，y：年go_gc_duration_seconds_count&#123;&#125;[5m]# 偏移go_gc_duration_seconds_count&#123;&#125;[5m] offset 1d 内置函数raterate 函数可以用来求指标的平均变化速率 1rate函数=时间区间前后两个点的差 / 时间范围 一般 rate 函数可以用来求某个时间区间内的请求速率，也就是我们常说的 QPS： 1rate(demo_api_request_duration_seconds_count[1m])/60 但是 rate 函数只是算出来了某个时间区间内的平均速率，没办法反映突发变化，假设在一分钟的时间区间里，前 50 秒的请求量都是 0 到 10 左右，但是最后 10 秒的请求量暴增到 100 以上，这时候算出来的值可能无法很好的反映这个峰值变化。这个问题可以通过 irate 函数解决，irate 函数求出来的就是瞬时变化率。 irate1irate = 时间区间内最后两个样本点的差 / 最后两个样本点的时间差 聚合函数：Sum() by() without()12345678# 将多个服务多个接口的请求聚合sum(rate(demo_api_request_duration_seconds_count&#123;job=\"demo\", method=\"GET\", status=\"200\"&#125;[5m]))# 根据请求接口标签分组sum(rate(demo_api_request_duration_seconds_count&#123;job=\"demo\", method=\"GET\", status=\"200\"&#125;[5m])) by(path)# 不根据接口路径分组sum(rate(demo_api_request_duration_seconds_count&#123;job=\"demo\", method=\"GET\", status=\"200\"&#125;[5m])) without(path) histogram_quantile12# 用来统计百分位数：第一个参数是百分位，第二个 histogram 指标，这样计算出来的就是中位数，即 P50histogram_quantile(0.5,go_gc_pauses_seconds_total_bucket) 其他prometheus配置动态动态更新 启动时需带上参数 prometheus --config.file=/usr/local/etc/prometheus.yml --web.enable-lifecycle 更新prometheus.yml配置 通过post的方式请求接口curl -v --request POST &#39;http://localhost:9090/-/reload&#39; 指标抓取和存储Prometheus 对指标的抓取采取主动 Pull 的方式，即周期性的请求被监控服务暴露的 metrics 接口或者是 PushGateway，从而获取到 Metrics 指标，默认时间是 15s 抓取一次，配置项如下： 12global: scrape_interval: 15s 抓取到的指标会被以时间序列的形式保存在内存中，并且定时刷到磁盘上，默认是两个小时回刷一次。并且为了防止 Prometheus 发生崩溃或重启时能够恢复数据，Prometheus 也提供了类似 MySQL 中 binlog 一样的预写日志，当 Prometheus 崩溃重启时，会读这个预写日志来恢复数据。 prometheus分位数坑点Prometheus 不保存具体的指标数值的，他会帮你把指标放到具体的桶，但是他不会保存你指标的值，计算的分位数是一个预估的值，怎么预估呢？就是假设每个桶内的样本分布是均匀的，线性分布来计算的。假设我们指定桶为：[]float64{0,2.5,5,7.5,10}则 P50，其实就是算排在第50%位置的样本值，假设刚刚所有的数据都落在了第一个桶，那么他在计算的时候就会假定这个50%值在第一个桶的中点，他就会假定这个数就是 0.5*2.5，P99 就是第一个桶的 99%的位置，他就会假定这个数就是 0.99*2.5。 导致这个误差较大的原因就是我们的 bucket 设置的不合理。 参考 一文带你了解 Prometheus","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"云原生","slug":"云原生","permalink":"https://fengyuwsuong.cn/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"},{"name":"监控","slug":"监控","permalink":"https://fengyuwsuong.cn/tags/%E7%9B%91%E6%8E%A7/"},{"name":"prometheus","slug":"prometheus","permalink":"https://fengyuwsuong.cn/tags/prometheus/"}]},{"title":"Golang逃逸分析","slug":"Golang逃逸分析","date":"2022-05-10T08:58:42.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2022/05/10/Golang逃逸分析/","link":"","permalink":"https://fengyuwsuong.cn/2022/05/10/Golang%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/","excerpt":"Golang编译器逃逸分析逃逸分析(escape analysis)go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。","text":"Golang编译器逃逸分析逃逸分析(escape analysis)go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。 判断是否发生逃逸 查看指针是否连续 12345678910111213141516171819202122232425262728package mainfunc foo(arg_val int) (*int) &#123; var foo_val1 int = 11; var foo_val2 int = 12; var foo_val3 int = 13; var foo_val4 int = 14; var foo_val5 int = 15; //此处循环是防止go编译器将foo优化成inline(内联函数) //如果是内联函数，main调用foo将是原地展开，所以foo_val1-5相当于main作用域的变量 //即使foo_val3发生逃逸，地址与其他也是连续的 for i := 0; i &lt; 5; i++ &#123; println(&amp;arg_val, &amp;foo_val1, &amp;foo_val2, &amp;foo_val3, &amp;foo_val4, &amp;foo_val5) &#125; //返回foo_val3给main函数 return &amp;foo_val3;&#125;func main() &#123; main_val := foo(666) println(*main_val, main_val)&#125; 输出： 1234560xc000038768 0xc000038760 0xc000038758 0xc000038750 0xc000038748 0xc0000387400xc000038768 0xc000038760 0xc000038758 0xc000038750 0xc000038748 0xc0000387400xc000038768 0xc000038760 0xc000038758 0xc000038750 0xc000038748 0xc0000387400xc000038768 0xc000038760 0xc000038758 0xc000038750 0xc000038748 0xc0000387400xc000038768 0xc000038760 0xc000038758 0xc000038750 0xc000038748 0xc00003874013 0xc000038750 使用go tool compile测试，发现该变量被判断为逃逸，在堆中被开辟 12345➜ ~ go tool compile -m demo.go demo.go:3:6: can inline foodemo.go:22:6: can inline maindemo.go:23:17: inlining call to foodemo.go:7:6: moved to heap: foo_val3 也可以采用去汇编的方式来证实是否逃逸 1go tool compile -S demo.go &gt; demo.S 截取demo.S部分，发现runtime.newobject(SB),说明该变量在堆空间开辟。 12345678910110x0033 00051 (demo.go:7) LEAQ type.int(SB), AX0x003a 00058 (demo.go:7) MOVQ AX, (SP)0x003e 00062 (demo.go:7) PCDATA $1, $00x003e 00062 (demo.go:7) NOP0x0040 00064 (demo.go:7) CALL runtime.newobject(SB)0x0045 00069 (demo.go:7) MOVQ 8(SP), AX0x004a 00074 (demo.go:7) MOVQ AX, &quot;&quot;.&amp;foo_val3+56(SP)0x004f 00079 (demo.go:7) MOVQ $13, (AX)0x0056 00086 (demo.go:8) MOVQ $14, &quot;&quot;.foo_val4+32(SP)0x005f 00095 (demo.go:9) MOVQ $15, &quot;&quot;.foo_val5+24(SP)0x0068 00104 (demo.go:9) XORL CX, CX 逃逸规则一般我们给一个引用类对象中的引用类成员进行赋值，可能出现逃逸现象。可以理解为访问一个引用对象实际上底层就是通过一个指针来间接的访问了，但如果再访问里面的引用成员就会有第二次间接访问，这样操作这部分对象的话，极大可能会出现逃逸的现象。 Go语言中的引用类型有func（函数类型），interface（接口类型），slice（切片类型），map（字典类型），channel（管道类型），*（指针类型），等 逃逸范例 []interface{}数据类型，通过[]赋值必定会出现逃逸。 map[string]interface{}类型尝试通过赋值，必定会出现逃逸。 map[interface{}]interface{}类型尝试通过赋值，会导致key和value的赋值，key和value均出现逃逸。 map[string][]string数据类型，赋值会发生[]string发生逃逸。 []*int数据类型，赋值的右值会发生逃逸现象。 func(*int)函数类型，进行函数赋值，会使传递的形参出现逃逸现象。 func([]string): 函数类型，进行[]string{“value”}赋值，会使传递的参数出现逃逸现象。 chan []string数据类型，想当前channel中传输[]string{“value”}会发生逃逸现象。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"go","slug":"go","permalink":"https://fengyuwsuong.cn/tags/go/"},{"name":"逃逸分析","slug":"逃逸分析","permalink":"https://fengyuwsuong.cn/tags/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"}]},{"title":"tmux学习笔记","slug":"tmux学习笔记","date":"2022-05-08T06:21:20.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2022/05/08/tmux学习笔记/","link":"","permalink":"https://fengyuwsuong.cn/2022/05/08/tmux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"Tmux","text":"Tmux Tmux是什么会话与进程 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。用户与计算机的这种临时的交互，称为一次”会话”（session） 。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 故为了避免上述问题，需要将会话和窗口“解绑” Tmux的作用Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。 它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 它可以让新窗口”接入”已经存在的会话。 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 它还支持窗口任意的垂直和水平拆分。 基本用法安装12345678# Ubuntu 或 Debian$ sudo apt-get install tmux# CentOS 或 Fedora$ sudo yum install tmux# Mac$ brew install tmux 启动1tmux 退出 exit Ctrl+d 前缀键 Ctrl+b Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是Ctrl+b，即先按下Ctrl+b，快捷键才会生效。 会话管理新建会话 tmux new -s &lt;session-name&gt; 第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。 使用编号区分会话，不太直观，更好的方法是为会话起名。 分离会话 tmux detach Ctrl+b d 在 Tmux 窗口中，按下Ctrl+b d或者输入tmux detach命令，就会将当前会话与窗口分离。 查看会话 tmux ls tmux list-session 接入会话 tmux attach -t &lt;session-id&gt; tmux attach -t &lt;session-name&gt; 杀死会话 tmux kill-session -t &lt;session-id&gt; tmux kill-session -t &lt;session-name&gt; 切换会话 tmux switch -t &lt;session-id&gt; tmux switch -t &lt;session-name&gt; 重命名会话 `tmux rename-session -t Ctrl+b $ 重命名当前会话 会话快捷键 Ctrl+b d 分离当前会话 Ctrl+b s 列出所有会话 Ctrl+b $ 重命名当前会话 窗格操作划分窗格 tmux split-window 划分上下两个窗格 tmux split-window -h 划分左右两个窗格 移动光标 tmux select-pane -U 光标切换到上方窗格 tmux select-pane -D 光标切换到下方窗格 tmux select-pane -L 光标切换到左边窗格 tmux select-pane -R 光标切换到右边窗格 交换窗格位置 tmux swap-pane -U 当前窗格上移 tmux swap-pane -D 当前窗格下移 窗格快捷键1234567891011121314Ctrl+b %：划分左右两个窗格。Ctrl+b \"：划分上下两个窗格。Ctrl+b &lt;arrow key&gt;：光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。Ctrl+b ;：光标切换到上一个窗格。Ctrl+b o：光标切换到下一个窗格。Ctrl+b &#123;：当前窗格与上一个窗格交换位置。Ctrl+b &#125;：当前窗格与下一个窗格交换位置。Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。Ctrl+b x：关闭当前窗格。Ctrl+b !：将当前窗格拆分为一个独立窗口。Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。Ctrl+b q：显示窗格编号。 窗口管理新建窗口 tmux new-window tmux new-window -n &lt;window-name&gt; 切换窗口 tmux select-window -t &lt;window-number&gt; 切换到指定编号的窗口 tmux select-window -t &lt;window-name&gt; 切换到指定名称的窗口 重命名窗口 tmux rename-window &lt;new-name&gt; 命名当前窗口(重命名) 窗口快捷键123456Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。Ctrl+b n：切换到下一个窗口。Ctrl+b &lt;number&gt;：切换到指定编号的窗口，其中的&lt;number&gt;是状态栏上的窗口编号。Ctrl+b w：从列表中选择窗口。Ctrl+b ,：窗口重命名。 其他命令1234567891011# 列出所有快捷键，及其对应的 Tmux 命令$ tmux list-keys# 列出所有 Tmux 命令及其参数$ tmux list-commands# 列出当前所有 Tmux 会话的信息$ tmux info# 重新加载当前的 Tmux 配置$ tmux source-file ~/.tmux.conf 踩坑点 鼠标滚轮不能翻动缓冲区 需要更改~/.tmux.conf配置，增加配置 set -g mode-mouse on","categories":[{"name":"编程","slug":"编程","permalink":"https://fengyuwsuong.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"linux","slug":"linux","permalink":"https://fengyuwsuong.cn/tags/linux/"},{"name":"tmux","slug":"tmux","permalink":"https://fengyuwsuong.cn/tags/tmux/"}]},{"title":"Golang的协程调度器原理及GMP设计思想","slug":"Golang的协程调度器原理及GMP设计思想","date":"2022-05-07T08:27:55.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2022/05/07/Golang的协程调度器原理及GMP设计思想/","link":"","permalink":"https://fengyuwsuong.cn/2022/05/07/Golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/","excerpt":"思维导图 Markmap * { margin: 0; padding: 0; } #mindmap { display: block; width: 100vw; height: 100vh; } (r => { setTimeout(r); })(() => { const { markmap, mm } = window; const toolbar = new markmap.Toolbar(); toolbar.attach(mm); const el = toolbar.render(); el.setAttribute('style', 'position:absolute;bottom:20px;right:20px'); document.body.append(el); })((getMarkmap, getOptions, root, jsonOptions) => { const markmap = getMarkmap(); window.mm = markmap.Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(markmap, jsonOptions), root); })(() => window.markmap,(markmap, jsonOptions) => markmap.deriveOptions(jsonOptions),{\"type\":\"heading\",\"depth\":1,\"payload\":{\"lines\":[1,2]},\"content\":\"GMP设计思想\",\"children\":[{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[3,4]},\"content\":\"调度器的由来\",\"children\":[{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[5,6]},\"content\":\"单进程\"},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[9,10]},\"content\":\"多进程/线程\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[13,14]},\"content\":\"优点\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[14,15]},\"content\":\"可以并发执行任务\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[15,16]},\"content\":\"缺点\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[16,17]},\"content\":\"高内存占用\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[17,18]},\"content\":\"调度的高消耗CPU\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[18,19]},\"content\":\"锁&amp;竞争冲突\"}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[20,21]},\"content\":\"协程\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[22,23]},\"content\":\"解决多进程&amp;线程的缺点而被设计\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[23,24]},\"content\":\"线程和协程关系\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[24,25]},\"content\":\"N:1\",\"children\":[{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[25,26]},\"content\":\"缺点：无法使用硬件多核能力、协程阻塞则无法并行\"}]},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[26,27]},\"content\":\"1:1\",\"children\":[{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[27,28]},\"content\":\"缺点：协程创建、删除和切换的代价都依赖CPU线程完成，代价昂贵\"}]},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[28,29]},\"content\":\"M:N\",\"children\":[{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[29,30]},\"content\":\"克服了以上缺点\"}]}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[30,31]},\"content\":\"线程&amp;协程区别\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[31,32]},\"content\":\"占用空间\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[32,33]},\"content\":\"调度：抢占式vs协作式（协程让出CPU后才执行下一个协程）\"}]}]}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[34,35]},\"content\":\"Goroutine调度器的GMP模型设计思想\",\"children\":[{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[36,37]},\"content\":\"Go语言的协程goroutine\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[38,39]},\"content\":\"goroutine&amp;channel\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[39,40]},\"content\":\"特点\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[40,41]},\"content\":\"占用内存更小\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[41,42]},\"content\":\"调度更灵活\"}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[43,44]},\"content\":\"旧版goroutine调度器\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[49,50]},\"content\":\"缺点\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[50,51],\"index\":1},\"content\":\"1. 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[51,52],\"index\":2},\"content\":\"2. M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M'。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[52,53],\"index\":3},\"content\":\"3. 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。\"}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[54,55]},\"content\":\"GMP模型\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[58,59]},\"content\":\"模型相关\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[59,60],\"index\":1},\"content\":\"1. 全局队列（Global Queue）：存放等待运行的G。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[60,61],\"index\":2},\"content\":\"2. P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[61,62],\"index\":3},\"content\":\"3. P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[62,63],\"index\":4},\"content\":\"4. M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[63,64]},\"content\":\"P和M的个数问题\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[64,65]},\"content\":\"P的数量\",\"children\":[{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[65,66]},\"content\":\"由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。\"},{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[66,67]},\"content\":\"M的数量\",\"children\":[{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[67,68]},\"content\":\"go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。\"},{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[68,69]},\"content\":\"runtime/debug中的SetMaxThreads函数，设置M的最大数量\"},{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[69,70]},\"content\":\"一个M阻塞了，会创建新的M。\"}]},{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[70,71]},\"content\":\"P和M的关系\",\"children\":[{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[71,72]},\"content\":\"M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。\"}]},{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[72,73]},\"content\":\"P和M何时被创建\",\"children\":[{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[73,74]},\"content\":\"P：在确定P的最大数量n后，运行时系统会根据这个数量创建n个P\"},{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[74,75]},\"content\":\"M：没有足够的M来关联P并运行其中可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。\"}]}]}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[76,77]},\"content\":\"调度器的设计策略\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[78,79]},\"content\":\"复用线程\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[79,80]},\"content\":\"work stealing机制：当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[80,81]},\"content\":\"hand off机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[81,82]},\"content\":\"利用并行\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[82,83]},\"content\":\"GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[83,84]},\"content\":\"抢占\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[84,85]},\"content\":\"在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[85,86]},\"content\":\"全局G队列\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[86,87]},\"content\":\"在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。\"}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[88,89]},\"content\":\"go func()调度流程\"},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[99,100]},\"content\":\"调度器的生命周期\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"package main\\n\\nimport \\\"fmt\\\"\\n\\nfunc main() {\\n fmt.Println(\\\"Hello world\\\")\\n}\\n\\n\"},{\"type\":\"bullet_list\",\"depth\":4,\"payload\":{\"lines\":[113,125]},\"content\":\"\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[113,114]},\"content\":\"M0&amp;G0\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[114,115]},\"content\":\"M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[115,116]},\"content\":\"G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[116,117]},\"content\":\"生命周期流程\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[117,118],\"index\":1},\"content\":\"1. runtime创建最初的线程m0和goroutine g0，并把2者关联。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[118,119],\"index\":2},\"content\":\"2. 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[119,120],\"index\":3},\"content\":\"3. 示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[120,121],\"index\":4},\"content\":\"4. 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[121,122],\"index\":5},\"content\":\"5. G拥有栈，M根据G中的栈信息和调度信息设置运行环境\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[122,123],\"index\":6},\"content\":\"6. M运行G\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[123,124],\"index\":7},\"content\":\"7. G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。\"}]}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[125,126]},\"content\":\"可视化GMP编程\",\"children\":[{\"type\":\"bullet_list\",\"depth\":4,\"payload\":{\"lines\":[127,129]},\"content\":\"\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[127,128]},\"content\":\"go tool trace\"}]},{\"type\":\"fence\",\"depth\":4,\"content\":\"package main\\n\\nimport (\\n \\\"os\\\"\\n \\\"fmt\\\"\\n \\\"runtime/trace\\\"\\n)\\n\\nfunc main() {\\n\\n //创建trace文件\\n f, err := os.Create(\\\"trace.out\\\")\\n if err != nil {\\n panic(err)\\n }\\n\\n defer f.Close()\\n\\n //启动trace goroutine\\n err = trace.Start(f)\\n if err != nil {\\n panic(err)\\n }\\n defer trace.Stop()\\n\\n //main\\n fmt.Println(\\\"Hello World\\\")\\n}\\n\\n\"},{\"type\":\"bullet_list\",\"depth\":4,\"payload\":{\"lines\":[162,164]},\"content\":\"\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[162,163]},\"content\":\"Debug trace\"}]},{\"type\":\"fence\",\"depth\":4,\"content\":\" $ GODEBUG=schedtrace=1000 ./trace2\\n SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [0 0]\\n Hello World\\n SCHED 1003ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]\\n Hello World\\n SCHED 2014ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]\\n Hello World\\n SCHED 3015ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]\\n Hello World\\n SCHED 4023ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]\\n Hello World\\n\\n\"},{\"type\":\"bullet_list\",\"depth\":4,\"payload\":{\"lines\":[180,192]},\"content\":\"\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[180,181]},\"content\":\"执行方式：GODEBUG=schedtrace=1000 ./trace2\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[181,182]},\"content\":\"说明\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[182,183]},\"content\":\"SCHED：调试信息输出标志字符串，代表本行是goroutine调度器的输出；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[183,184]},\"content\":\"0ms：即从程序启动到输出这行日志的时间；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[184,185]},\"content\":\"gomaxprocs: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[185,186]},\"content\":\"idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[186,187]},\"content\":\"threads: os threads/M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[187,188]},\"content\":\"spinningthreads: 处于自旋状态的os thread数量；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[188,189]},\"content\":\"idlethread: 处于idle状态的os thread的数量；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[189,190]},\"content\":\"runqueue=0： Scheduler全局队列中G的数量；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[190,191]},\"content\":\"[0 0]: 分别为2个P的local queue中的G的数量。\"}]}]}]}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[192,193]},\"content\":\"Go调度器调度场景过程全解析\",\"children\":[{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[196,197]},\"content\":\"新建G会优先放到当前的P本地队列\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[197,198]},\"content\":\"M执行完G时，会先切换G0负责协程的调度切换，从而执行下一个G\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[198,199]},\"content\":\"当开辟过多G，P本地队列装不下的时候，则会执行负载均衡（把P本地队列前一半的G和新建的G打乱顺序转移到全局队列【新建的G不一定会转移，需视是否需立即执行决定】）\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[199,200]},\"content\":\"创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[200,201]},\"content\":\"空闲M从全局队列GQ获取G的数量符合公式：n = min(len(GQ) / GOMAXPROCS + 1, cap(LQ) / 2 )\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[201,202]},\"content\":\"如全局队列已经没有G，则m需要自行work stealing: 从其他P的本地队列中偷取一半的G，放到自己的P队列\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[202,203]},\"content\":\"空闲线程如没有G执行，则会让其处于自旋状态【由于创建销毁本身也需消耗资源，故保存自旋当有新的G时可立马执行】，最多有GOMAXPROCS个自旋线程\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[203,204]},\"content\":\"当G进行了系统调用时，则M和P会立即解绑，此时如P本地队列存在G、全局队列有G或有空闲的M，P都会立马唤醒一个M和它绑定，否则P会加入空闲P列表，等待M来获取【即当前M用于执行阻塞系统调用的G，此时M无P绑定】\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[204,205]},\"content\":\"假设G进行的系统调用并非阻塞，则M执行完毕系统后，G会重新投入G全局队列中并标记为可运行状态，同时M会重新尝试获取之前绑定的P，如该P已被其他M绑定，则从空闲队列中获取P，如仍获取失败则M因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。\"}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[206,207]},\"content\":\"总结\"},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[210,211]},\"content\":\"参考\",\"children\":[{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[212,213]},\"content\":\"Golang的协程调度器原理及GMP设计思想\"}]}]},{})","text":"思维导图 Markmap * { margin: 0; padding: 0; } #mindmap { display: block; width: 100vw; height: 100vh; } (r => { setTimeout(r); })(() => { const { markmap, mm } = window; const toolbar = new markmap.Toolbar(); toolbar.attach(mm); const el = toolbar.render(); el.setAttribute('style', 'position:absolute;bottom:20px;right:20px'); document.body.append(el); })((getMarkmap, getOptions, root, jsonOptions) => { const markmap = getMarkmap(); window.mm = markmap.Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(markmap, jsonOptions), root); })(() => window.markmap,(markmap, jsonOptions) => markmap.deriveOptions(jsonOptions),{\"type\":\"heading\",\"depth\":1,\"payload\":{\"lines\":[1,2]},\"content\":\"GMP设计思想\",\"children\":[{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[3,4]},\"content\":\"调度器的由来\",\"children\":[{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[5,6]},\"content\":\"单进程\"},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[9,10]},\"content\":\"多进程/线程\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[13,14]},\"content\":\"优点\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[14,15]},\"content\":\"可以并发执行任务\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[15,16]},\"content\":\"缺点\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[16,17]},\"content\":\"高内存占用\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[17,18]},\"content\":\"调度的高消耗CPU\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[18,19]},\"content\":\"锁&amp;竞争冲突\"}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[20,21]},\"content\":\"协程\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[22,23]},\"content\":\"解决多进程&amp;线程的缺点而被设计\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[23,24]},\"content\":\"线程和协程关系\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[24,25]},\"content\":\"N:1\",\"children\":[{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[25,26]},\"content\":\"缺点：无法使用硬件多核能力、协程阻塞则无法并行\"}]},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[26,27]},\"content\":\"1:1\",\"children\":[{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[27,28]},\"content\":\"缺点：协程创建、删除和切换的代价都依赖CPU线程完成，代价昂贵\"}]},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[28,29]},\"content\":\"M:N\",\"children\":[{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[29,30]},\"content\":\"克服了以上缺点\"}]}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[30,31]},\"content\":\"线程&amp;协程区别\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[31,32]},\"content\":\"占用空间\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[32,33]},\"content\":\"调度：抢占式vs协作式（协程让出CPU后才执行下一个协程）\"}]}]}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[34,35]},\"content\":\"Goroutine调度器的GMP模型设计思想\",\"children\":[{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[36,37]},\"content\":\"Go语言的协程goroutine\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[38,39]},\"content\":\"goroutine&amp;channel\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[39,40]},\"content\":\"特点\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[40,41]},\"content\":\"占用内存更小\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[41,42]},\"content\":\"调度更灵活\"}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[43,44]},\"content\":\"旧版goroutine调度器\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[49,50]},\"content\":\"缺点\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[50,51],\"index\":1},\"content\":\"1. 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[51,52],\"index\":2},\"content\":\"2. M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M'。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[52,53],\"index\":3},\"content\":\"3. 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。\"}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[54,55]},\"content\":\"GMP模型\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[58,59]},\"content\":\"模型相关\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[59,60],\"index\":1},\"content\":\"1. 全局队列（Global Queue）：存放等待运行的G。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[60,61],\"index\":2},\"content\":\"2. P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[61,62],\"index\":3},\"content\":\"3. P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[62,63],\"index\":4},\"content\":\"4. M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[63,64]},\"content\":\"P和M的个数问题\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[64,65]},\"content\":\"P的数量\",\"children\":[{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[65,66]},\"content\":\"由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。\"},{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[66,67]},\"content\":\"M的数量\",\"children\":[{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[67,68]},\"content\":\"go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。\"},{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[68,69]},\"content\":\"runtime/debug中的SetMaxThreads函数，设置M的最大数量\"},{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[69,70]},\"content\":\"一个M阻塞了，会创建新的M。\"}]},{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[70,71]},\"content\":\"P和M的关系\",\"children\":[{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[71,72]},\"content\":\"M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。\"}]},{\"type\":\"list_item\",\"depth\":9,\"payload\":{\"lines\":[72,73]},\"content\":\"P和M何时被创建\",\"children\":[{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[73,74]},\"content\":\"P：在确定P的最大数量n后，运行时系统会根据这个数量创建n个P\"},{\"type\":\"list_item\",\"depth\":11,\"payload\":{\"lines\":[74,75]},\"content\":\"M：没有足够的M来关联P并运行其中可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。\"}]}]}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[76,77]},\"content\":\"调度器的设计策略\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[78,79]},\"content\":\"复用线程\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[79,80]},\"content\":\"work stealing机制：当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[80,81]},\"content\":\"hand off机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[81,82]},\"content\":\"利用并行\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[82,83]},\"content\":\"GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[83,84]},\"content\":\"抢占\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[84,85]},\"content\":\"在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[85,86]},\"content\":\"全局G队列\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[86,87]},\"content\":\"在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。\"}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[88,89]},\"content\":\"go func()调度流程\"},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[99,100]},\"content\":\"调度器的生命周期\",\"children\":[{\"type\":\"fence\",\"depth\":4,\"content\":\"package main\\n\\nimport \\\"fmt\\\"\\n\\nfunc main() {\\n fmt.Println(\\\"Hello world\\\")\\n}\\n\\n\"},{\"type\":\"bullet_list\",\"depth\":4,\"payload\":{\"lines\":[113,125]},\"content\":\"\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[113,114]},\"content\":\"M0&amp;G0\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[114,115]},\"content\":\"M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[115,116]},\"content\":\"G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。\"}]},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[116,117]},\"content\":\"生命周期流程\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[117,118],\"index\":1},\"content\":\"1. runtime创建最初的线程m0和goroutine g0，并把2者关联。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[118,119],\"index\":2},\"content\":\"2. 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[119,120],\"index\":3},\"content\":\"3. 示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[120,121],\"index\":4},\"content\":\"4. 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[121,122],\"index\":5},\"content\":\"5. G拥有栈，M根据G中的栈信息和调度信息设置运行环境\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[122,123],\"index\":6},\"content\":\"6. M运行G\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[123,124],\"index\":7},\"content\":\"7. G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。\"}]}]}]},{\"type\":\"heading\",\"depth\":3,\"payload\":{\"lines\":[125,126]},\"content\":\"可视化GMP编程\",\"children\":[{\"type\":\"bullet_list\",\"depth\":4,\"payload\":{\"lines\":[127,129]},\"content\":\"\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[127,128]},\"content\":\"go tool trace\"}]},{\"type\":\"fence\",\"depth\":4,\"content\":\"package main\\n\\nimport (\\n \\\"os\\\"\\n \\\"fmt\\\"\\n \\\"runtime/trace\\\"\\n)\\n\\nfunc main() {\\n\\n //创建trace文件\\n f, err := os.Create(\\\"trace.out\\\")\\n if err != nil {\\n panic(err)\\n }\\n\\n defer f.Close()\\n\\n //启动trace goroutine\\n err = trace.Start(f)\\n if err != nil {\\n panic(err)\\n }\\n defer trace.Stop()\\n\\n //main\\n fmt.Println(\\\"Hello World\\\")\\n}\\n\\n\"},{\"type\":\"bullet_list\",\"depth\":4,\"payload\":{\"lines\":[162,164]},\"content\":\"\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[162,163]},\"content\":\"Debug trace\"}]},{\"type\":\"fence\",\"depth\":4,\"content\":\" $ GODEBUG=schedtrace=1000 ./trace2\\n SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [0 0]\\n Hello World\\n SCHED 1003ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]\\n Hello World\\n SCHED 2014ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]\\n Hello World\\n SCHED 3015ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]\\n Hello World\\n SCHED 4023ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]\\n Hello World\\n\\n\"},{\"type\":\"bullet_list\",\"depth\":4,\"payload\":{\"lines\":[180,192]},\"content\":\"\",\"children\":[{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[180,181]},\"content\":\"执行方式：GODEBUG=schedtrace=1000 ./trace2\"},{\"type\":\"list_item\",\"depth\":5,\"payload\":{\"lines\":[181,182]},\"content\":\"说明\",\"children\":[{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[182,183]},\"content\":\"SCHED：调试信息输出标志字符串，代表本行是goroutine调度器的输出；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[183,184]},\"content\":\"0ms：即从程序启动到输出这行日志的时间；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[184,185]},\"content\":\"gomaxprocs: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[185,186]},\"content\":\"idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[186,187]},\"content\":\"threads: os threads/M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[187,188]},\"content\":\"spinningthreads: 处于自旋状态的os thread数量；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[188,189]},\"content\":\"idlethread: 处于idle状态的os thread的数量；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[189,190]},\"content\":\"runqueue=0： Scheduler全局队列中G的数量；\"},{\"type\":\"list_item\",\"depth\":7,\"payload\":{\"lines\":[190,191]},\"content\":\"[0 0]: 分别为2个P的local queue中的G的数量。\"}]}]}]}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[192,193]},\"content\":\"Go调度器调度场景过程全解析\",\"children\":[{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[196,197]},\"content\":\"新建G会优先放到当前的P本地队列\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[197,198]},\"content\":\"M执行完G时，会先切换G0负责协程的调度切换，从而执行下一个G\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[198,199]},\"content\":\"当开辟过多G，P本地队列装不下的时候，则会执行负载均衡（把P本地队列前一半的G和新建的G打乱顺序转移到全局队列【新建的G不一定会转移，需视是否需立即执行决定】）\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[199,200]},\"content\":\"创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[200,201]},\"content\":\"空闲M从全局队列GQ获取G的数量符合公式：n = min(len(GQ) / GOMAXPROCS + 1, cap(LQ) / 2 )\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[201,202]},\"content\":\"如全局队列已经没有G，则m需要自行work stealing: 从其他P的本地队列中偷取一半的G，放到自己的P队列\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[202,203]},\"content\":\"空闲线程如没有G执行，则会让其处于自旋状态【由于创建销毁本身也需消耗资源，故保存自旋当有新的G时可立马执行】，最多有GOMAXPROCS个自旋线程\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[203,204]},\"content\":\"当G进行了系统调用时，则M和P会立即解绑，此时如P本地队列存在G、全局队列有G或有空闲的M，P都会立马唤醒一个M和它绑定，否则P会加入空闲P列表，等待M来获取【即当前M用于执行阻塞系统调用的G，此时M无P绑定】\"},{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[204,205]},\"content\":\"假设G进行的系统调用并非阻塞，则M执行完毕系统后，G会重新投入G全局队列中并标记为可运行状态，同时M会重新尝试获取之前绑定的P，如该P已被其他M绑定，则从空闲队列中获取P，如仍获取失败则M因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。\"}]},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[206,207]},\"content\":\"总结\"},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[210,211]},\"content\":\"参考\",\"children\":[{\"type\":\"list_item\",\"depth\":4,\"payload\":{\"lines\":[212,213]},\"content\":\"Golang的协程调度器原理及GMP设计思想\"}]}]},{}) GMP设计思想调度器的由来单进程一个进程只能处理一个任务，故不需要调度器 多进程/线程进程阻塞时，可以切换其他进程来执行其他任务 优点 可以并发执行任务 缺点 高内存占用 调度的高消耗CPU 锁&amp;竞争冲突 协程 解决多进程&amp;线程的缺点而被设计 线程和协程关系 N:1 缺点：无法使用硬件多核能力、协程阻塞则无法并行 1:1 缺点：协程创建、删除和切换的代价都依赖CPU线程完成，代价昂贵 M:N 克服了以上缺点 线程&amp;协程区别 占用空间 调度：抢占式vs协作式（协程让出CPU后才执行下一个协程） Goroutine调度器的GMP模型设计思想Go语言的协程goroutine goroutine&amp;channel 特点 占用内存更小 调度更灵活 旧版goroutine调度器Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？ 缺点 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。 M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M’。 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。 GMP模型 模型相关 全局队列（Global Queue）：存放等待运行的G。 P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。 P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。 M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。 P和M的个数问题 P的数量 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。 M的数量 go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。 runtime/debug中的SetMaxThreads函数，设置M的最大数量 一个M阻塞了，会创建新的M。 P和M的关系 M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。 P和M何时被创建 P：在确定P的最大数量n后，运行时系统会根据这个数量创建n个P M：没有足够的M来关联P并运行其中可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。 调度器的设计策略 复用线程 work stealing机制：当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。 hand off机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。 利用并行 GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。 抢占 在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。 全局G队列 在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。 go func()调度流程 1、我们通过 go func()来创建一个goroutine； 2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中； 3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行； 4、一个M调度G执行的过程是一个循环机制； 5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P； 6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。 调度器的生命周期 1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello world\")&#125; M0&amp;G0 M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。 G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。 生命周期流程 runtime创建最初的线程m0和goroutine g0，并把2者关联。 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。 示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。 G拥有栈，M根据G中的栈信息和调度信息设置运行环境 M运行G G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。 可视化GMP编程 go tool trace trace记录了运行时的信息，能提供可视化的Web页面。 12345678910111213141516171819202122232425262728package mainimport ( \"os\" \"fmt\" \"runtime/trace\")func main() &#123; //创建trace文件 f, err := os.Create(\"trace.out\") if err != nil &#123; panic(err) &#125; defer f.Close() //启动trace goroutine err = trace.Start(f) if err != nil &#123; panic(err) &#125; defer trace.Stop() //main fmt.Println(\"Hello World\")&#125; Debug trace 编译二进制包后使用以下方式执行 1234567891011$ GODEBUG=schedtrace=1000 ./trace2SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [0 0]Hello WorldSCHED 1003ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]Hello WorldSCHED 2014ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]Hello WorldSCHED 3015ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]Hello WorldSCHED 4023ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]Hello World 执行方式：GODEBUG=schedtrace=1000 ./trace2 说明 SCHED：调试信息输出标志字符串，代表本行是goroutine调度器的输出； 0ms：即从程序启动到输出这行日志的时间； gomaxprocs: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置； idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量； threads: os threads/M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量； spinningthreads: 处于自旋状态的os thread数量； idlethread: 处于idle状态的os thread的数量； runqueue=0： Scheduler全局队列中G的数量； [0 0]: 分别为2个P的local queue中的G的数量。 Go调度器调度场景过程全解析具体参考下列文章，重点如下： 新建G会优先放到当前的P本地队列 M执行完G时，会先切换G0负责协程的调度切换，从而执行下一个G 当开辟过多G，P本地队列装不下的时候，则会执行负载均衡（把P本地队列前一半的G和新建的G打乱顺序转移到全局队列【新建的G不一定会转移，需视是否需立即执行决定】） 创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行 空闲M从全局队列GQ获取G的数量符合公式：n = min(len(GQ) / GOMAXPROCS + 1, cap(LQ) / 2 ) 如全局队列已经没有G，则m需要自行work stealing: 从其他P的本地队列中偷取一半的G，放到自己的P队列 空闲线程如没有G执行，则会让其处于自旋状态【由于创建销毁本身也需消耗资源，故保存自旋当有新的G时可立马执行】，最多有GOMAXPROCS个自旋线程 当G进行了系统调用时，则M和P会立即解绑，此时如P本地队列存在G、全局队列有G或有空闲的M，P都会立马唤醒一个M和它绑定，否则P会加入空闲P列表，等待M来获取【即当前M用于执行阻塞系统调用的G，此时M无P绑定】 假设G进行的系统调用并非阻塞，则M执行完毕系统后，G会重新投入G全局队列中并标记为可运行状态，同时M会重新尝试获取之前绑定的P，如该P已被其他M绑定，则从空闲队列中获取P，如仍获取失败则M因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。 总结Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。 参考 Golang的协程调度器原理及GMP设计思想","categories":[{"name":"编程","slug":"编程","permalink":"https://fengyuwsuong.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://fengyuwsuong.cn/tags/golang/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"GMP","slug":"GMP","permalink":"https://fengyuwsuong.cn/tags/GMP/"}]},{"title":"go应用问题排查常用方法","slug":"go应用问题排查常用方法","date":"2022-05-05T09:25:15.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2022/05/05/go应用问题排查常用方法/","link":"","permalink":"https://fengyuwsuong.cn/2022/05/05/go%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"前言一般来说，在开发过程中我们的应用都会遇上各种问题场景，下面关于以下几种常见场景的排查分析问题常见方法进行一定的总结： 分析程序运行时间和CPU利用率情况 分析golang程序内存占用情况 分析golang程序CPU性能情况","text":"前言一般来说，在开发过程中我们的应用都会遇上各种问题场景，下面关于以下几种常见场景的排查分析问题常见方法进行一定的总结： 分析程序运行时间和CPU利用率情况 分析golang程序内存占用情况 分析golang程序CPU性能情况 场景1： 如何分析程序的运行时间与CPU利用率情况？(1) shell内置time指令这个方法不算新颖，但是确很实用。 time是Unix/Linux内置多命令，使用时一般不用传过多参数，直接跟上需要调试多程序即可。 123456$ time go run test2.go&amp;&#123;&#123;0 0&#125; 张三 0&#125;real 0m0.843suser 0m0.216ssys 0m0.389s 上面是使用time对 go run test2.go对执行程序坐了性能分析，得到3个指标。 ● real：从程序开始到结束，实际度过的时间；● user：程序在用户态度过的时间；● sys：程序在内核态度过的时间。 一般情况下 real &gt;= user + sys，因为系统还有其它进程(切换其他进程中间对于本进程会有空白期)。 2) /usr/bin/time指令这个指令比内置的time更加详细一些，使用的时候需要用绝对路径，而且要加上参数-v 12345678910111213141516171819202122232425$ /usr/bin/time -v go run test2.go Command being timed: \"go run test2.go\" User time (seconds): 0.12 System time (seconds): 0.06 Percent of CPU this job got: 115% Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.16 Average shared text size (kbytes): 0 Average unshared data size (kbytes): 0 Average stack size (kbytes): 0 Average total size (kbytes): 0 Maximum resident set size (kbytes): 41172 Average resident set size (kbytes): 0 Major (requiring I/O) page faults: 1 Minor (reclaiming a frame) page faults: 15880 Voluntary context switches: 897 Involuntary context switches: 183 Swaps: 0 File system inputs: 256 File system outputs: 2664 Socket messages sent: 0 Socket messages received: 0 Signals delivered: 0 Page size (bytes): 4096 Exit status: 0 可以看到这里的功能要强大多了，除了之前的信息外，还包括了： ● CPU占用率；● 内存使用情况；● Page Fault 情况；● 进程切换情况；● 文件系统IO；● Socket 使用情况；● …… 场景2： 如何分析golang程序的内存使用情况？(1) 内存占用情况查看我们先写一段demo例子代码 12345678910111213141516171819202122232425262728293031package mainimport ( \"log\" \"runtime\" \"time\")func test() &#123; //slice 会动态扩容，用slice来做堆内存申请 container := make([]int, 8) log.Println(\" ===&gt; loop begin.\") for i := 0; i &lt; 32*1000*1000; i++ &#123; container = append(container, i) &#125; log.Println(\" ===&gt; loop end.\")&#125;func main() &#123; log.Println(\"Start.\") test() log.Println(\"force gc.\") runtime.GC() //强制调用gc回收 log.Println(\"Done.\") time.Sleep(3600 * time.Second) //睡眠，保持程序不退出&#125; 编译 1$go build -o snippet_mem &amp;&amp; ./snippet_mem 然后在./snippet_mem进程没有执行完，我们再开一个窗口，通过top命令查看进程的内存占用情况 $top -p $(pidof snippet_mem) 得到结果如下： 我们看出来，没有退出的snippet_mem进程有约770m的内存被占用。 直观上来说，这个程序在test()函数执行完后，切片contaner的内存应该被释放，不应该占用770m那么大。 下面让我们使用GODEBUG来分析程序的内存使用情况。 (2) GODEBUG与gctrace 用法 执行snippet_mem程序之前添加环境变量GODEBUG=&#39;gctrace=1&#39;来跟踪打印垃圾回收器信息 1GODEBUG='gctrace=1' ./snippet_mem 设置gctrace=1会使得垃圾回收器在每次回收时汇总所回收内存的大小以及耗时，并将这些内容汇总成单行内容打印到标准错误输出中。 格式 1gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&gt;#-&gt;# MB, # MB goal, # P 含义 1234567gc # GC次数的编号，每次GC时递增@#s 距离程序开始执行时的时间#% GC占用的执行时间百分比#+...+# GC使用的时间#-&gt;#-&gt;# MB GC开始，结束，以及当前活跃堆内存的大小，单位M# MB goal 全局堆内存大小# P 使用processor的数量 如果每条信息最后，以(forced)结尾，那么该信息是由runtime.GC()调用触发 我们来选择其中一行来解释一下： 1gc 17 @0.149s 1%: 0.004+36+0.003 ms clock, 0.009+0/0.051/36+0.006 ms cpu, 181-&gt;181-&gt;101 MB, 182 MB goal, 2 P 该条信息含义如下： ● gc 17: Gc 调试编号为17● @0.149s:此时程序已经执行了0.149s● 1%: 0.149s中其中gc模块占用了1%的时间● 0.004+36+0.003 ms clock: 垃圾回收的时间，分别为STW（stop-the-world）清扫的时间+并发标记和扫描的时间+STW标记的时间● 0.009+0/0.051/36+0.006 ms cpu: 垃圾回收占用cpu时间● 181-&gt;181-&gt;101 MB： GC开始前堆内存181M， GC结束后堆内存181M，当前活跃的堆内存101M● 182 MB goal: 全局堆内存大小● 2 P: 本次GC使用了2个P(调度器中的Processer) 了解了GC的调试信息读法后，接下来我们来分析一下本次GC的结果。 我们还是执行GODEBUG调试 1GODEBUG='gctrace=1' ./snippet_mem 结果如下 12345678910111213141516171819202122232425262728➜ study git:(main) ✗ GODEBUG='gctrace=1' ./main2022/05/06 10:16:30 Start.2022/05/06 10:16:30 ===&gt; loop begin.gc 1 @0.001s 3%: 0.008+0.42+0.002 ms clock, 0.017+0/0.10/0.33+0.004 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 2 Pgc 2 @0.002s 2%: 0.006+1.6+0.003 ms clock, 0.012+0/0.10/0.59+0.006 ms cpu, 4-&gt;6-&gt;3 MB, 5 MB goal, 2 Pgc 3 @0.004s 2%: 0.007+1.4+0.001 ms clock, 0.014+0/0.10/1.3+0.003 ms cpu, 8-&gt;8-&gt;2 MB, 9 MB goal, 2 Pgc 4 @0.006s 3%: 0.017+0.49+0.001 ms clock, 0.034+0.11/0/0+0.003 ms cpu, 6-&gt;6-&gt;3 MB, 7 MB goal, 2 Pgc 5 @0.007s 9%: 0.32+0.54+0.001 ms clock, 0.65+0.020/0.41/0+0.003 ms cpu, 8-&gt;8-&gt;4 MB, 9 MB goal, 2 Pgc 6 @0.008s 7%: 0.006+2.5+0.002 ms clock, 0.013+0.005/0.075/2.4+0.005 ms cpu, 10-&gt;10-&gt;5 MB, 11 MB goal, 2 Pgc 7 @0.011s 9%: 0.024+2.5+0.003 ms clock, 0.048+0.020/0.91/0+0.006 ms cpu, 12-&gt;12-&gt;6 MB, 13 MB goal, 2 Pgc 8 @0.014s 9%: 0.11+1.7+0.001 ms clock, 0.23+0.10/0/0+0.003 ms cpu, 15-&gt;15-&gt;8 MB, 16 MB goal, 2 Pgc 9 @0.016s 7%: 0.007+5.4+0.004 ms clock, 0.015+0/0.074/5.1+0.008 ms cpu, 19-&gt;19-&gt;10 MB, 20 MB goal, 2 Pgc 10 @0.021s 6%: 0.007+1.4+0.002 ms clock, 0.014+0/0.076/1.2+0.005 ms cpu, 24-&gt;24-&gt;13 MB, 25 MB goal, 2 Pgc 11 @0.023s 6%: 0.007+3.0+0.003 ms clock, 0.014+0/0.083/2.9+0.007 ms cpu, 30-&gt;30-&gt;16 MB, 31 MB goal, 2 Pgc 12 @0.027s 14%: 0.050+9.4+0.004 ms clock, 0.10+0.012/7.2/0.009+0.008 ms cpu, 38-&gt;38-&gt;21 MB, 39 MB goal, 2 Pgc 13 @0.037s 13%: 0.007+2.7+0.003 ms clock, 0.014+0/0.091/2.5+0.006 ms cpu, 47-&gt;47-&gt;26 MB, 48 MB goal, 2 Pgc 14 @0.040s 17%: 0.084+5.8+0.003 ms clock, 0.16+0.021/5.3/0+0.007 ms cpu, 59-&gt;59-&gt;33 MB, 60 MB goal, 2 Pgc 15 @0.046s 26%: 0.027+19+0.004 ms clock, 0.054+0.022/19/0+0.009 ms cpu, 74-&gt;74-&gt;41 MB, 75 MB goal, 2 Pgc 16 @0.066s 24%: 0.007+5.2+0.003 ms clock, 0.014+0/0.11/4.9+0.007 ms cpu, 93-&gt;93-&gt;51 MB, 94 MB goal, 2 Pgc 17 @0.072s 27%: 0.008+10+0.005 ms clock, 0.017+0.010/10/0.010+0.010 ms cpu, 116-&gt;116-&gt;64 MB, 117 MB goal, 2 Pgc 18 @0.084s 18%: 0.007+40+0.005 ms clock, 0.015+0/0.080/39+0.010 ms cpu, 145-&gt;145-&gt;145 MB, 146 MB goal, 2 Pgc 19 @0.167s 10%: 0.016+59+0.004 ms clock, 0.032+0/0.082/58+0.009 ms cpu, 372-&gt;372-&gt;126 MB, 373 MB goal, 2 Pgc 20 @0.227s 12%: 0.34+15+0.015 ms clock, 0.69+0/14/0+0.030 ms cpu, 284-&gt;284-&gt;284 MB, 285 MB goal, 2 Pgc 2022/05/06 10:16:30 ===&gt; loop end.21 @0.3242022/05/06 10:16:30 force gc.s 5%: 0.014+198+0.003 ms clock, 0.029+0/0.089/198+0.006 ms cpu, 728-&gt;728-&gt;0 MB, 729 MB goal, 2 P2022/05/06 10:16:30 Done.gc 22 @0.523s 5%: 0.006+2.4+0.002 ms clock, 0.013+0/0.045/2.4+0.005 ms cpu, 0-&gt;0-&gt;0 MB, 4 MB goal, 2 P (forced) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374- 分析 先看在test()函数执行完后立即打印的gc 21那行的信息。&#96;728-&gt;728-&gt;0 MB, 729 MB goal&#96;表示垃圾回收器已经把729M的内存标记为非活跃的内存。再看下一个记录&#96;gc 22。0-&gt;0-&gt;0 MB, 4 MB goal&#96;表示垃圾回收器中的全局堆内存大小由729M下降为4M。- 结论1、在test()函数执行完后，demo程序中的切片容器所申请的堆空间都被垃圾回收器回收了。2、如果此时在top指令查询内存的时候，如果依然是800+MB，说明垃圾回收器回收了应用层的内存后，（可能）并不会立即将内存归还给系统。#### (3) runtime.ReadMemStats接下来我么换另一种方式查看内存的方式 利用 runtime库里的ReadMemStats()方法demo2.go&#96;&#96;&#96;gopackage mainimport ( &quot;log&quot; &quot;runtime&quot; &quot;time&quot;)func readMemStats() &#123; var ms runtime.MemStats runtime.ReadMemStats(&amp;ms) log.Printf(&quot; &#x3D;&#x3D;&#x3D;&gt; Alloc:%d(bytes) HeapIdle:%d(bytes) HeapReleased:%d(bytes)&quot;, ms.Alloc, ms.HeapIdle, ms.HeapReleased)&#125;func test() &#123; &#x2F;&#x2F;slice 会动态扩容，用slice来做堆内存申请 container :&#x3D; make([]int, 8) log.Println(&quot; &#x3D;&#x3D;&#x3D;&gt; loop begin.&quot;) for i :&#x3D; 0; i &lt; 32*1000*1000; i++ &#123; container &#x3D; append(container, i) if ( i &#x3D;&#x3D; 16*1000*1000) &#123; readMemStats() &#125; &#125; log.Println(&quot; &#x3D;&#x3D;&#x3D;&gt; loop end.&quot;)&#125;func main() &#123; log.Println(&quot; &#x3D;&#x3D;&#x3D;&gt; [Start].&quot;) readMemStats() test() readMemStats() log.Println(&quot; &#x3D;&#x3D;&#x3D;&gt; [force gc].&quot;) runtime.GC() &#x2F;&#x2F;强制调用gc回收 log.Println(&quot; &#x3D;&#x3D;&#x3D;&gt; [Done].&quot;) readMemStats() go func() &#123; for &#123; readMemStats() time.Sleep(10 * time.Second) &#125; &#125;() time.Sleep(3600 * time.Second) &#x2F;&#x2F;睡眠，保持程序不退出&#125; 这里我们， 封装了一个函数readMemStats()，这里面主要是调用runtime中的ReadMemStats()方法获得内存信息，然后通过log打印出来。 我们执行一下代码并运行 12345678910111213➜ study git:(main) ✗ go run demo2.go 2022/05/06 10:21:59 ===&gt; [Start].2022/05/06 10:21:59 ===&gt; Alloc:63872(bytes) HeapIdle:66592768(bytes) HeapReleased:66560000(bytes)2022/05/06 10:21:59 ===&gt; loop begin.2022/05/06 10:21:59 ===&gt; Alloc:238511072(bytes) HeapIdle:96509952(bytes) HeapReleased:96378880(bytes)2022/05/06 10:21:59 ===&gt; loop end.2022/05/06 10:21:59 ===&gt; Alloc:631416280(bytes) HeapIdle:173424640(bytes) HeapReleased:141795328(bytes)2022/05/06 10:21:59 ===&gt; [force gc].2022/05/06 10:21:59 ===&gt; [Done].2022/05/06 10:21:59 ===&gt; Alloc:51040(bytes) HeapIdle:804790272(bytes) HeapReleased:141795328(bytes)2022/05/06 10:21:59 ===&gt; Alloc:52064(bytes) HeapIdle:804782080(bytes) HeapReleased:141787136(bytes)2022/05/06 10:22:09 ===&gt; Alloc:52272(bytes) HeapIdle:804782080(bytes) HeapReleased:141795328(bytes)2022/05/06 10:22:19 ===&gt; Alloc:52416(bytes) HeapIdle:804782080(bytes) HeapReleased:202391552(bytes) 可以看到，打印[Done].之后那条trace信息，Alloc已经下降，即内存已被垃圾回收器回收。在2022/05/06 10:22:19的这条trace信息中，HeapReleased开始上升，即垃圾回收器把内存归还给系统。 另外，MemStats还可以获取其它哪些信息以及字段的含义可以参见官方文档 (4) pprof工具pprof工具支持网页上查看内存的使用情况，需要在代码中添加一个协程即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import( \"net/http\" _ \"net/http/pprof\")go func() &#123; log.Println(http.ListenAndServe(\"0.0.0.0:10000\", nil))&#125;()具体添加的完整代码如下：demo3.gopackage mainimport ( \"log\" \"runtime\" \"time\" \"net/http\" _ \"net/http/pprof\")func readMemStats() &#123; var ms runtime.MemStats runtime.ReadMemStats(&amp;ms) log.Printf(\" ===&gt; Alloc:%d(bytes) HeapIdle:%d(bytes) HeapReleased:%d(bytes)\", ms.Alloc, ms.HeapIdle, ms.HeapReleased)&#125;func test() &#123; //slice 会动态扩容，用slice来做堆内存申请 container := make([]int, 8) log.Println(\" ===&gt; loop begin.\") for i := 0; i &lt; 32*1000*1000; i++ &#123; container = append(container, i) if ( i == 16*1000*1000) &#123; readMemStats() &#125; &#125; log.Println(\" ===&gt; loop end.\")&#125;func main() &#123; //启动pprof go func() &#123; log.Println(http.ListenAndServe(\"0.0.0.0:10000\", nil)) &#125;() log.Println(\" ===&gt; [Start].\") readMemStats() test() readMemStats() log.Println(\" ===&gt; [force gc].\") runtime.GC() //强制调用gc回收 log.Println(\" ===&gt; [Done].\") readMemStats() go func() &#123; for &#123; readMemStats() time.Sleep(10 * time.Second) &#125; &#125;() time.Sleep(3600 * time.Second) //睡眠，保持程序不退出&#125; 我们正常运行程序，然后同时打开浏览器， 输入地址：http://127.0.0.1:10000/debug/pprof/heap?debug=1 浏览器的内容其中有一部分如下，记录了目前的内存情况 12345678910111213141516171819202122232425262728293031323334353637383940414243## runtime.MemStats# Alloc = 228248# TotalAlloc = 1293696976# Sys = 834967896# Lookups = 0# Mallocs = 2018# Frees = 671# HeapAlloc = 228248# HeapSys = 804913152# HeapIdle = 804102144# HeapInuse = 811008# HeapReleased = 108552192# HeapObjects = 1347# Stack = 360448 / 360448# MSpan = 28288 / 32768# MCache = 3472 / 16384# BuckHashSys = 1449617# GCSys = 27418976# OtherSys = 776551# NextGC = 4194304# LastGC = 1583203571137891390 场景3: 如何分析Golang程序的CPU性能情况？(1)性能分析注意事项● 性能分析必须在一个可重复的、稳定的环境中来进行。 ○ 机器必须闲置 ■ 不要在共享硬件上进行性能分析; ■ 不要在性能分析期间，在同一个机器上去浏览网页 ○ 注意省电模式和过热保护，如果突然进入这些模式，会导致分析数据严重不准确 ○ 不要使用虚拟机、共享的云主机，太多干扰因素，分析数据会很不一致； ○ 不要在 macOS 10.11 及以前的版本运行性能分析，有 bug，之后的版本修复了。 如果承受得起，购买专用的性能测试分析的硬件设备，上架。 ● 关闭电源管理、过热管理;● 绝不要升级，以保证测试的一致性，以及具有可比性。 如果没有这样的环境，那就一定要在多个环境中，执行多次，以取得可参考的、具有相对一致性的测试结果。 (2) CPU性能分析我们来用下面的代码进行测试 demo4.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( \"bytes\" \"math/rand\" \"time\" \"log\" \"net/http\" _ \"net/http/pprof\")func test() &#123; log.Println(\" ===&gt; loop begin.\") for i := 0; i &lt; 1000; i++ &#123; log.Println(genSomeBytes()) &#125; log.Println(\" ===&gt; loop end.\")&#125;//生成一个随机字符串func genSomeBytes() *bytes.Buffer &#123; var buff bytes.Buffer for i := 1; i &lt; 20000; i++ &#123; buff.Write([]byte&#123;'0' + byte(rand.Intn(10))&#125;) &#125; return &amp;buff&#125;func main() &#123; go func() &#123; for &#123; test() time.Sleep(time.Second * 1) &#125; &#125;() //启动pprof http.ListenAndServe(\"0.0.0.0:10000\", nil)&#125; 这里面还是启动了pprof的坚挺,有关pprof启动的代码如下 123456789101112import ( \"net/http\" _ \"net/http/pprof\")func main() &#123; //... //... //启动pprof http.ListenAndServe(\"0.0.0.0:10000\", nil)&#125; main()里的流程很简单,启动一个goroutine去无限循环调用test()方法,休眠1s. test()的流程是生成1000个20000个字符的随机字符串.并且打印. 我们将上面的代码编译成可执行的二进制文件 demo4(记住这个名字,稍后我们能用到) 1$ go build demo4.go 接下来我们启动程序,程序会无限循环的打印字符串. 接下来我们通过几种方式来查看进程的cpu性能情况. A. Web界面查看浏览器访问http://127.0.0.1:10000/debug/pprof/ 我们会看到如下画面 这里面能够通过pprof查看包括(阻塞信息、cpu信息、内存堆信息、锁信息、goroutine信息等等), 我们这里关心的cpu的性能的profile信息. 有关profile下面的英文解释大致如下: “CPU配置文件。您可以在秒GET参数中指定持续时间。获取概要文件后，请使用go tool pprof命令调查概要文件。” 所以我们要是想得到cpu性能,就是要获取到当前进程的profile文件,这个文件默认是30s生成一个,所以你的程序要至少运行30s以上(这个参数也可以修改,稍后我们介绍) 我们可以直接点击网页的profile,浏览器会给我们下载一个profile文件. 记住这个文件的路径, 可以拷贝到与demo4所在的同一文件夹下. B. 使用pprof工具查看pprof 的格式如下 go tool pprof [binary] [profile] binary: 必须指向生成这个性能分析数据的那个二进制可执行文件； profile: 必须是该二进制可执行文件所生成的性能分析数据文件。 binary 和 profile 必须严格匹配。 我们来查看一下: 12345678$ go tool pprof ./demo4 profileFile: demo4Type: cpuTime: Mar 3, 2020 at 11:18pm (CST)Duration: 30.13s, Total samples = 6.27s (20.81%)Entering interactive mode (type \"help\" for commands, \"o\" for options)(pprof) help可以查看一些指令,我么可以通过top来查看cpu的性能情况. 12345678910111213141516(pprof) topShowing nodes accounting for 8420ms, 84.79% of 9930ms totalDropped 116 nodes (cum &lt;= 49.65ms)Showing top 10 nodes out of 83 flat flat% sum% cum cum% 2190ms 22.05% 22.05% 4350ms 43.81% math/rand.(*Rand).Int31n 1530ms 15.41% 37.46% 5880ms 59.21% math/rand.(*Rand).Intn 1240ms 12.49% 49.95% 1240ms 12.49% sync.(*Mutex).Unlock (inline) 1130ms 11.38% 61.33% 1170ms 11.78% syscall.Syscall 610ms 6.14% 67.47% 2060ms 20.75% math/rand.(*lockedSource).Int63 550ms 5.54% 73.01% 7500ms 75.53% main.genSomeBytes 420ms 4.23% 77.24% 990ms 9.97% bytes.(*Buffer).Write 280ms 2.82% 80.06% 280ms 2.82% runtime.futex 240ms 2.42% 82.48% 240ms 2.42% runtime.usleep 230ms 2.32% 84.79% 230ms 2.32% runtime.memmove(pprof) 这里面有几列数据,需要说明一下. ● flat：当前函数占用CPU的耗时● flat：:当前函数占用CPU的耗时百分比● sun%：函数占用CPU的耗时累计百分比● cum：当前函数加上调用当前函数的函数占用CPU的总耗时● cum%：当前函数加上调用当前函数的函数占用CPU的总耗时百分比● 最后一列：函数名称 通过结果我们可以看出, 该程序的大部分cpu性能消耗在 main.getSomeBytes()方法中,其中math/rand取随机数消耗比较大. C. 通过go tool pprof得到profile文件我们上面的profile文件是通过web浏览器下载的,这个profile的经过时间是30s的,默认值我们在浏览器上修改不了,如果你想得到时间更长的cpu利用率,可以通过go tool pprof指令与程序交互来获取到 首先,我们先启动程序 1$./demo4 然后再打开一个终端 go tool pprof http://localhost:10000/debug/pprof/profile?seconds=60 这里制定了生成profile文件的时间间隔60s 等待60s之后, 终端就会有结果出来,我们继续使用top来查看. 123456789101112131415161718192021222324$ go tool pprof &lt;http://localhost:10000/debug/pprof/profile?seconds=60&gt;Fetching profile over HTTP from &lt;http://localhost:10000/debug/pprof/profile?seconds=60&gt;Saved profile in /home/itheima/pprof/pprof.demo4.samples.cpu.005.pb.gzFile: demo4Type: cpuTime: Mar 3, 2020 at 11:59pm (CST)Duration: 1mins, Total samples = 12.13s (20.22%)Entering interactive mode (type \"help\" for commands, \"o\" for options)(pprof) topShowing nodes accounting for 9940ms, 81.95% of 12130ms totalDropped 110 nodes (cum &lt;= 60.65ms)Showing top 10 nodes out of 56 flat flat% sum% cum cum% 2350ms 19.37% 19.37% 4690ms 38.66% math/rand.(*lockedSource).Int63 1770ms 14.59% 33.97% 1770ms 14.59% sync.(*Mutex).Unlock (inline) 1290ms 10.63% 44.60% 6040ms 49.79% math/rand.(*Rand).Int31n 1110ms 9.15% 53.75% 1130ms 9.32% syscall.Syscall 810ms 6.68% 60.43% 1860ms 15.33% bytes.(*Buffer).Write 620ms 5.11% 65.54% 6660ms 54.91% math/rand.(*Rand).Intn 570ms 4.70% 70.24% 570ms 4.70% runtime.procyield 500ms 4.12% 74.36% 9170ms 75.60% main.genSomeBytes 480ms 3.96% 78.32% 480ms 3.96% runtime.memmove 440ms 3.63% 81.95% 440ms 3.63% math/rand.(*rngSource).Uint64(pprof) 依然会得到cpu性能的结果, 我们发现这次的结果与上次30s的结果百分比类似. D.可视化查看我们还是通过 1go tool pprof ./demo4 profile 进入profile文件查看,然后我们输入web指令. 123456$ go tool pprof ./demo4 profileFile: demo4Type: cpuTime: Mar 3, 2020 at 11:18pm (CST)Duration: 30.13s, Total samples = 6.27s (20.81%)Entering interactive mode (type \"help\" for commands, \"o\" for options)(pprof) web 这里如果报找不到graphviz工具,需要安装一下 Ubuntu安装 1$sudo apt-get install graphviz Mac安装 1brew install graphviz windows安装 下载https://graphviz.gitlab.io/_pages/Download/Download_windows.html 将graphviz安装目录下的bin文件夹添加到Path环境变量中。 在终端输入dot -version查看是否安装成功。 然后我们得到一个svg的可视化文件在/tmp路径下 这样我们就能比较清晰的看到函数之间的调用关系,方块越大的表示cpu的占用越大. 参考最常用的调试 golang 的 bug 以及性能问题的实践方法","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://fengyuwsuong.cn/tags/golang/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"编程","slug":"编程","permalink":"https://fengyuwsuong.cn/tags/%E7%BC%96%E7%A8%8B/"},{"name":"问题排查","slug":"问题排查","permalink":"https://fengyuwsuong.cn/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}]},{"title":"简单讲讲一次http请求中的网络流程","slug":"http请求的网络流程","date":"2022-04-28T09:20:58.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2022/04/28/http请求的网络流程/","link":"","permalink":"https://fengyuwsuong.cn/2022/04/28/http%E8%AF%B7%E6%B1%82%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B/","excerpt":"引言平时无论是生活，还是工作中。我们浏览网页都逃不开一个个的http请求，同时在面试上也经常会被问及：简单说说一次http请求的整个流程？下面也是基于这个点，结合已掌握的知识，这里把相关的流程简单讲一下。","text":"引言平时无论是生活，还是工作中。我们浏览网页都逃不开一个个的http请求，同时在面试上也经常会被问及：简单说说一次http请求的整个流程？下面也是基于这个点，结合已掌握的知识，这里把相关的流程简单讲一下。 1. 获取IP 静态配置 动态配置（DHCP） 后续续约流程重复流程3、4即可。 2. 域名解析浏览器缓存-&gt;系统缓存【本地dns解析】-&gt;请求dns服务器 思考题： dns用途： 域名解析 负载均衡【内部&amp;全局(GSLB)运营商+地域等】 传统dns协议VS httpdns 缓存问题 域名转发 出口NAT问题 域名更新 延迟问题 3. 判断目标机器是否在同一个局域网内 CIDR网络无类型域间选路（CIDR）例如：10.100.122.2/24网段：10.100.122.2 广播地址：10.100.122.255 子网掩码：255.255.255.0 思考题 跨网段的请求，应该要怎么发起？如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。 4. 获取网关MAC地址ARP协议 思考题： mac层用来解决什么问题的？ 多个交换机arp会出现什么问题，怎么解决？【环路】 5. TCP链接 思考题： 为什么需要三次握手？ 握手除了建立连接，还做了哪个比较重要的事情？ 6. 构建报文发起请求的第一步，应该是构建需要发出去的报文，基于网络5层协议，当我们准备发出一个HTTP报文的时候，整个报文的构建应该是基于网络协议自顶向下进行构建的。 以一个简单的http报文为例，首先他应该是先构建HTTP报文 应用层：http请求报文构建 运输层：数据报 网络层：ip帧`` 数据链路层：MAC帧 物理层：二进制流 整体包： 7. 报文在网络中应该如何转发- 无nat模式 服务器A发送请求到服务器B包内容应依序为： 序号 源ip 源mac 目标ip 目标mac 备注 1 192.168.1.101 服务器A的mac地址 192.168.4.101 网关192.168.1.1的mac地址 网段不同，修改mac地址发到网关 2 192.168.1.101 192.168.56.1的mac地址 192.168.4.101 网关192.168.56.2的mac地址 查询本机路由表，下一跳为192.168.56.2的交换机，arp查询该机器mac地址 3 192.168.1.101 网关192.168.4.1的mac地址 192.168.4.101 服务器B的mac地址 查询路由表或arp，转发到目标服务器B - 有nat模式局域网之间无协商，各定各的网段，存在ip段冲突。 服务器A发送请求到服务器B包内容应依序为： 序号 源ip 源mac 目标ip 目标mac 备注 1 192.168.1.101 服务器A的mac地址 192.168.56.2 网关192.168.1.1的mac地址 网段不同，修改mac地址发到网关 2 192.168.56.1 192.168.56.1的mac地址 192.168.56.2 网关192.168.56.2的mac地址 修改源ip，以交换机ip发送请求到网关192.168.56.2 nat过程中，网络包从局域网转发时，需要变更源ip，否则无法确认身份 3 192.168.56.1 网关192.168.1.1的mac地址 192.168.1.101 服务器B的mac地址 网关根据NAT配置，来源ip是192.168.56.2的通通转发到服务器B 思考题： 以上介绍的nat方式是使用中间局域网身份方式进行映射，那么存在ip耗尽的危险，目前是如何规避的呢？【NAPT】 8. 路由转发第7点关于路由跳转描述都是很简单的场景（仅一条映射关系），但是在实际的网络世界上要复杂很多，一旦出了网关，会面临很多的路由，需要如何选择更快速的通道？ 静态路由策略 动态路由策略 距离矢量算法【维护到任意路由的距离路由表，定期广播所有路由表】（BGP：外网路由协议） 收敛慢【包含路径解决】 发送需广播全部路由表【不适用于大型网络规模】 链路状态路由算法【根据收包的方式计算临近路由距离,可维护一个完整的图，然后使用Dijkstra算法计算最短路径】（OSPF：内部网关协议） 扩展思考读完上文，大家对发起一个请求协议在网络中的流转流程应该有了大致的了解，那么这里再简单拓展一下提问： 为什么有了ip还需要mac地址？ https应该加上哪些流程？ 移动设备的ip怎么获取的？ 有哪些技术是用于服务端相应提升的？ …………. 参考文档http协议文档: https://developer.mozilla.org/en-US/docs/Web/HTTP极客时间课-趣谈网络协议：https://time.geekbang.org/column/intro/100007101","categories":[{"name":"编程","slug":"编程","permalink":"https://fengyuwsuong.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://fengyuwsuong.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://fengyuwsuong.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"ipad编程体验","slug":"ipad编程体验","date":"2021-12-25T03:00:13.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2021/12/25/ipad编程体验/","link":"","permalink":"https://fengyuwsuong.cn/2021/12/25/ipad%E7%BC%96%E7%A8%8B%E4%BD%93%E9%AA%8C/","excerpt":"背景由于之前买的16寸mac太大太重了，同时看到有许多同事有使用ipad等平板设备进行办公，在这个念头的驱动下，摆脱又大又重的笔记本的想法越来越强烈，故在双十一一冲动则入手了ipad pro2021 11寸M1款，并且也上手在公司使用了一段时间，平时开会&amp;技术方案评审等表现都尚可，总体来说还是十分满意～ 最近有些事情需要回家一趟，遂想着vscode本身也是基于Node.js与Chromium进行搭建的，故理论上应该能够在我的云服务器上搭建一个vscode服务器，同时使用浏览器进行访问使用vscode，在网上搜索了一下果不其然有相关的方案，故下面介绍一下vscode服务器版code-server的搭建以及在ipad上编码的感受～","text":"背景由于之前买的16寸mac太大太重了，同时看到有许多同事有使用ipad等平板设备进行办公，在这个念头的驱动下，摆脱又大又重的笔记本的想法越来越强烈，故在双十一一冲动则入手了ipad pro2021 11寸M1款，并且也上手在公司使用了一段时间，平时开会&amp;技术方案评审等表现都尚可，总体来说还是十分满意～ 最近有些事情需要回家一趟，遂想着vscode本身也是基于Node.js与Chromium进行搭建的，故理论上应该能够在我的云服务器上搭建一个vscode服务器，同时使用浏览器进行访问使用vscode，在网上搜索了一下果不其然有相关的方案，故下面介绍一下vscode服务器版code-server的搭建以及在ipad上编码的感受～ code-server官方介绍code-server是运行代码服务器的最佳场所，它在您的浏览器或桌面中提供 Visual Studio Code 作为渐进式 Web 应用程序。由数以万计的个人开发人员使用，代码服务器使在任何设备上的任何浏览器中运行 VS Code 成为可能——由任何规模的服务器提供支持。当打包在 Coder 工作区中时，代码服务器为开发团队提供无缝的 VS Code 体验，感觉像是原生的，并以您的云提供的速度和可扩展性为后盾。 搭建搭建方式有多种，这里面简单介绍一下docker以及普通rpm部署。安装文档：https://coder.com/docs/code-server/latest/install docker1docker run -itd -u root -p 18888:8080 --name code-server -v $CODE&#x2F;config.yaml:&#x2F;data&#x2F;apps&#x2F;docker&#x2F;code-server-data&#x2F;config.yaml codercom&#x2F;code-server docker部署后进入vscode使用的终端为docker内部bash，除非多人使用，否则不太推荐使用docker部署。 rpm123curl -fOL https:&#x2F;&#x2F;github.com&#x2F;coder&#x2F;code-server&#x2F;releases&#x2F;download&#x2F;v3.12.0&#x2F;code-server-3.12.0-amd64.rpmsudo systemctl enable --now code-server@$USER# Now visit http:&#x2F;&#x2F;127.0.0.1:8080. Your password is in ~&#x2F;.config&#x2F;code-server&#x2F;config.yaml 访问config.yaml 1234bind-addr: 127.0.0.1:8080auth: passwordpassword: xxxxcert: false config.yaml文件为登录code-server网页需要的配置的密钥，映射好后登录后查看相关密码输入即可进入界面。 此时访问服务对应端口号应该就能进入到服务（没尝试过），但是为了达到ipad访问的目的，我们还需要通过nginx给服务设置反向代理,绑定域名以及证书进行访问，nginx location相关配置如下： code-server.conf 123456789101112131415161718192021222324252627282930313233#PROXY-START&#x2F;location ~* \\.(gif|png|jpg|css|js|woff|woff2)$&#123; proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header REMOTE-HOST $remote_addr; expires 12h;&#125;location &#x2F;&#123; proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header REMOTE-HOST $remote_addr; add_header X-Cache $upstream_cache_status; #Set Nginx Cache proxy_ignore_headers Set-Cookie Cache-Control expires; proxy_cache cache_one; proxy_cache_key $host$uri$is_args$args; proxy_cache_valid 200 304 301 302 1m; # websocket config 此处需加wss配置，否则进入会提示websocket建立超时 proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection upgrade; proxy_set_header Accept-Encoding gzip;&#125;#PROXY-END&#x2F; ipad使用技巧 使用safari浏览器打开对应code-server网页,点击右上角导出添加到主屏幕 键盘相关设置和输入法切换需要修改一下，否则一直会有下面横跳出现很难受 感受环境机器负载并不大，对于个人使用上来说一定是满足的了，在编码体验上总的来说还是能勉强够用的，当网络条件不允许远程的情况下，使用这个vscode编码进行简单的学习和工作还是十分惬意，也满足了当前情况我对于这个ipad生产力的需求～ 例如目前这篇文章就是在这个环境下进行的，感觉还是挺有意思的哈～以后如果是几天的假期应该是能完全摆脱mac和家里的台式机了。 在家使用ipad写这个文章 在高铁上编码 缺陷 有些快捷键缺失，很影响编程感受，例如ctrol+tab切换tab 中文输出法无法使用快捷键 切换进程再切回vscode时，键盘输出有时不响应，需要切到其他tab或删除文本操作重新调出键盘才行 vscode用户无法登录，没办法同步配置 markdown无法侧边预览 官网相关使用建议 相关设备及依赖 ipad pro 罗技k380键盘 罗技pabble无线鼠标 腾讯云服务2c4g 后续看了下相关介绍，目前Jetbrains也有类似的产品Projector支持，但是看使用体验上来说好像都是半斤八两，后续有机会再折腾一下试试，毕竟目前goland可是上班吃饭的家伙，如果能完美支持远程使用就好了～","categories":[{"name":"折腾","slug":"折腾","permalink":"https://fengyuwsuong.cn/categories/%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"折腾","slug":"折腾","permalink":"https://fengyuwsuong.cn/tags/%E6%8A%98%E8%85%BE/"},{"name":"搭建","slug":"搭建","permalink":"https://fengyuwsuong.cn/tags/%E6%90%AD%E5%BB%BA/"}]},{"title":"三亚旅游","slug":"三亚旅游-2021","date":"2021-04-27T14:41:41.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2021/04/27/三亚旅游-2021/","link":"","permalink":"https://fengyuwsuong.cn/2021/04/27/%E4%B8%89%E4%BA%9A%E6%97%85%E6%B8%B8-2021/","excerpt":"由于公司有3k的旅游和两天的旅游假，所以在公司的组织下在意外中报名了去三亚旅游，总的来说也算是难的休闲了几天，下面记录一下那几天的游记做下备份~","text":"由于公司有3k的旅游和两天的旅游假，所以在公司的组织下在意外中报名了去三亚旅游，总的来说也算是难的休闲了几天，下面记录一下那几天的游记做下备份~ 出发 （2021/04/22 周四）由于我们的机票是22号周四晚上7点20的，所以那天我们在4点就在公司附近集合准备去机场了，不得不说搭飞机真麻烦，需要提前三个多钟就出发（然而回来的经历告诉我这还算好的了🤣） 前往三亚的机票 托运行李 就这样我们抱着兴奋和期待的心情在9点半左右到达了三亚，于10点20分左右到达了居住的酒店- 这里我忘记拍照片了，所以这里没有记录，只能找下网上的图片凑合凑合了。 三亚金莎唐酒店附近，从2016年的百度导航实景来看还是挺县城级别的（这里也算是三亚的郊区）😂 由于当晚去到太晚了，大家都没有吃东西，于是大家组队在外面逛了一下，本来想在外面找下大排档一块去吃，走了1.5公里左右都没找着，最后决定吃沙县小吃。（谁也没想到去到三亚吃的第一餐居然是沙县🤣） 附近的沙县小吃（可以猜猜多少钱） 出人意料的是三亚还有挺多隆江猪脚饭，果然不努力就只有干不完的活和吃不完的隆江猪脚饭😅 蜈支洲岛 （2021/04/23 周五）早上第二天起床出阳台看了下酒店配套和风景还是很好的，看了下美团一晚400+左右。 酒店阳台早上8点左右实拍 酒店自助早餐 上午-下午洗漱完毕和用完早餐后，我们就继续乘坐约一个钟左右大巴车去三亚最出名的岛屿，蜈支洲岛了。以下是百度百科介绍： 蜈支洲岛坐落在海南省三亚市北部的海棠湾内，北面与南湾猴岛遥遥相对，南邻美誉天下第一湾的亚龙湾。蜈支洲岛距海岸线2.7公里，方圆1.48平方公里，呈不规则的蝴蝶状，东西长1400米，南北宽1100米。 距三亚市30公里，凤凰机场38公里，紧靠海口至三亚的高速公路，位置优越，交通便利。蜈支洲岛是海南岛周围为数不多的有淡水资源和丰富植被的小岛，有二千多种植物，种类繁多。 排队上岛拍婚纱照的准新娘 排队上岛（由于旅行社的原因，上岛我们不需要排队） 登船，导游说没坐过船的要做后面，否则会晕船（上去的时候已经没位置选择了，只能坐前面，但好像也不咋的🤣） 上岛，非节假日还到处都是人😥 上岛后，导游发了餐票并且带我们到餐厅后就是自由活动了，由于近视我没有玩海上项目，所以就只能在岛上到处逛，最后走完整个岛还剩半个钟就提前下岛等车回去了，总的来说不玩项目的话和普通公园差不多😂。 海上项目价格表 排队吃自助餐（99元），吃的东西忘记拍了（人山人海🤣） 海上风景 因为这里曾被解放军征用作为战略防御的重点地区，所以环境之类的保护都还挺好。 草泥马（我认为拍的最不错的一张照片之一哈哈😎） 海边拍照（难以想象几个直男在那拍照哈哈） 这张也不错🤣 拍婚纱照的情侣 下岛岸边 一起拍集体照 于是蜈支洲岛一天的行程大概这样就结束啦，总的来说去那边有机会还是体验一下海上项目，不然像我们这样干走还是挺无聊的~特别是对于我这个在海边长大的孩子没啥新奇感🤣 晚上旅行社的预算分配好像有点问题，晚上的吃饭预算只有人均30，最后去了个小饭店做的菜不是很好吃，大家都没啥胃口吃😅，这里没拍到照片，大概就靠脑补吧~ 吃晚饭重新乘坐大巴车回到酒店已经是晚上了，和同事一块下酒店体验了一下酒店的泳池，游了一个钟左右，然后上去洗完澡又去海边逛了一下，于是就结束了在三亚的第二天~ 悠闲的三亚当地居民（感觉在那边生活应该挺不错，生活节奏特别慢~） 酒店边的海滩（与家乡里需要出海捕鱼的海滩相比保护的还是很好的） 海的那边是敌人🤣 海边餐厅 大小洞天-三亚免税店（2021/04/24 周六）上午上午我们的行程是去三亚的知名景点-大小洞天，下面是百度百科的介绍： 大小洞天风景区，原名海山奇观风景区，古称鳌山大小洞天，位于海南省三亚市区以西40公里的南山西南隅，总面积为22.5平方公里，景区已有800多年历史，是著名的道教文化风景区。 大小洞天风景区以其秀丽的海景、山景和石景号称琼崖第一山水名胜。风景区内仍有“小洞天”、“钓台”、“海山奇观”、“仙人足”、“试剑峰”等历代诗文摩崖石刻。山、海、林泉是构成一个旅游名胜必不可少的条件。这里，崖州湾弧弦百里，碧波万倾；鳌山云深林翠，岩奇洞幽；海岸遍布神工鬼斧，肖形状物之大小磊群；山海之间宛如一幅古朴雄壮的长卷画图。 门口景点，也有很多人在这拍婚纱照 专业导游🤣 景点自助餐（也不是很好吃，但是胜在不贵，好像是68块） 其他地方都是海了，也没啥好看的了~ 下午下午去的是三亚免税店，看了电子产品还没有PDD便宜，PDD yyds好吧🤣 免税店 帮忙排队，一堆购物单 晚上由于大家购物热情好像都不是很强烈，所以天还亮的时候就回到了别墅酒店入住了。这次入住的酒店是三亚半岭温泉海韵别墅度假酒店，6个人住一个三居别墅，给我的感觉就是进了B站那种别人带看的豪宅，有钱人的世界是真的丰富多彩😂穷人还是缺乏想象力了。 不是我能住的起的价格🤣 大厅 一楼庭院（泳池+温泉） 大学毕业以后首次玩狼人杀 一大早起床打王者的大佬🤣 别墅部分就先到此为止~ 晚上我们还去吃了三亚当地的海鲜市场，吃到了当地地道的海鲜~这里需要感谢某位大佬的款待😇 三亚海鲜套餐（没有吧石斑拍进去，疏忽了🤣） 回来的时候翻车了，打车打到了半岭温泉中心，距离住的地方还有2公里。最后还得走路加翻墙回去，真是一次难忘的旅程呢🤣 小黄鸭翻车现场 三亚不夜城-回家（2021/04/25 周日）最后一天的行程原计划是直升机+去三亚不夜城豪生潜水，但是由于海南举办博鳌会议所以禁飞，就在酒店待到了中午在出发去不夜城潜水。 下午中午的吃饭又是去了30块人均的地方吃饭，体验相当不好~特别是旁边卖鱼仔的服务源又重复了一次推销流程让我感觉像是游戏重新读了档，怀疑昨天还没过去 人均30元的中午饭（很难想象旅游还能吃上这么便宜的饭菜，虽然特别难吃🤣） 潜水 同事的小孩，挺可爱的~ 潜水的体验也不是很好，近视啥也看不清🤣救生员在旁边不停推销拍照片和视频，体验过后感觉也就那样了吧~ 整个三亚不夜城没什么好玩的，不知道是不是白天过去的缘故，感觉人不多有点荒凉，最后在KFC坐了1个钟然后吃了椰子鸡就回家啦~ 回程回去的时候由于旅行社没沟通好，最后大巴进不了机场，走了接近半个钟才找到大巴，2点才回到我的城中村小窝，也算是一种难得的体验啦~🤣 飞机上 12点多在机场找大巴 总结总的来说三亚作为一个旅游景点，还是很适合没有经常见过大海的朋友的，像我这种在海边长大的孩子已经没感觉的到啥惊喜了~ 所以整个行程只能说中规中矩，在意料之中吧~ 整个旅程中居住的酒店都还不错算是加分项，但是那个30块人均的午餐是真的太难吃了🤣 三亚的海鲜还是很值得去试试的，价格来说也不算特别的贵吧。 说起来中间和司机唠叨才知道原来海南话就是我家乡那边的话，亲切感up+ 在海南三亚生活的当地居民感觉挺幸福的，小日子过得特别悠闲，不像在大城市里面特别匆忙。希望以后自己也能过上这样的生活吧~ 附带一下家乡的海哈哈~ 拍摄于2021年农历初一 这和三亚相比好像也差不了多少？🤣 后记回到家后发现养的栀子花又开了一朵，幸福感up！ 回来第二天晚上去吃了老地方小排挡，同事说还是地道广东菜好吃，比酒店的好吃多了哈哈","categories":[{"name":"生活","slug":"生活","permalink":"https://fengyuwsuong.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"旅游","slug":"旅游","permalink":"https://fengyuwsuong.cn/tags/%E6%97%85%E6%B8%B8/"},{"name":"三亚","slug":"三亚","permalink":"https://fengyuwsuong.cn/tags/%E4%B8%89%E4%BA%9A/"}]},{"title":"leetcode-15.3Sum","slug":"leetcode-15.-3Sum","date":"2020-05-17T02:27:05.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2020/05/17/leetcode-15.-3Sum/","link":"","permalink":"https://fengyuwsuong.cn/2020/05/17/leetcode-15.-3Sum/","excerpt":"题目12345678910111213141516171819Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目12345678910111213141516171819Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路1. 暴力解法假设三个数字分别为 x, y, z。 那么可知 x + y + z = 0，由此可以通过三层遍历依次确定每个数值即可（确保不会出现重复，需要将数组排序）。 需要注意的是每个解的三个数值必须不同， 当x ，y确定时， z符合目标的仅需遍历一次，x，y不可与上次符合的重复。 该解法不够优雅，特殊情况太多if判断，时间复杂度o(n^3)。 2. 利用hash表获取第三人由于 x + y + z = 0，那么我们可以维护一个hash表，确定需要的x值是否存在 =&gt; x = 0 - y -z，设为 hash[0 - y - z] = [y, z]， 不存在则 hash[x] = nil. 可以先通过二维遍历整个数组确定x、y值、以及维护一个hash表， 则可将时间复杂度降低为 O(n^2)。 3. 双指针可以先对数组进行排序，然后取中间的任意一个数 x，那么有 x + y + z = 0可知（由于排序后， z &gt;= y &gt;= x）， 那么x必然在y左边，z必然在y右边。那么就可以通过双指针依次遍历即可得到解。 12345x =&gt; nums[i]y =&gt; nums[i + 1] z =&gt; nums[len(nums)-1] 当 x + y + z &gt; 0，说明 z 值过大，指针左移； 当 x + y + z &lt; 0，说明x值过小，指针右移。 当 两者相遇时退出 x = nums[i] 循环。 优化点&amp;特殊情况考虑： 需考虑x值重复情况，例如 [0, 0 , 0, 10情况，x值取两次0必然会重复得出结果 [0, 0, 0]。 由于 x + y + z == 0，那么 x/y/z必然符号不可能相同（0除外）； 必然不存在 x &gt; 0 的情况。 时间复杂度 O(nlogn) 代码1. 暴力解12345678910111213141516171819202122232425func threeSum(nums []int) [][]int &#123; sort.Ints(nums) var x, y, z int var res [][]int for i := 0; i &lt; len(nums); i++ &#123; if i != 0 &amp;&amp; x == nums[i] &#123; continue &#125; x = nums[i] for j := i + 1; j &lt; len(nums); j++ &#123; if j &gt; i+1 &amp;&amp; nums[j] == nums[j-1] &#123; continue &#125; y = nums[j] z = 0 - x - y for k := j + 1; k &lt; len(nums); k++ &#123; if z == nums[k] &#123; res = append(res, []int&#123;x, y, z&#125;) break &#125; &#125; &#125; &#125; return res&#125; 2. hash表12345678910111213141516// hash表解法 不可ac 特殊情况未编写 如重复值func threeSum(nums []int) [][]int &#123; var res [][]int hash := make(map[int][]int) for i := 0; i &lt; len(nums)-2; i++ &#123; for j := i + 1; j &lt; len(nums)-1; j++ &#123; if hash[nums[j]] != nil &#123; res = append(res, append(hash[nums[j]], nums[j])) continue &#125; // hash表不存在则两个人x, y 组队 hash[0-nums[j]-nums[i]] = []int&#123;nums[j], nums[i]&#125; &#125; &#125; return res&#125; 3. 双指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 双指针func threeSum(nums []int) [][]int &#123; if len(nums) &lt; 3 &#123; return nil &#125; sort.Ints(nums) var res [][]int for i := 0; i &lt; len(nums)-1; i++ &#123; // x 值不可能大于0 if nums[i] &gt; 0 &#123; break &#125; left := i + 1 right := len(nums) - 1 for &#123; // left &gt;= right x z 不可能符号相同 时退出 if left &gt;= right || nums[i]*nums[right] &gt; 0 &#123; break &#125; data := nums[i] + nums[left] + nums[right] if data == 0 &#123; res = append(res, []int&#123;nums[left], nums[i], nums[right]&#125;) // 同一x值可能有不同结果 left + 1取其他情况 left++ for left &lt; right &amp;&amp; nums[left] == nums[left-1] &#123; left++ &#125; &#125; else if data &gt; 0 &#123; right-- for right &gt; left &amp;&amp; nums[right] == nums[right+1] &#123; right-- &#125; &#125; else &#123; left++ for left &lt; right &amp;&amp; nums[left] == nums[left-1] &#123; left++ &#125; &#125; &#125; //去除x值重复值情况 for i &lt; len(nums)-1 &amp;&amp; nums[i] == nums[i+1] &#123; i++ &#125; &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"如何高效的学习","slug":"如何高效的学习","date":"2020-05-16T14:27:05.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2020/05/16/如何高效的学习/","link":"","permalink":"https://fengyuwsuong.cn/2020/05/16/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"此文整理知乎回答怎么才能心无旁骛地学习？，希望自己以后能够更好的调整学习状态，保持自己的学习进度。","text":"此文整理知乎回答怎么才能心无旁骛地学习？，希望自己以后能够更好的调整学习状态，保持自己的学习进度。 1. 学习场所很重要在图书馆学习、在家学习、在宿舍学习，这三种学习效果是呈直线式递减的。如果个人专注力较差，前期可以先去图书馆学习，通过外界因素约束自己。 2. 学习前准备很重要在学习前不应该长时间玩手机、娱乐等。应先让大脑进行缓冲5-10分钟后，准备好学习状态后在进行学习，否则会由于情绪太过兴奋而学不进去。 3. 排除一切外接干扰学习前应排除一切外接干扰，如手机、游戏等，将一切干扰源排到最远。 4. 合理使用番茄时钟可使用番茄时钟25+5分钟的学习/休息时间，但是5分钟内最好不要接近诱惑干扰源。 5. 制定目标很重要学习前可制定今天的学习目标，如某本书看到40%，刷x道题。这样会更加具备学习动力。 6. 交替学习可以交替的学习不同知识，比如在学习一项知识2个钟后可以转移学习另一门知识，提高学习新鲜感，降低学习疲劳程度。 7. 绘画掌握知识脑图可以绘制个人掌握的知识思维脑图，了解自己的薄弱点，可以对已掌握知识做更好的总结。","categories":[{"name":"生活","slug":"生活","permalink":"https://fengyuwsuong.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://fengyuwsuong.cn/tags/%E7%94%9F%E6%B4%BB/"},{"name":"随笔","slug":"随笔","permalink":"https://fengyuwsuong.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"leetcode-69. Sqrt(x)","slug":"leetcode-69. Sqrt(x)","date":"2020-03-08T07:00:13.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2020/03/08/leetcode-69. Sqrt(x)/","link":"","permalink":"https://fengyuwsuong.cn/2020/03/08/leetcode-69.%20Sqrt(x)/","excerpt":"题目1234567891011121314151617181920Implement int sqrt(int x).Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:Input: 4Output: 2Example 2:Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sqrtx著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目1234567891011121314151617181920Implement int sqrt(int x).Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:Input: 4Output: 2Example 2:Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sqrtx著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路使用二分法求其根，注意使用 x/res &gt; res 来进行比较，如使用res * res &gt;=x 有溢出风险。 需考虑代码健壮性排除0、1。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package easyimport ( \"testing\")/**Implement int sqrt(int x).Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:Input: 4Output: 2Example 2:Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sqrtx著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/func mySqrt(x int) int &#123; if x &lt;= 1 &#123; return x &#125; min, max := 0, x for max-min != 1 &#123; res := (min + max) / 2 if x/res &gt;= res &#123; min = res continue &#125; max = res &#125; return min&#125;func TestMySqrt(t *testing.T) &#123; println(mySqrt(4)) println(mySqrt(8)) println(mySqrt(100))&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"leetcode-67. Add Binary","slug":"leetcode-67. Add Binary","date":"2020-03-08T05:57:13.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2020/03/08/leetcode-67. Add Binary/","link":"","permalink":"https://fengyuwsuong.cn/2020/03/08/leetcode-67.%20Add%20Binary/","excerpt":"题目12345678910111213141516Given two binary strings, return their sum (also a binary string).The input strings are both non-empty and contains only characters 1 or 0.Example 1:Input: a = \"11\", b = \"1\"Output: \"100\"Example 2:Input: a = \"1010\", b = \"1011\"Output: \"10101\"来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-binary著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目12345678910111213141516Given two binary strings, return their sum (also a binary string).The input strings are both non-empty and contains only characters 1 or 0.Example 1:Input: a = \"11\", b = \"1\"Output: \"100\"Example 2:Input: a = \"1010\", b = \"1011\"Output: \"10101\"来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-binary著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路根据题意解答即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package easyimport ( \"testing\")/**Given two binary strings, return their sum (also a binary string).The input strings are both non-empty and contains only characters 1 or 0.Example 1:Input: a = \"11\", b = \"1\"Output: \"100\"Example 2:Input: a = \"1010\", b = \"1011\"Output: \"10101\"来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-binary著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/func addBinary(a string, b string) string &#123; al := len(a) - 1 bl := len(b) - 1 needAdd := 0 var res string for ; al &gt;= 0 || bl &gt;= 0; al, bl = al-1, bl-1 &#123; if al &gt;= 0 &amp;&amp; bl &gt;= 0 &#123; aRes := rune2int(a[al]) bRes := rune2int(b[bl]) na, tRes := cal(aRes + bRes + needAdd) needAdd = na res = tRes + res continue &#125; if al &lt; 0 &#123; bRes := rune2int(b[bl]) na, tRes := cal(bRes + needAdd) needAdd = na res = tRes + res continue &#125; aRes := rune2int(a[al]) na, tRes := cal(aRes + needAdd) needAdd = na res = tRes + res &#125; if needAdd == 1 &#123; res = \"1\" + res &#125; return res&#125;func rune2int(r uint8) int &#123; if r == '1' &#123; return 1 &#125; return 0&#125;func cal(i int) (int, string) &#123; needAdd := 0 res := \"0\" switch i &#123; case 0: case 1: res = \"1\" case 2: needAdd = 1 case 3: needAdd = 1 res = \"1\" &#125; return needAdd, res&#125;func TestAddBinary(t *testing.T) &#123; println(addBinary(\"11\", \"1\")) println(addBinary(\"1010\", \"10110\"))&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"Plus One","slug":"leetcode-66-Plus One","date":"2020-03-08T05:51:13.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2020/03/08/leetcode-66-Plus One/","link":"","permalink":"https://fengyuwsuong.cn/2020/03/08/leetcode-66-Plus%20One/","excerpt":"题目1234567891011121314151617181920Given a non-empty array of digits representing a non-negative integer, plus one to the integer.The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.You may assume the integer does not contain any leading zero, except the number 0 itself.Example 1:Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Example 2:Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321.66来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/plus-one著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目1234567891011121314151617181920Given a non-empty array of digits representing a non-negative integer, plus one to the integer.The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.You may assume the integer does not contain any leading zero, except the number 0 itself.Example 1:Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Example 2:Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321.66来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/plus-one著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路依照题意解答即可，需注意当个位为9的时候，进位情况。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package easyimport \"testing\"/**Given a non-empty array of digits representing a non-negative integer, plus one to the integer.The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.You may assume the integer does not contain any leading zero, except the number 0 itself.Example 1:Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Example 2:Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321.66来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/plus-one著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/func plusOne(digits []int) []int &#123; for i := len(digits) - 1; i &gt;= 0; i-- &#123; digits[i]++ if digits[i] == 10 &#123; digits[i] = 0 continue &#125; break &#125; // 开头为0 需进位 if digits[0] == 0 &#123; digits = append(digits, 0) digits[0] = 1 &#125; return digits&#125;func TestPlusOne(t *testing.T) &#123; for _, i := range plusOne([]int&#123;1, 2, 3&#125;) &#123; println(i) &#125; for _, i := range plusOne([]int&#123;9&#125;) &#123; println(i) &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"leetcode-58-Length of Last Word","slug":"leetcode-58-Length of Last Word","date":"2020-02-23T03:35:13.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2020/02/23/leetcode-58-Length of Last Word/","link":"","permalink":"https://fengyuwsuong.cn/2020/02/23/leetcode-58-Length%20of%20Last%20Word/","excerpt":"题目1234567891011121314Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word (last word means the last appearing word if we loop from left to right) in the string.If the last word does not exist, return 0.Note: A word is defined as a maximal substring consisting of non-space characters only.Example:Input: \"Hello World\"Output: 5来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/length-of-last-word著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目1234567891011121314Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word (last word means the last appearing word if we loop from left to right) in the string.If the last word does not exist, return 0.Note: A word is defined as a maximal substring consisting of non-space characters only.Example:Input: \"Hello World\"Output: 5来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/length-of-last-word著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路从尾到头进行遍历，当遇到单词的下一个空格时退出遍历即可。 注意项后置多个空格的情况，取最后一个单词长度作为返回。 代码123456789101112131415161718192021222324252627282930313233343536373839404142package easyimport ( \"fmt\" \"testing\")/**Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word (last word means the last appearing word if we loop from left to right) in the string.If the last word does not exist, return 0.Note: A word is defined as a maximal substring consisting of non-space characters only.Example:Input: \"Hello World\"Output: 5来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/length-of-last-word著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/func lengthOfLastWord(s string) int &#123; var res int for i := len(s) - 1; i &gt;= 0; i-- &#123; if s[i] == ' ' &#123; if res == 0 &#123; continue &#125; break &#125; res++ &#125; return res&#125;func TestLengthOfLastWord(t *testing.T) &#123; fmt.Println(lengthOfLastWord(\"Hello World\")) fmt.Println(lengthOfLastWord(\"b a \"))&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"leetcode-53-Maximum Subarray","slug":"leetcode-53-Maximum-Subarray","date":"2020-02-22T03:55:13.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2020/02/22/leetcode-53-Maximum-Subarray/","link":"","permalink":"https://fengyuwsuong.cn/2020/02/22/leetcode-53-Maximum-Subarray/","excerpt":"题目1234567891011121314Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.Example:Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-subarray著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目1234567891011121314Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.Example:Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-subarray著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路求最大子序列和。 1. 暴力法双层for循环遍历所有子序列求和。时间复杂度O(n^2) 2. 动态规划动态规划重点在于写出隐含的推导公式。dp指当前索引的最大值。时间复杂度O(n)。 12# 当前节点最大值 = max(上一节点最大值 + 当前节点值, 当前节点值)Dp[i] = max(dp[i-1] +num[i], num[i]) 即当上一节点最大值为负数时，放弃之前节点，从当前节点开始。 3. 贪心法翻版动态规划，使用max变量记录最大值则无需dp数组。 4. 分治法时间复杂度O(nlog(n)) 将数组分为左右中三部分，左右分别可以通过递归到单个元素解决。重点在于求中间数组的子序列最大值。 其值等于左边部分的最右边开始的最大值 + 右边部分的最左边开始的最大值（与单独贪心不同，求和值必须是连续的,因为计算的是中间开始的子串的最大值）。 注意项建壮性编写 当数据为空时返回0 数组全是负数返回最小负数，初始化max使用负无穷或数组第一个元素。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package easyimport ( \"fmt\" \"testing\")/**Given an integer array nums, find the contiguous subarray (containing at least one number)which has the largest sum and return its sum.Example:Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-subarray著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/func maxInt(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;// 动态规划 重点为推导式 dp[i] = max(nums[i], dp[i-1] + nums[i]) dp为在每个位置上的最大子串和func maxSubArray(nums []int) int &#123; if len(nums) == 0 &#123; return 0 &#125; dp := make([]int, len(nums)) dp[0] = nums[0] for i := 1; i &lt; len(nums); i++ &#123; dp[i] = maxInt(nums[i], dp[i-1]+nums[i]) &#125; // 遍历dp数组查找遍历到那个节点中值最大 max := dp[0] for _, d := range dp &#123; max = maxInt(max, d) &#125; return max&#125;// 贪心法 实际为动态规划 使用max记录数组中最大值func maxSubArray2(nums []int) int &#123; if len(nums) == 0 &#123; return 0 &#125; sum, max := nums[0], nums[0] for i := 1; i &lt; len(nums); i++ &#123; sum = maxInt(nums[i], nums[i]+sum) max = maxInt(sum, max) &#125; return max&#125;// 分治法func maxSubArray3(nums []int) int &#123; // 递归出口 numsLen := len(nums) if numsLen == 0 &#123; return 0 &#125; if numsLen == 1 &#123; return nums[0] &#125; // 递归处理左边最大值 leftMax := maxSubArray3(nums[:numsLen/2]) // 递归处理右边最大值 rightMax := maxSubArray3(nums[numsLen/2:]) // 使用贪心法处理中间最大值 分别从 中心向左右拓张查找最大值 符合分治思路 // 中心往左最大值 leftStart := numsLen/2 - 1 lSum, lMax := nums[leftStart], nums[leftStart] for i := leftStart - 1; i &gt;= 0; i-- &#123; lSum = nums[i] + lSum // 此处应该直接相加 因为不能再从单前节点开始 中间往外拓展应是连续的 lMax = maxInt(lSum, lMax) &#125; // 中心往右最大值 rightStart := numsLen / 2 rSum, rMax := nums[rightStart], nums[rightStart] for i := rightStart + 1; i &lt; len(nums); i++ &#123; rSum = nums[i] + rSum rMax = maxInt(rSum, rMax) &#125; return maxInt(maxInt(leftMax, rightMax), lMax+rMax)&#125;func TestMaxSubArray(t *testing.T) &#123; fmt.Println(maxSubArray([]int&#123;-2, 1, -3, 4, -1, 2, 1, -5, 4&#125;)) fmt.Println(maxSubArray([]int&#123;-1&#125;)) fmt.Println(maxSubArray2([]int&#123;-2, 1, -3, 4, -1, 2, 1, -5, 4&#125;)) fmt.Println(maxSubArray3([]int&#123;-2, 1, -3, 4, -1, 2, 1, -5, 4&#125;))&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"Golang包管理笔记","slug":"golang包管理","date":"2020-02-18T15:00:13.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2020/02/18/golang包管理/","link":"","permalink":"https://fengyuwsuong.cn/2020/02/18/golang%E5%8C%85%E7%AE%A1%E7%90%86/","excerpt":"1. go get命令go get 命令可以借助代码管理工具通过远程拉取或更新代码包及其依赖包到gopath路径下，并自动完成编译和安装。整个过程就像安装一个 App 一样简单。example: 1go get github.com/spf13/viper 如上命令则是将github上中的viper包下载到本地gopath路径，在对应目录$gopath/src/github.com/sfp13/viper即可看到对应代码。 这个命令可以动态获取远程代码包，目前支持的有 BitBucket、GitHub、Google Code 和 Launchpad。在使用 go get 命令前，需要安装与远程包匹配的代码管理工具，如 Git、SVN、HG 等，参数中需要提供一个包名。 这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行 go install。 下载源码包的 go 工具会自动根据不同的域名调用不同的源码工具，对应关系如下： 名称 主命令 说明 Mercurial hg Mercurial是一种轻量级分布式版本控制系统，采用Python语言实现，易于学习和使用，扩展性强。 Git git Git最开始是Linux Torvalds为了帮助管理 Linux 内核开发而开发的一个开源的分布式版本控制软件。但现在已被广泛使用。它是被用来进行有效、高速的各种规模项目的版本管理。 Subversion svn Subversion是一个版本控制系统，也是第一个将分支概念和功能纳入到版本控制模型的系统。但相对于Git和Mercurial而言，它只算是传统版本控制系统的一员。 Bazaar bzr Bazaar是一个开源的分布式版本控制系统。但相比而言，用它来作为VCS的项目并不多。","text":"1. go get命令go get 命令可以借助代码管理工具通过远程拉取或更新代码包及其依赖包到gopath路径下，并自动完成编译和安装。整个过程就像安装一个 App 一样简单。example: 1go get github.com/spf13/viper 如上命令则是将github上中的viper包下载到本地gopath路径，在对应目录$gopath/src/github.com/sfp13/viper即可看到对应代码。 这个命令可以动态获取远程代码包，目前支持的有 BitBucket、GitHub、Google Code 和 Launchpad。在使用 go get 命令前，需要安装与远程包匹配的代码管理工具，如 Git、SVN、HG 等，参数中需要提供一个包名。 这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行 go install。 下载源码包的 go 工具会自动根据不同的域名调用不同的源码工具，对应关系如下： 名称 主命令 说明 Mercurial hg Mercurial是一种轻量级分布式版本控制系统，采用Python语言实现，易于学习和使用，扩展性强。 Git git Git最开始是Linux Torvalds为了帮助管理 Linux 内核开发而开发的一个开源的分布式版本控制软件。但现在已被广泛使用。它是被用来进行有效、高速的各种规模项目的版本管理。 Subversion svn Subversion是一个版本控制系统，也是第一个将分支概念和功能纳入到版本控制模型的系统。但相对于Git和Mercurial而言，它只算是传统版本控制系统的一员。 Bazaar bzr Bazaar是一个开源的分布式版本控制系统。但相比而言，用它来作为VCS的项目并不多。 1.1. 常用参数 标记名称 标记描述 -d 让命令程序只执行下载动作，而不执行安装动作。 -f 仅在使用-u标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里Fork过来的，那么这样做就尤为重要了。 -fix 让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装。 -insecure 允许命令程序使用非安全的scheme（如HTTP）去下载指定的代码包。如果你用的代码仓库（如公司内部的Gitlab）没有HTTPS支持，可以添加此标记。请在确定安全的情况下使用它。 -t 让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。 -u 让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。 -v 打印出那些下载的代码包的名字 -x 打印出整个过程使用的命令 1.2. 下载特定分支1go get 项目包路径@(分支名或提交id) # 默认go1版本 其次master 1.3. 手动导入包可手动到$gopath/src路径进行git clone等操作进行手动导入包。 1.4 常见错误由于http协议使用git系列操作的时候，需要输入密码，但是由于go默认不进行交互，所以还是会导致最终结果失败。错误如下： 12345get \"xxx.fengyuwusong.cn/basic_dev_libs/go_template\": found meta tag get.metaImport&#123;Prefix:\"xxx.fengyuwusong.cn/basic_dev_libs/go_template\", VCS:\"git\", RepoRoot:\"http://xxx.fengyuwusong.cn/basic_dev_libs/go_template.git\"&#125; at //xxx.fengyuwusong.cn/basic_dev_libs/go_template?go-get=1go get xxx.fengyuwusong.cn/basic_dev_libs/go_template: git ls-remote -q http://xxx.fengyuwusong.cn/basic_dev_libs/go_template.git in /Users/fengyuwusong/code/gopath/pkg/mod/cache/vcs/bf5a86f855b001622b2d2fe3a7b0447bf64efb8d09620ba2443dd04f7e0ffe44: exit status 128: fatal: could not read Username for 'http://xxx.fengyuwusong.cn': terminal prompts disabledConfirm the import path was entered correctly.If this is a private repository, see https://golang.org/doc/faq#git_https for additional information. 以上错误我们可以通过以下两种方式来解决： 1234567891011方案一临时解法：手动输入用户名密码env GIT_TERMINAL_PROMPT&#x3D;1 go get xxx.com&#x2F;xxx&#x2F;xxx方案二长期解法：使用已经配置好的git密钥以GITHUB为例git config --global --add url.&quot;git@github.com:&quot;.insteadOf &quot;https:&#x2F;&#x2F;github.com&#x2F;&quot; 2. govendorgolang工程的依赖包经常使用go get命令来获取，例如：go get github.com/kardianos/govendor ，会将依赖包下载到GOPATH的路径下。 常用的依赖包管理工具有godep，govendor等，在Golang1.5之后，Go提供了 GO15VENDOREXPERIMENT 环境变量(Go 1.6版本默认开启该环境变量)，用于将go build时的应用路径搜索调整成为 当前项目目录/vendor 目录方式。通过这种形式，我们可以实现类似于 godep 方式的项目依赖管理。 2.1. 安装1go get -u -v github.com/kardianos/govendor 2.2. 使用12345678910111213141516171819#进入到项目目录cd /home/gopath/src/mytool#初始化vendor目录govendor init#查看vendor目录[root@CC54425A mytool]# lscommands main.go vendor mytool_test.sh#将GOPATH中本工程使用到的依赖包自动移动到vendor目录中#说明：如果本地GOPATH没有依赖包，先go get相应的依赖包govendor add +external或使用缩写： govendor add +e #Go 1.6以上版本默认开启 GO15VENDOREXPERIMENT 环境变量，可忽略该步骤。#通过设置环境变量 GO15VENDOREXPERIMENT=1 使用vendor文件夹构建文件。#可以选择 export GO15VENDOREXPERIMENT=1 或 GO15VENDOREXPERIMENT=1 go build 执行编译export GO15VENDOREXPERIMENT=1 2.3. 常用命令常见的命令如下，格式为 govendor COMMAND。 命令 功能 init 初始化 vendor 目录 list 列出所有的依赖包 add 添加包到 vendor 目录，如 govendor add +external 添加所有外部包 add PKG_PATH 添加指定的依赖包到 vendor 目录 update 从 $GOPATH 更新依赖包到 vendor 目录 remove 从 vendor 管理中删除依赖 status 列出所有缺失、过期和修改过的包 fetch 添加或更新包到本地 vendor 目录 sync 本地存在 vendor.json 时候拉去依赖包，匹配所记录的版本 get 类似 go get 目录，拉取依赖包到 vendor 目录 包状态： 状态 缩写状态 缩写含义 +local l 本地包，项目自身的包组织 +external e 外部包，被$GOPATH管理，但不在vendor目录下 +vendor v 已被govendor管理的包，在vendor目录下 +std s 标准库的包 +unused u 未使用的包，即包在vendor目录下，但在项目中并没有使用 +missing m 代码应用了依赖包，但该包未找到 +program p 主程序包，可编译为执行文件 +outside 外部包或缺失的包 +all 所有包 example： 12# 将外部包打入vendor目录govendor add +e 3. go mod从 Go1.11 开始，golang 官方支持了新的依赖管理工具go mod。 其本质为将包下载到$gopath/pkg/mod目录 123~/code/gopath/pkg/mod: lscache github.com go.uber.org google.golang.org honnef.cocloud.google.com go.etcd.io golang.org gopkg.in 3.1. 常用命令123456789101112131415161718192021222324➜ ~ go modGo mod provides access to operations on modules. Note that support for modules is built into all the go commands,not just 'go mod'. For example, day-to-day adding, removing, upgrading,and downgrading of dependencies should be done using 'go get'.See 'go help modules' for an overview of module functionality. Usage: go mod &lt;command&gt; [arguments] The commands are: download download modules to local cache 下载包到本地缓存 edit edit go.mod from tools or scripts 编写go.mod 文件 graph print module requirement graph 打印依赖关系图 init initialize new module in current directory 初始化当前目录 tidy add missing and remove unused modules 添加丢失和移除无用的包 vendor make vendored copy of dependencies 打包vendor目录 verify verify dependencies have expected content 验证依赖内容 why explain why packages or modules are needed 解释为什么依赖此包 Use \"go help mod &lt;command&gt;\" for more information about a command. 3.2. 使用12345678910111213141516171819go mod init # 在项目目录下初始化 生成go.mod文件# build 和test会自动编辑go.mod文件 导入依赖包go build xxx.gogo test xxx.go# ... 编辑go.mod文件 导入你需要的包然后执行go mod download# 或进行以下命令 添加missing包及移除无用包go mod tidy # 打包到本地并部署go mod vendor# 其他命令go list -m all # 列出所有直接或间接使用的包的最终版本go list -u -m all # 查看所有可用于升级的补丁go get xxx # 导入需要的包 会自动编辑go.mod文件添加该包 3.3. 使用代理由于一些总所周知的原因，在国内有一些包是无法下载的，所以这时候需要设置第三方代理来对包进行拉取。 1234# 使用代理go env -w GOPROXY=\"https://goproxy.cn\"# 直连go env -w GOPROXY=\"direct\" 但是有一些包我们是存在自建仓库的，那么这时候需要设置GOPRIVATE跳过代理。 123go env -w GOPRIVATE=\"*.fengyuwusong.cn\"# 此时导入该包将不会使用代理go get -u -v test.fengyuwusong.cn 3.4. go.mod module 语句指定包的名字（路径） require 语句指定的依赖项模块 replace 语句可以替换依赖项模块 exclude 语句可以忽略依赖项模块 go.mod 文件样例 123456789101112131415module fengyuwusong.cn&#x2F;my&#x2F;thing &#x2F;&#x2F; 指明身份 模块中所有软件包导入前缀go 1.12&#x2F;&#x2F; 依赖包列表 不指定版本时 依赖所需最小版本require ( github.com&#x2F;some&#x2F;dependency v1.2.3 github.com&#x2F;another&#x2F;dependency&#x2F;v4 v4.0.0 &#x2F;&#x2F; indirect 意为间接使用)&#x2F;&#x2F; replace 替换本地路径 当一些包不想上传远程或拉不下来的时候可以使用replace example.com&#x2F;some&#x2F;dependency &#x3D;&gt; example.com&#x2F;some&#x2F;dependency v1.2.3 &#x2F;&#x2F; 替换为其他地址replace example.com&#x2F;original&#x2F;import&#x2F;path &#x3D;&gt; &#x2F;your&#x2F;forked&#x2F;import&#x2F;path &#x2F;&#x2F; 替换为本地路径exclude xxx.xx.com&#x2F;test &#x2F;&#x2F; 忽略此项依赖 很少使用 3.5. http支持目前go mod等导包相关操作并不支持http，但是有时公司的仓库并不支持https，这时候我们需要使用go get -u -v -insecure xxx导入此包。 参考文章Go 1.11 Modules 官方文档 go get命令——一键获取代码、编译并安装 Golang包管理工具之govendor的使用 【Golang】go get报错：fatal: could not read Username … terminal prompts disabled","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"go","slug":"go","permalink":"https://fengyuwsuong.cn/tags/go/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"govendor","slug":"govendor","permalink":"https://fengyuwsuong.cn/tags/govendor/"},{"name":"go mod","slug":"go-mod","permalink":"https://fengyuwsuong.cn/tags/go-mod/"},{"name":"包管理","slug":"包管理","permalink":"https://fengyuwsuong.cn/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"}]},{"title":"leetcode-38-Count and Say","slug":"leetcode-38-Count-and-Say","date":"2020-02-16T08:28:13.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2020/02/16/leetcode-38-Count-and-Say/","link":"","permalink":"https://fengyuwsuong.cn/2020/02/16/leetcode-38-Count-and-Say/","excerpt":"题目12345678910111213141516171819202122232425262728293031The count-and-say sequence is the sequence of integers with the first five terms as following:1. 12. 113. 214. 12115. 1112211 is read off as \"one 1\" or 11.11 is read off as \"two 1s\" or 21.21 is read off as \"one 2, then one 1\" or 1211.Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.Note: Each term of the sequence of integers will be represented as a string. Example 1:Input: 1Output: \"1\"Explanation: This is the base case.Example 2:Input: 4Output: \"1211\"Explanation: For n = 3 the term was \"21\" in which we have two groups \"2\" and \"1\", \"2\" can be read as \"12\" which means frequency = 1 and value = 2, the same way \"1\" is read as \"11\", so the answer is the concatenation of \"12\" and \"11\" which is \"1211\".来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-and-say著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目12345678910111213141516171819202122232425262728293031The count-and-say sequence is the sequence of integers with the first five terms as following:1. 12. 113. 214. 12115. 1112211 is read off as \"one 1\" or 11.11 is read off as \"two 1s\" or 21.21 is read off as \"one 2, then one 1\" or 1211.Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.Note: Each term of the sequence of integers will be represented as a string. Example 1:Input: 1Output: \"1\"Explanation: This is the base case.Example 2:Input: 4Output: \"1211\"Explanation: For n = 3 the term was \"21\" in which we have two groups \"2\" and \"1\", \"2\" can be read as \"12\" which means frequency = 1 and value = 2, the same way \"1\" is read as \"11\", so the answer is the concatenation of \"12\" and \"11\" which is \"1211\".来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-and-say著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路先理解题意： 1234567# 设函数为fn(x) 其本意为解释int类型每个数的个数和顺序fn(1) =&gt; \"1\" # 固定值返回1fn(2) =&gt; fn(fn(1)) =&gt; fn(\"1\") =&gt; \"11\" # 1个1fn(3) =&gt; fn(fn(2)) =&gt; fn(\"11\") =&gt; \"21\" # 2个1fn(4) =&gt; fn(fn(3)) =&gt; fn(\"21\") =&gt; \"1211\" # 1个2 1个1fn(5) =&gt; fn(fn(4)) =&gt; fn(\"1211\") =&gt; \"111221\" # 1个1 1个2 2个1... 故明显需使用递归来进行，找到递归出口并按照规则返回即可。 golang注意语法，string进行切片本质为[]rune{...} 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package easyimport ( \"bytes\" \"strconv\" \"testing\")/**The count-and-say sequence is the sequence of integers with the first five terms as following:1. 12. 113. 214. 12115. 1112211 is read off as \"one 1\" or 11.11 is read off as \"two 1s\" or 21.21 is read off as \"one 2, then one 1\" or 1211.Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.Note: Each term of the sequence of integers will be represented as a string.Example 1:Input: 1Output: \"1\"Explanation: This is the base case.Example 2:Input: 4Output: \"1211\"Explanation: For n = 3 the term was \"21\" in which we have two groups \"2\" and \"1\", \"2\" can be read as \"12\" which means frequency = 1 and value = 2, the same way \"1\" is read as \"11\", so the answer is the concatenation of \"12\" and \"11\" which is \"1211\".来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-and-say著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/func countAndSay(n int) string &#123; // 递归出口 if n == 1 &#123; return \"1\" &#125; // 上一个递归结果 lastRes := countAndSay(n - 1) var sameTimes, lastIndex int var res bytes.Buffer for i := 0; i &lt; len(lastRes); i++ &#123; if lastRes[i] == lastRes[lastIndex] &#123; sameTimes++ &#125; else &#123; res.WriteString(strconv.Itoa(sameTimes)) res.WriteRune(rune(lastRes[lastIndex])) sameTimes = 1 lastIndex = i &#125; &#125; if sameTimes != 0 &#123; res.WriteString(strconv.Itoa(sameTimes)) res.WriteRune(rune(lastRes[lastIndex])) &#125; return res.String()&#125;func TestCountAnySay(t *testing.T) &#123; println(countAndSay(5))&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"leetcode-35-Search Insert Position","slug":"leetcode-35-Search Insert Position","date":"2020-02-09T05:25:13.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2020/02/09/leetcode-35-Search Insert Position/","link":"","permalink":"https://fengyuwsuong.cn/2020/02/09/leetcode-35-Search%20Insert%20Position/","excerpt":"题目123456789101112131415161718192021222324Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You may assume no duplicates in the array.Example 1:Input: [1,3,5,6], 5Output: 2Example 2:Input: [1,3,5,6], 2Output: 1Example 3:Input: [1,3,5,6], 7Output: 4Example 4:Input: [1,3,5,6], 0Output: 0来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-insert-position著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目123456789101112131415161718192021222324Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You may assume no duplicates in the array.Example 1:Input: [1,3,5,6], 5Output: 2Example 2:Input: [1,3,5,6], 2Output: 1Example 3:Input: [1,3,5,6], 7Output: 4Example 4:Input: [1,3,5,6], 0Output: 0来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-insert-position著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路遍历比较即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package easyimport \"testing\"/**Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You may assume no duplicates in the array.Example 1:Input: [1,3,5,6], 5Output: 2Example 2:Input: [1,3,5,6], 2Output: 1Example 3:Input: [1,3,5,6], 7Output: 4Example 4:Input: [1,3,5,6], 0Output: 0来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-insert-position著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/func searchInsert(nums []int, target int) int &#123; if len(nums) == 0 &#123; return 0 &#125; for index, num := range nums &#123; if num == target &#123; return index &#125; if num &gt; target &#123; return index &#125; &#125; return len(nums)&#125;func TestSearchInsert(t *testing.T) &#123; println(searchInsert([]int&#123;1, 3, 5, 6&#125;, 7))&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"leetcode-28. Implement strStr()","slug":"leetcode-28-Implement strStr","date":"2020-02-08T12:16:13.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2020/02/08/leetcode-28-Implement strStr/","link":"","permalink":"https://fengyuwsuong.cn/2020/02/08/leetcode-28-Implement%20strStr/","excerpt":"题目123456789101112131415161718192021Implement strStr().Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.Example 1:Input: haystack = \"hello\", needle = \"ll\"Output: 2Example 2:Input: haystack = \"aaaaa\", needle = \"bba\"Output: -1Clarification:What should we return when needle is an empty string? This is a great question to ask during an interview.For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-strstr著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目123456789101112131415161718192021Implement strStr().Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.Example 1:Input: haystack = \"hello\", needle = \"ll\"Output: 2Example 2:Input: haystack = \"aaaaa\", needle = \"bba\"Output: -1Clarification:What should we return when needle is an empty string? This is a great question to ask during an interview.For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-strstr著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路双循环暴力解法。 kmp解法：相较于暴力解法更聪明，遇到特定字符时不会完全从头开始，而是遵从pat生成的next数组规则（即确认有限自动状态机）。如下图所示： 主要任务在于构建确认有限自动状态机，即上图中的跳转规则。创建next数组如下图所示： 伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class KMP &#123; private int[][] dp; private String pat; public KMP(String pat) &#123; this.pat = pat; int M = pat.length(); // dp[状态][字符] = 下个状态 dp = new int[M][256]; // base case dp[0][pat.charAt(0)] = 1; // 影子状态 X 初始为 0 int X = 0; // 构建状态转移图（稍改的更紧凑了） for (int j = 1; j &lt; M; j++) &#123; for (int c = 0; c &lt; 256; c++) &#123; // 等于重置状态 x 值 dp[j][c] = dp[X][c]; &#125; // 步进状态 dp[j][pat.charAt(j)] = j + 1; // 更新影子状态 等于为 dp[j][c] = dp[X][c]; 做下一步的映射准备 X = dp[X][pat.charAt(j)]; &#125; &#125; public int search(String txt) &#123; int M = pat.length(); int N = txt.length(); // pat 的初始态为 0 int j = 0; for (int i = 0; i &lt; N; i++) &#123; // 计算 pat 的下一个状态 j = dp[j][txt.charAt(i)]; // 到达终止态，返回结果 if (j == M) return i - M + 1; &#125; // 没到达终止态，匹配失败 return -1; &#125;&#125;/**作者：labuladong链接：https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。/ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package easyimport \"testing\"/**Implement strStr().Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.Example 1:Input: haystack = \"hello\", needle = \"ll\"Output: 2Example 2:Input: haystack = \"aaaaa\", needle = \"bba\"Output: -1Clarification:What should we return when needle is an empty string? This is a great question to ask during an interview.For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-strstr著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/// 暴力解func strStr(haystack string, needle string) int &#123; // 健壮性编写 if len(needle) == 0 &#123; return 0 &#125; if len(needle) &gt; len(haystack) &#123; return -1 &#125; var i, j int for i = 0; i &lt; len(haystack); i++ &#123; for j = 0; j &lt; len(needle); j++ &#123; if haystack[i+j] != needle[j] &#123; break &#125; &#125; if j == len(needle) &#123; return i &#125; // 剩余字符串长度小于needle长度则返回 if len(haystack)-i-1 &lt; len(needle) &#123; return -1 &#125; &#125; return -1&#125;func TestStrStr(t *testing.T) &#123; println(strStr(\"hello\", \"ll\")) println(strStr(\"aaaaa\", \"bba\")) println(strStr(\"aaaaa\", \"aa\")) println(strStr(\"mississippi\", \"issipi\"))&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"leetcode-27-Remove Element","slug":"leetcode-26-Remove Element","date":"2020-02-03T10:30:13.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2020/02/03/leetcode-26-Remove Element/","link":"","permalink":"https://fengyuwsuong.cn/2020/02/03/leetcode-26-Remove%20Element/","excerpt":"题目123456789101112131415161718192021222324252627282930313233343536373839404142Given an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.The order of elements can be changed. It doesn't matter what you leave beyond the new length.Example 1:Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn't matter what you leave beyond the returned length.Example 2:Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn't matter what values are set beyond the returned length.Clarification:Confused why the returned value is an integer but your answer is an array?Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.Internally you can think of this:// nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目123456789101112131415161718192021222324252627282930313233343536373839404142Given an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.The order of elements can be changed. It doesn't matter what you leave beyond the new length.Example 1:Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn't matter what you leave beyond the returned length.Example 2:Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn't matter what values are set beyond the returned length.Clarification:Confused why the returned value is an integer but your answer is an array?Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.Internally you can think of this:// nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路记录一个后置索引变量lastIndex, 当前序遍历到val时将该后置索引元素代替当前元素i，并后退i和lastIndex索引。当i==lastIndex时退出循环返回该变量即可。以下举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 初始化nums = [0, 1, 2, 2, 3, 0, 4, 2]val = 2lastIndex = 8 // 初始化为数组长度 // 第一次遍历i = 0 // 当前索引num = 0 // 当前元素nums = [0, 1, 2, 2, 3, 0, 4, 2]lastIndex = 8// 第二次遍历i = 1num = 1// 第三次遍历i = 2num = 2 // 与val相等 执行以下程序lastIndex--nums[i] = nums[lastIndex]i--// 此时变量nums = [0, 1, 2, 2, 3, 0, 4, 2]i = 1lastIndex = 7// 第四次遍历i = 2num = 2 // 与val相等 执行以下程序lastIndex--nums[i] = nums[lastIndex]i--// 此时变量nums = [0, 1, 4, 2, 3, 0, 2, 2]i = 1lastIndex = 6// 第五次遍历i = 2num = 4// 第六次遍历i = 3num = 2 // 与val相等 执行以下程序lastIndex--nums[i] = nums[lastIndex]i--// 此时变量nums = [0, 1, 4, 0, 3, 2, 2, 2]i = 2lastIndex = 5// 第七次遍历i = 3num = 0// 第八次遍历i = 4num = 3// 第九次遍历i = 5 // 与 lastIndex 相等 退出循环return lastIndex // 则可遍历结果为前5个 [0, 1, 4, 0, 3] 代码123456789101112131415161718192021222324252627282930313233343536373839404142package easyimport ( \"fmt\" \"testing\")func removeElement(nums []int, val int) int &#123; if len(nums) == 0 &#123; return -1 &#125; var lastIndex int = len(nums) for i := 0; i &lt; len(nums); i++ &#123; // 跳出循环条件 if lastIndex == i &#123; break &#125; // 相等则前后索引元素替换 lastIndex、i 后退重新遍历当前元素 if nums[i] == val &#123; lastIndex-- nums[i] = nums[lastIndex] i-- &#125; &#125; return lastIndex&#125;func TestRemoveElement(t *testing.T) &#123; f := func(nums []int, length int) &#123; println(length) for i := 0; i &lt; length; i++ &#123; fmt.Printf(\"%d=&gt;\", nums[i]) &#125; println() &#125; nums := []int&#123;0, 1, 2, 2, 3, 0, 4, 2&#125; length := removeElement(nums, 2) f(nums, length) nums = []int&#123;1&#125; length = removeElement(nums, 1) f(nums, length)&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"正则表达式学习笔记","slug":"正则表达式学习笔记","date":"2020-01-28T06:14:36.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2020/01/28/正则表达式学习笔记/","link":"","permalink":"https://fengyuwsuong.cn/2020/01/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"什么是正则表达式正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。","text":"什么是正则表达式正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。 1. 基本匹配最基础的匹配方式，如： 1&quot;the&quot; &#x3D;&gt; The fat cat sat on the mat. 即可找出句子中the这个单词。正则表达式大小写敏感，所以The不会匹配the。 2. 元字符正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍： 元字符 描述 . 实心点匹配任意单个字符除了换行符。 [ ] 字符种类。匹配方括号内的任意字符。 [^ ] 否定的字符种类。匹配除了方括号里的任意字符 * 匹配&gt;=0个重复的在*号之前的字符。 + 匹配&gt;=1个重复的+号前的字符。 ? 标记?之前的字符为可选. {n,m} 匹配num个大括号之间的字符 (n &lt;= num &lt;= m). (xyz) 字符集，匹配与 xyz 完全相等的字符串. | 或运算符，匹配符号前或后的字符. \\ 转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \\ ^ 从开始行开始匹配. $ 从末端开始匹配 下面开始举例说明。 2.1 点运算符 ..是元字符中最简单的例子。 .匹配任意单个字符，但不匹配换行符。 例如，表达式.ar匹配一个任意字符后面跟着是a和r的字符串。 \".ar\" => The car parked in the garage. 2.2 字符集 []字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中可使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式[Tt]he 匹配 the 和 The。 “[Tt]he” => The car parked in the garage. 方括号的句号就表示句号。 表达式 ar[.] 匹配 ar.字符串 \"ar[.]\" => A garage is a good place to park a car. 2.2.1 否定字符集[^]一般来说 ^ 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式[^c]ar 匹配一个后面跟着ar的除了c的任意字符。 “[^car]\" => The car parked in the garage. 2.3 重复次数后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。 2.3.1 *号*号匹配 在*之前的字符出现大于等于0次。 例如，表达式 a* 匹配0或更多个以a开头的字符。表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串。 \"[a-z]*\" => The car parked in the garage #21. *字符和.字符搭配可以匹配所有的字符.*。 *和表示匹配空格的符号\\s连起来用，如表达式\\s*cat\\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。 \"\\s*cat\\s*\" => The fat cat sat on the concatenation. 2.3.3 ? 号在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。例如，表达式 [T]?he 匹配字符串 he 和 The。 \"[T]he\" => The car is parked in the garage. \"[T]?he\" => The car is parked in the garage. 2.4 {} 号在正则表达式中 {} 是一个量词，常用来一个或一组字符可以重复出现的次数。例如， 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字。 \"[0-9]{2,3}\" => The number was 9.9997 but we rounded it off to 10.0. 我们可以省略第二个参数。例如，[0-9]{2,} 匹配至少两位 0~9 的数字。 \"[0-9]{2,}\" => The number was 9.9997 but we rounded it off to 10.0. 如果逗号也省略掉则表示重复固定的次数。例如，[0-9]{3} 匹配3位数字 \"[0-9]{3}\" => The number was 9.9997 but we rounded it off to 10.0. 2.5 (...) 特征标群特征标群是一组写在 (...) 中的子模式。例如之前说的 {} 是用来表示前面一个字符出现指定次数。但如果在 {} 前加入特征标群则表示整个标群内的字符重复 N 次。例如，表达式 (ab)* 匹配连续出现 0 或更多个 ab。 我们还可以在 () 中用或字符 | 表示或。例如，(c|g|p)ar 匹配 car 或 gar 或 par. \"(c|g|p)ar\" => The car is parked in the garage. 2.6 | 或运算符或运算符就表示或，用作判断条件。 例如 (T|t)he|car 匹配 (T|t)he 或 car。 \"(T|t)he|car\" => The car is parked in the garage. 2.7 转码特殊字符反斜线 \\ 在表达式中用于转码紧跟其后的字符。用于指定 { } [ ] / \\ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \\。 例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \\. 以下这个例子 \\.?是选择性匹配. \"(f|c|m)at\\.?\" => The fat cat sat on the mat. 2.8 锚点在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。 2.8.1 ^ 号^ 用来检查匹配的字符串是否在所匹配字符串的开头。 例如，在 abc 中使用表达式 ^a 会得到结果 a。但如果使用 ^b 将匹配不到任何结果。因为在字符串 abc 中并不是以 b 开头。 例如，^(T|t)he 匹配以 The 或 the 开头的字符串。 \"(T|t)he\" => The car is parked in the garage. \"^(T|t)he\" => The car is parked in the garage. 2.8.2 $ 号同理于 ^ 号，$ 号用来匹配字符是否是最后一个。 例如，(at\\.)$ 匹配以 at. 结尾的字符串。 \"(at\\.)\" => The fat cat. sat. on the mat. \"(at\\.)$\" => The fat cat. sat. on the mat. 3. 简写字符集正则表达式提供一些常用的字符集简写。如下: 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字或下划线或汉字或希腊或俄文字符等，等同于 `[a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于： [^\\w] \\d 匹配数字： [0-9] \\D 匹配非数字： [^\\d] \\s 匹配所有空格字符，等同于： [\\t\\n\\f\\r\\v] \\S 匹配所有非空格字符： [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF（等同于 \\r\\n），用来匹配 DOS 行终止符 4. 零宽度断言（前后预查）先行断言和后发断言都属于非捕获簇（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。 例如，我们想要获得所有跟在 $ 符号后的数字，我们可以使用正后发断言 (?&lt;=\\$)[0-9\\.]*。 这个表达式匹配 $ 开头，之后跟着 0,1,2,3,4,5,6,7,8,9,. 这些字符可以出现大于等于 0 次。 零宽度断言如下： 符号 描述 ?= 正先行断言-存在 ?! 负先行断言-排除 ?&lt;= 正后发断言-存在 ?&lt;! 负后发断言-排除 4.1 ?=... 正先行断言?=... 正先行断言，表示第一部分表达式之后必须跟着 ?=...定义的表达式。 返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=...)。 正先行断言的内容写在括号中的等号后面。 例如，表达式 (T|t)he(?=\\sfat) 匹配 The 和 the，在括号中我们又定义了正先行断言 (?=\\sfat) ，即 The 和 the 后面紧跟着 (空格)fat。 \"(T|t)he(?=\\sfat)\" => The fat cat sat on the mat. 4.2 ?!... 负先行断言负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。正先行断言 定义和 负先行断言 一样，区别就是 = 替换成 ! 也就是 (?!...)。 表达式 (T|t)he(?!\\sfat) 匹配 The 和 the，且其后不跟着 (空格)fat。 \"(T|t)he(?!\\sfat)\" => The fat cat sat on the mat. 4.3 ?&lt;= ... 正后发断言正后发断言 记作(?&lt;=...) 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。例如，表达式 (?&lt;=(T|t)he\\s)(fat|mat) 匹配 fat 和 mat，且其前跟着 The 或 the。 \"(?","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://fengyuwsuong.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"leetcode-26-Remove Duplicates from Sorted Array","slug":"leetcode-26-Remove Duplicates from Sorted Array","date":"2020-01-28T01:50:13.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2020/01/28/leetcode-26-Remove Duplicates from Sorted Array/","link":"","permalink":"https://fengyuwsuong.cn/2020/01/28/leetcode-26-Remove%20Duplicates%20from%20Sorted%20Array/","excerpt":"题目1234567891011121314151617181920212223242526272829303132333435363738Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.Example 1:Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn't matter what you leave beyond the returned length.Example 2:Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn't matter what values are set beyond the returned length.Clarification:Confused why the returned value is an integer but your answer is an array?Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.Internally you can think of this:// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目1234567891011121314151617181920212223242526272829303132333435363738Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.Example 1:Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn't matter what you leave beyond the returned length.Example 2:Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn't matter what values are set beyond the returned length.Clarification:Confused why the returned value is an integer but your answer is an array?Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.Internally you can think of this:// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路遍历数组即可即可，注意参数校验。 代码123456789101112131415161718192021222324252627282930package easyimport ( \"fmt\" \"testing\")func removeDuplicates(nums []int) int &#123; if len(nums) == 0 &#123; return 0 &#125; lastNum := nums[0] currentIndex := 1 for _, num := range nums &#123; if num &gt; lastNum &#123; nums[currentIndex] = num currentIndex++ lastNum = num &#125; &#125; return currentIndex&#125;func TestRemoveDuplicates(t *testing.T) &#123; nums := []int&#123;0, 0, 1, 1, 1, 2, 2, 3, 3, 4&#125; numsLen := removeDuplicates(nums) for i := 0; i &lt; numsLen; i++ &#123; fmt.Printf(\"=&gt;%v\", nums[i]) &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"leetcode-21-Merge Two Sorted Lists","slug":"leetcode-21-Merge Two Sorted Lists","date":"2020-01-27T03:17:13.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2020/01/27/leetcode-21-Merge Two Sorted Lists/","link":"","permalink":"https://fengyuwsuong.cn/2020/01/27/leetcode-21-Merge%20Two%20Sorted%20Lists/","excerpt":"题目123456789Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.Example:Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目123456789Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.Example:Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路遍历即可，注意参数校验。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Definition for singly-linked list.type ListNode struct &#123; Val int Next *ListNode&#125;// 循环遍历合并即可func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; // 参数健壮性编写 if l1 == nil &#123; return l2 &#125; if l2 == nil &#123; return l1 &#125; var mergeList *ListNode var currentNode *ListNode // 选取头结点 复用 l1 l2 地址 if l1.Val &lt; l2.Val &#123; mergeList = l1 l1 = l1.Next &#125; else &#123; mergeList = l2 l2 = l2.Next &#125; currentNode = mergeList for &#123; // 退出循环条件 if l1 == nil &#123; currentNode.Next = l2 break &#125; if l2 == nil &#123; currentNode.Next = l1 break &#125; // 比较大小 if l1.Val &lt; l2.Val &#123; currentNode.Next = l1 l1 = l1.Next currentNode = currentNode.Next continue &#125; currentNode.Next = l2 currentNode = currentNode.Next l2 = l2.Next &#125; return mergeList&#125;func TestMergeTwoLists(t *testing.T) &#123; l5 := &amp;ListNode&#123;16, nil&#125; l4 := &amp;ListNode&#123;8, l5&#125; l3 := &amp;ListNode&#123;4, l4&#125; l2 := &amp;ListNode&#123;2, l3&#125; l1 := &amp;ListNode&#123;1, l2&#125; ll3 := &amp;ListNode&#123;6, nil&#125; ll2 := &amp;ListNode&#123;3, ll3&#125; ll1 := &amp;ListNode&#123;1, ll2&#125; res := mergeTwoLists(l1, ll1) for &#123; if res == nil &#123; break &#125; fmt.Printf(\"=&gt;%v\", res.Val) res = res.Next &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"leetcode-20-Valid Parentheses","slug":"leetcode-20-Valid Parentheses","date":"2020-01-27T01:15:13.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2020/01/27/leetcode-20-Valid Parentheses/","link":"","permalink":"https://fengyuwsuong.cn/2020/01/27/leetcode-20-Valid%20Parentheses/","excerpt":"题目12345678910111213141516171819202122232425262728293031Given a string containing just the characters '(', ')', '&#123;', '&#125;', '[' and ']', determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Note that an empty string is also considered valid.Example 1:Input: \"()\"Output: trueExample 2:Input: \"()[]&#123;&#125;\"Output: trueExample 3:Input: \"(]\"Output: falseExample 4:Input: \"([)]\"Output: falseExample 5:Input: \"&#123;[]&#125;\"Output: true来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"题目12345678910111213141516171819202122232425262728293031Given a string containing just the characters '(', ')', '&#123;', '&#125;', '[' and ']', determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Note that an empty string is also considered valid.Example 1:Input: \"()\"Output: trueExample 2:Input: \"()[]&#123;&#125;\"Output: trueExample 3:Input: \"(]\"Output: falseExample 4:Input: \"([)]\"Output: falseExample 5:Input: \"&#123;[]&#125;\"Output: true来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答思路可使用栈的特点进行解答。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 使用栈的思路进行解答func isValid(s string) bool &#123; var stack []string // 自定义栈 for _, str := range s &#123; switch str &#123; case '(': fallthrough case '&#123;': fallthrough case '[': // 入栈 stack = append(stack, string(str)) break case ')': // 查看是否相等并出栈 if len(stack) == 0 &#123; return false &#125; ch := stack[len(stack)-1] if ch == \"(\" &#123; // 出栈 if len(stack) &gt; 1 &#123; stack = stack[0 : len(stack)-1] &#125; else &#123; stack = stack[0:0] &#125; break &#125; return false case '&#125;': // 查看是否相等并出栈 if len(stack) == 0 &#123; return false &#125; ch := stack[len(stack)-1] if ch == \"&#123;\" &#123; // 出栈 if len(stack) &gt; 1 &#123; stack = stack[0 : len(stack)-1] &#125; else &#123; stack = stack[0:0] &#125; break &#125; return false case ']': // 查看是否相等并出栈 if len(stack) == 0 &#123; return false &#125; ch := stack[len(stack)-1] if ch == \"[\" &#123; // 出栈 if len(stack) &gt; 1 &#123; stack = stack[0 : len(stack)-1] &#125; else &#123; stack = stack[0:0] &#125; break &#125; return false &#125; &#125; return len(stack) == 0&#125;func TestIsValid(t *testing.T) &#123; println(isValid(\"[&#123;&#123;&#125;&#125;]\"))&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"}]},{"title":"2019年个人总结","slug":"2019-summary","date":"2020-01-20T15:20:09.000Z","updated":"2022-08-26T08:54:09.904Z","comments":true,"path":"2020/01/20/2019-summary/","link":"","permalink":"https://fengyuwsuong.cn/2020/01/20/2019-summary/","excerpt":"每年都能看到师兄有在写博客的年终总结，列出一整年下来的收获与感悟，看了之后觉得很不错，自己也得到了许多的收获与感想。 于是乎便也有了想法想把自己每年的经历和想法记录下来，但是每次都是一打开草稿就不知从何下笔，毕竟距离上一次写作文好像是高考了吧🤣。 这次终于下定决心，无论写的再糟也要尝试一下，那么接下来就开始好好的对这一年进行总结梳理吧。","text":"每年都能看到师兄有在写博客的年终总结，列出一整年下来的收获与感悟，看了之后觉得很不错，自己也得到了许多的收获与感想。 于是乎便也有了想法想把自己每年的经历和想法记录下来，但是每次都是一打开草稿就不知从何下笔，毕竟距离上一次写作文好像是高考了吧🤣。 这次终于下定决心，无论写的再糟也要尝试一下，那么接下来就开始好好的对这一年进行总结梳理吧。 复盘总结去年目标由于去年没有好好进行总结和立下flag，所以没有一个特别好的参照标准，仔细想了想，去年这时候的我应该最迫切的想要实现的目标有这几个吧~ 好好做好实习工作, 努力转正 减肥 大学最后一年拿到奖学金 学会游泳 70% 毕业前来一次毕业旅行 通过英语六级 坚持写博客 5% 完成情况遗憾的是除了前三项后面的都没怎么好好完成~具体细节在下面在仔细说下吧。 毕业往年都是参加师兄师姐的毕业典礼，和他们一块拍毕业照。如今终于也轮到了自己，回顾大学的四年时光（其实感觉也就待了两年半，大三后半学期+大四一年基本都是在实习中度过的），感觉自己并没有好好珍惜这几年下来的人与事，最起码在大学期间我们宿舍四个人都没一起出去吃过一次饭😓。 其中值得纪念的有两件事： 在大学的最后一年生涯里，还是成功拿到了一次二等奖学金（前几年都是差一点~），成功薅到了一点学费的羊毛回来😂也是大学生涯里面为数不多的闪光点了吧； 在快要离开学校的最后一个月里和同学学了游泳（然而还是半吊子，并不能很长距离的换气游🤣），当时就特别后悔在大学仅能报四次的体育课里为啥没有学游泳，而是打了三个学期的乒乓球 + 一个学期的羽毛球，还好最后还是稍微弥补了这点遗憾。 而遗憾的事情就特别多了，比如没有好好学习英语，总是给自己找这个那个借口，买的英语六级试卷都没有好好做几篇，最后连六级的考试都没有回学校参加考试了；还有人际关系的维护和性格不成熟等等等… 最后一天离开学校 星空十周年： 感谢一路上来给予过我帮助的老师同学，还有星空这个大家庭，虽然大三和大四两年里没有接着任职，但是还是非常感谢它带我走入了编程的大门，认识了许多一起共事有趣的灵魂和可以作为人生道路学习榜样的师兄。谢谢你们👏 实习生到正式员工从18年6月到WPS进行实习，到19年7月转正，再到现在的2020年1月，满打满算其实已经在WPS里工作有一年半多了（当然实习的时候中间有很多时间回学校处理毕业相关事宜了），中间也经历了几个公司比较重要的节点，例如公司30周年、科创板上市成功。总的来说对公司和大佬们的领导也是具有归属和认同感的，感激公司和大佬的悉心栽培，在里面学到了很多技术知识和为人处世之道。最后也很感激大佬的信任和器重，拿到了卓越实习生并且最后成功转正。从实习生到正式员工，感觉自己肩上的担子也变重了，以后也会加倍努力不辜负大佬们的信任~ 新员工培训合照 优秀实习生 园区海滩，又安静人又少，超适合居住（我才一点都不羡慕呢~🍋🍋🍋） 减肥（跑步+keep+游泳）减肥的话其实是在下半年才算是开始认真对待起来，虽然上半年也偶尔有进行跑步，但是总的来说还是摄入比消耗的多，而且其实在上半年直到新员工培训的时候还是特别胖的，那个时间段朋友圈好友也还都评论胖的都不认识了😂，直到下半年国庆回家亲戚好友才说瘦了些，当时培训的小伙伴也说认不出我了（可能变丑了吧🤣）。 下半年很高兴认识了一块跑步锻炼的小伙伴，通过每天下班后约跑，还有晚饭少吃或不吃（直接吃水果代替，因为公司有下午茶，晚上有时候其实不是特别的饿，不太推荐不吃），所以整体下来还是比较有成效的，从19年1月算起到19年12月最后一天，一整年下来一共跑了109次，所以说做什么事其实都还是要靠毅力和持之以恒的决心。 中间也有做过一段时间的keep，下班回家也有做健身环大冒险，还有周末偶尔继续去游泳。生活上改变饮食习惯。目前还是有点小肚子，明年还是需要继续努力👏还有就是非常感谢超哥大佬，虽然我经常毒舌调侃你🤣 目前体重 去年体重 数码产品今年终于从实习生转为了正式员工，手里终于也再也不用紧巴巴的过日子了（可能还没经过社会主义的毒打），于是便大手大脚的购入了一堆设备🤣，真的是半毛钱都攒不下来，哎🙃 设备清单： 设备名 价格 入手时间 使用感想 iPad 2018 32GB 2288 2018/06/01 第一个入手的苹果设备，当初的使用感想忘记了，目前觉得有点鸡肋。现在还好可以使用mac的随航作为副屏来使用，偶尔追追剧看看PDF文档还是不错的。 apple pencil 亚太版 608 2018/06/10 当时入手主要是想培养画画的兴趣爱好，还有阅读PDF文档做笔记，可能当时在学校还是挺有用的，工作之后几乎没怎么使用了。 iPhone XR 128GB 6399 2018/12/12 由于宿舍三个都是用苹果手机，并且当时在体验到ipad的流畅程度之后，决心下一步手机入手iphone的，使用上来说的确无可挑剔，到现在也算使用了一年多一些了，也没有啥毛病，算是我用过时间算比较久的一台手机了🤣美中不足的是买完没多久苹果就价格大跳水，直接亏了好多。9月份给老妈也买了一台，4k多就能买到了，真是心碎~ AirPods2 1099 2019/07/05 最满意的电子设备之一，几乎无可挑剔。在苹果的生态之下完美切换各种设备，就是用了几个月价格也跳水了🤣 Appl Watch Series 5 2999 2019/10/08 当时跑步满了一百天，买给自己的一个礼物。功能上的确很不错，但是价格偏贵，而且一天一充，经常运动的人可以考虑，不大推荐。这个设备还买了AC+，怕不小心摔坏了，真是败家🙃 2019 16寸 MacBook Pro 15513 2019/12/07 目前买过的最贵的电子设备，刚开始不太习惯mac的操作逻辑，后面习惯了之后觉得还好，目前还在适应中，由于公司配了电脑所以使用频率稍低，后续会带到公司辅助使用。 港版Switch续航加强版 1899 2019/11/12 当时PDD折扣入手的，想着不买mbp买这个好了，最后还是没忍住，哎☹️不是现充非常不推荐入手，一个人玩单机游戏绝对会自闭的，没错，说的就是我😪适合过年过节回家和家人一块玩。考虑年后出手。 其他一堆游戏卡 xxxx xxxxx 手头中的游戏中最值得推荐的游戏有两个。1.「健身环大冒险」真正做到了娱乐和锻炼一起并行的游戏，非常适合一个人在家下班后锻炼，也适合全家一起玩小游戏 2.「塞尔达传说 荒野之息」游戏细节丰富，即使是两年后热度仍不减，不愧IGN 2017最佳游戏。 聊一聊苹果生态为什么会入了苹果的坑？主要是身边有一堆果吹，三个舍友用的都是iPhone，并且在这之前用的都是Android手机，所以想换一下看看是不是有他们吹的这么神奇，其结果就是入了几个设备之后就入了坑了😓目前也算是集齐了一套生态设备了，在这可以以我的使用角度简单聊一聊使用体验，首先隔空投递、handoff、随航的体验都非常不错，你在手机拍的一张照片、复制的一段文字，都可以无缝在mac上进行裁切、编辑。airpods可以对你手上的任何设备无缝切换。这种使用体验在之前的android阵营是从来没有体验过的。主要和最大的缺点就是贵，可能这是我的缺点吧☹️ 晒一张全家福： 爱情想了很久怎么描述，最后还是「遗憾」一词概况吧。 生活日常一个人在外工作之后经常多愁善感，虽然平时老是嘻嘻哈哈的，其实我内心还是一个极度悲观的人。所幸的是遇到许多积极乐观的小伙伴，才不至于这么自闭吧（ 不过好像也逐渐被我传染了🤣）。 印象深刻的是一次感冒发烧，以为睡一下觉就会好，强行撑到了周日晚上最后实在没办法了才去看。一个人在外还是多照顾好自己吧。 下半年的时候还培养了另一个习惯，记账。记录了自己的消费习惯和主要开销，以后再接再厉继续保持。 明年Flag 完全学会游泳，保持锻炼身体，减掉肚子的肥肉。早睡早起； 多读书，少刷B站（占用太多时间了）； 写Blog，坚持至少一周一篇； 坚持技术学习，如读开源项目源码&amp;学习热门知识的使用等，工作上更加努力； 来一次旅游，目前计划和舍友去看LOL S赛； 攒钱&amp;理财&amp;理性消费 (今年应该是不会再买任何电子设备了~)； 多积攒人际关系&amp;减少自己性格的恶劣点(毒舌&amp;yygq等~)； 培养列举计划清单习惯，规划好自己的时间。 以上计划会列出量化指标，例如减肥具体到减多少斤、读书读多少本等，希望在明年的年末总结的时候通通都能实现吧😋 2020年冲冲冲，奥利给！","categories":[{"name":"生活","slug":"生活","permalink":"https://fengyuwsuong.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"2019总结","slug":"2019总结","permalink":"https://fengyuwsuong.cn/tags/2019%E6%80%BB%E7%BB%93/"}]},{"title":"每日leetcode-13-罗马数字转整数","slug":"每日leetcode-13-罗马数字转整数","date":"2019-12-17T15:32:45.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2019/12/17/每日leetcode-13-罗马数字转整数/","link":"","permalink":"https://fengyuwsuong.cn/2019/12/17/%E6%AF%8F%E6%97%A5leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/","excerpt":"罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 123456789101112131415161718192021示例 1:输入: &quot;III&quot;输出: 3示例 2:输入: &quot;IV&quot;输出: 4示例 3:输入: &quot;IX&quot;输出: 9示例 4:输入: &quot;LVIII&quot;输出: 58解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4. 题目地址：两数之和","text":"罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 123456789101112131415161718192021示例 1:输入: &quot;III&quot;输出: 3示例 2:输入: &quot;IV&quot;输出: 4示例 3:输入: &quot;IX&quot;输出: 9示例 4:输入: &quot;LVIII&quot;输出: 58解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4. 题目地址：两数之和 思路依题意解即可 代码1234567891011121314151617181920212223242526272829303132333435363738func romanToInt(s string) int &#123; sum := 0 ints := make([]int, len(s)) for index, value := range s &#123; v := string2int(string(value)) ints[index] = v sum += v // 左边比右边小则进行 sum - 2 * ints[index-1] if index != 0 &amp;&amp; ints[index-1] &lt; v &#123; sum -= 2 * ints[index-1] &#125; &#125; return sum&#125;func string2int(s string) int &#123; switch s &#123; case \"I\": return 1 case \"V\": return 5 case \"X\": return 10 case \"L\": return 50 case \"C\": return 100 case \"D\": return 500 case \"M\": return 1000 &#125; return 0&#125;func Test_romanToInt(t *testing.T) &#123; println(romanToInt(\"MCMXCIV\"))&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"},{"name":"每日训练","slug":"每日训练","permalink":"https://fengyuwsuong.cn/tags/%E6%AF%8F%E6%97%A5%E8%AE%AD%E7%BB%83/"},{"name":"算法","slug":"算法","permalink":"https://fengyuwsuong.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"每日leetcode-回文数-9","slug":"每日leetcode-回文数-9","date":"2019-12-16T15:45:36.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2019/12/16/每日leetcode-回文数-9/","link":"","permalink":"https://fengyuwsuong.cn/2019/12/16/%E6%AF%8F%E6%97%A5leetcode-%E5%9B%9E%E6%96%87%E6%95%B0-9/","excerpt":"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 12345678910111213141516示例 1:输入: 121输出: true示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶:你能不将整数转为字符串来解决这个问题吗？ 题目地址：两数之和","text":"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 12345678910111213141516示例 1:输入: 121输出: true示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶:你能不将整数转为字符串来解决这个问题吗？ 题目地址：两数之和 思路同整数回转, 取目标数的每位并回转判断。负数及对10求余等于0的数（不包括0）表示最后一为一定为0, 必不可能是回文数。 最佳解法只要反转一半数字再判断是否相等，就知道是不是回文数。 123而当x小于保存的数时，即表示已经到达中间了e.g. x:12321 res:0 -&gt; x:12321 res:1 -&gt; x:1232 res:12 -&gt; x:123 &#x3D;&gt; res &#x3D; x&#x2F;10此时x&lt;&#x3D;res则跳出循环去判断，分奇数和偶数两种情况，奇数时res要整除10 代码1234567891011121314151617181920func isPalindrome(x int) bool &#123; if x &lt; 0 &#123; return false &#125; pre_x := x reverseNum := 0 for ; ; &#123; if x == 0 &#123; break &#125; reverseNum = reverseNum * 10 + x % 10 x /= 10 &#125; return pre_x == reverseNum&#125;func Test_isPalindrome(t *testing.T) &#123; print(isPalindrome(123321))&#125; 最佳解123456789101112131415161718func isPalindrome(x int) bool &#123; // 只要是负数，肯定不是回文数 // 若对十求余数为0，表明最后一位是0，肯定不是回文数 if x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0) &#123; return false &#125; res := 0 // 只要反转一半数字再判断是否相等，就知道是不是回文数 // 而当x小于保存的数时，即表示已经到达中间了 // e.g. x:12321 res:0 -&gt; x:12321 res:1 -&gt; x:1232 res:12 -&gt; x:123 =&gt; res = x/10 // 此时x&lt;=res则跳出循环去判断，分奇数和偶数两种情况，奇数时res要整除10 for x &gt; res &#123; tmp := x % 10 x /= 10 res = res*10 + tmp &#125; return x == res || x == res / 10&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"},{"name":"每日训练","slug":"每日训练","permalink":"https://fengyuwsuong.cn/tags/%E6%AF%8F%E6%97%A5%E8%AE%AD%E7%BB%83/"},{"name":"算法","slug":"算法","permalink":"https://fengyuwsuong.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"每日leetcode-整数翻转-7","slug":"每日leetcode-整数翻转-7","date":"2019-12-14T02:02:35.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2019/12/14/每日leetcode-整数翻转-7/","link":"","permalink":"https://fengyuwsuong.cn/2019/12/14/%E6%AF%8F%E6%97%A5leetcode-%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC-7/","excerpt":"给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 1234567891011示例 1:输入: 123输出: 321示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 题目链接：点击这里~","text":"给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 1234567891011示例 1:输入: 123输出: 321示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 题目链接：点击这里~ 思路循环求得每位数值并乘以反转后的指数即可, 注意数据范围溢出。 123456789101112131415161718192021222324func reverse(x int) int &#123; var res int for &#123; if x == 0 &#123; break &#125; res = res*10 + x%10 x /= 10 &#125; // 根据补码 最大值为除首位全是1 先取全1后右移首位为0 需转换为int类型 否则后续计算数值时不检验首位 const INT32_MAX = int(^uint32(0) &gt;&gt; 1) // 除首位外全是0 取最大值反码即可 const INT32_MIN = ^INT32_MAX println(INT32_MAX) println(INT32_MIN) if res &lt; INT32_MIN || res &gt; INT32_MAX &#123; return 0 &#125; return res&#125;func Test_reverseNumber(t *testing.T) &#123; println(reverse(123))&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"},{"name":"每日训练","slug":"每日训练","permalink":"https://fengyuwsuong.cn/tags/%E6%AF%8F%E6%97%A5%E8%AE%AD%E7%BB%83/"},{"name":"算法","slug":"算法","permalink":"https://fengyuwsuong.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"每日leetcode-两数之和-1","slug":"每日leetcode-两数之和-1","date":"2019-12-09T15:49:44.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2019/12/09/每日leetcode-两数之和-1/","link":"","permalink":"https://fengyuwsuong.cn/2019/12/09/%E6%AF%8F%E6%97%A5leetcode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-1/","excerpt":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例1: 12345给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 题目地址：两数之和","text":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例1: 12345给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 题目地址：两数之和 思路基于数组建立value-index 的hash表， 循环遍历判断 hashmap[target - num] 是否存在即可。 代码1234567891011121314151617181920212223242526package easyimport ( \"fmt\" \"testing\")func twoSum(nums []int, target int) []int &#123; // 以 value, index 建立哈希表 // 初始化时建立可避免重复值问题 如 [3, 3] 6 hashMap := make(map[int]int) // 循环哈希表查看是否存在对应索引 for index, value := range nums &#123; otherKey := target - value if otherIndex, has := hashMap[otherKey]; has &#123; return []int&#123;otherIndex, index&#125; &#125; hashMap[value] = index &#125; return []int&#123;&#125;&#125;func Test_main(t *testing.T) &#123; fmt.Printf(\"%v\\n\", twoSum([]int&#123;3, 3&#125;, 6))&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"},{"name":"每日训练","slug":"每日训练","permalink":"https://fengyuwsuong.cn/tags/%E6%AF%8F%E6%97%A5%E8%AE%AD%E7%BB%83/"},{"name":"算法","slug":"算法","permalink":"https://fengyuwsuong.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"每日leetcode-翻转字符串里的单词","slug":"每日leetcode-翻转字符串里的单词","date":"2019-01-15T14:14:52.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2019/01/15/每日leetcode-翻转字符串里的单词/","link":"","permalink":"https://fengyuwsuong.cn/2019/01/15/%E6%AF%8F%E6%97%A5leetcode-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/","excerpt":"给定一个字符串，逐个翻转字符串中的每个单词。 示例: 12输入: &quot;the sky is blue&quot;,输出: &quot;blue is sky the&quot;. 说明: 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 进阶: 请选用C语言的用户尝试使用 O(1) 空间复杂度的原地解法。 题目地址：这里~","text":"给定一个字符串，逐个翻转字符串中的每个单词。 示例: 12输入: &quot;the sky is blue&quot;,输出: &quot;blue is sky the&quot;. 说明: 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 进阶: 请选用C语言的用户尝试使用 O(1) 空间复杂度的原地解法。 题目地址：这里~ 思路：java暴力破解。 代码1234567891011121314151617181920public class 翻转字符串里的单词 &#123; public static String reverseWords(String s) &#123; // 健壮性判空 if (s.trim().isEmpty()) return \"\"; String[] ss = s.split(\" \"); StringBuilder sb = new StringBuilder(); for (int i = ss.length - 1; i &gt;= 0; i--) &#123; if (!ss[i].isEmpty())&#123; sb.append(ss[i]).append(\" \"); &#125; &#125; // 删除最后添加的空格 return sb.deleteCharAt(sb.length()-1).toString(); &#125; public static void main(String[] args) &#123; System.out.println(reverseWords(\" \")); &#125;&#125; 注意特殊值的判断。 官方最佳答案：123456789101112131415161718192021222324252627public class Solution &#123; public String reverseWords(String s) &#123; if(s.length()==0)return s; char[] ch=s.toCharArray(); char[] res=new char[ch.length]; int len=helper(ch,ch.length-1,res,0,0); return new String(res,0,len); &#125; private int helper(char[] ch,int r,char[] res,int l,int len)&#123; while(r&gt;=0&amp;&amp;ch[r]==' ')&#123; r--; &#125; if(r&lt;0)return Math.max(0,len-1); int rigth=r; while(r&gt;=0&amp;&amp;ch[r]!=' ')&#123; r--; &#125; len+=rigth-r+1; for(int left=r+1;left&lt;=rigth;left++,l++)&#123; res[l]=ch[left]; &#125; if(l&lt;res.length)&#123; res[l++]=' '; &#125; return helper(ch,r,res,l,len); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"},{"name":"每日训练","slug":"每日训练","permalink":"https://fengyuwsuong.cn/tags/%E6%AF%8F%E6%97%A5%E8%AE%AD%E7%BB%83/"},{"name":"算法","slug":"算法","permalink":"https://fengyuwsuong.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"每日leetcode-字符串相乘","slug":"每日leetcode-字符串相乘","date":"2018-12-27T15:02:31.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2018/12/27/每日leetcode-字符串相乘/","link":"","permalink":"https://fengyuwsuong.cn/2018/12/27/%E6%AF%8F%E6%97%A5leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/","excerpt":"给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 1234567示例 1:输入: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;输出: &quot;6&quot;示例 2:输入: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;输出: &quot;56088&quot; 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 题目链接：点击这里~","text":"给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 1234567示例 1:输入: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;输出: &quot;6&quot;示例 2:输入: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;输出: &quot;56088&quot; 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 题目链接：点击这里~ 思路由于 num1 和 num2 长度最大为 110，故两数相乘的长度最大 110 * 110 位，long 为8字节 所能表示的最大长度为 2^64，所能表示最大长度远远小于目标位数，故 将字符串转为int类型后在做运算在转回字符串的方法行不通。 研究乘法计算发现规律， 以 123 *456 = 56088 举例： 1 2 3 * 4 5 6 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 5 + 8 = 13 6 + 10 + 12 = 28 12 + 15 =27 18 40000 10000 + 3000 2000 + 800 200 + 70 10 + 8 40000 + 10000 3000 +2000 800 + 200 70 + 10 8 5 6 0 8 8 则可以通过逐位相乘在相加的形式完成大数的乘法运算。 代码123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public String multiply(String num1, String num2) &#123;int len1 = num1.length(); int len2 = num2.length(); // 获得最大位数建立数组 int[] res = new int[len1 + len2]; // 遍历计算每位对应的数值 从最低位开始 int n1, n2; for (int i = len1 - 1; i &gt;= 0; i--) &#123; n1 = num1.charAt(i) - '0'; for (int j = len2 - 1; j &gt;= 0; j--) &#123; n2 = num2.charAt(j) - '0'; res[i + j + 1] += n1 * n2; // 如果大于10则向前进位 if(res[i + j + 1] &gt;= 10 )&#123; res[i + j] += res[i + j + 1] / 10; res[i + j + 1] %= 10; &#125; &#125; &#125; // 将int数组转为字符串 StringBuilder stringBuffer = new StringBuilder(len1 + len2); boolean flag = true; for (int n : res)&#123; if(flag)&#123; if(n != 0)&#123; flag = false; &#125;else &#123; continue; &#125; &#125; stringBuffer.append(n); &#125; return stringBuffer.toString().isEmpty() ? \"0\" : stringBuffer.toString(); &#125;&#125; 难点：注意进位问题 官方最佳解答123456789101112131415161718192021222324252627class Solution &#123; public String multiply(String num1, String num2) &#123; if(num1.isEmpty() || num2.isEmpty() ||(num1.length() &#x3D;&#x3D; 1 &amp;&amp; num1.charAt(0) &#x3D;&#x3D; &#39;0&#39;) || (num2.length() &#x3D;&#x3D; 1 &amp;&amp; num2.charAt(0) &#x3D;&#x3D; &#39;0&#39;)) return &quot;0&quot;; int len1 &#x3D; num1.length(); int len2 &#x3D; num2.length(); int[] ans &#x3D; new int[len1 + len2 + 1]; for(int i &#x3D; 0 ; i &lt; len1;i++) &#123; int a &#x3D; num1.charAt(i) - &#39;0&#39;; for(int j &#x3D; 0; j &lt; len2; j++) &#123; int b &#x3D; num2.charAt(j) - &#39;0&#39;; ans[len1 + len2 - i - j - 2] +&#x3D; a * b ; &#125; &#125; StringBuffer res &#x3D; new StringBuffer(); for(int i &#x3D; 0; i &lt; len1 + len2 ;i++) &#123; res.append(ans[i] % 10); ans[i + 1] +&#x3D; ans[i] &#x2F; 10; &#125; String result &#x3D; res.reverse().toString(); if(result.startsWith(&quot;0&quot;)) result &#x3D; result.substring(1, len1 + len2); return result; &#125; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"},{"name":"每日训练","slug":"每日训练","permalink":"https://fengyuwsuong.cn/tags/%E6%AF%8F%E6%97%A5%E8%AE%AD%E7%BB%83/"},{"name":"算法","slug":"算法","permalink":"https://fengyuwsuong.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"机器学习入门(4)-降低损失","slug":"机器学习入门-4-降低损失","date":"2018-12-19T03:46:12.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2018/12/19/机器学习入门-4-降低损失/","link":"","permalink":"https://fengyuwsuong.cn/2018/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-4-%E9%99%8D%E4%BD%8E%E6%8D%9F%E5%A4%B1/","excerpt":"问题引出上一节有提到损失用于表示模型对于单个样本预测准确程度的一个数值，那么问题就转移到了我们该如何降低损失呢？ 迭代方法 图 1. 用于训练模型的迭代方法。","text":"问题引出上一节有提到损失用于表示模型对于单个样本预测准确程度的一个数值，那么问题就转移到了我们该如何降低损失呢？ 迭代方法 图 1. 用于训练模型的迭代方法。 在机器学习中，迭代方法的应用十分的普遍，他的逻辑是通过不停的尝试来降低损失值。 例如对于线性回归公式$$y’=b+w_1x_1$$b *和 *w1的初始值应该设置为什么比较好呢？ 事实证明初始值并不重要。我们可以随机选择值，不过我们还是选择采用以下这些无关紧要的值： b= 0 w1 = 0 假设第一个特征值是 10。将该特征值代入预测函数会得到以下结果： 12y&#39; &#x3D; 0 + 0(10)y&#39; &#x3D; 0 图中的“计算损失”部分是模型将要使用的损失函数。假设我们使用平方损失函数。损失函数将采用两个输入值： y’：模型对特征 x 的预测 y：特征 x 对应的正确标签。 这时需要进行的是图一中的 计算参数更新， 具体是计算该 b 和 w1 下的损失值，然后再生成新的 b 和 w1。 这个过程会持续迭代，直至算法发现损失可能是最低的模型参数。 收敛： 当在不断迭代的情况下，损失值不变或十分缓慢，这时可以说该模型已经收敛。 该怎么进行计算参数？在上面的迭代方法中，最重要的一步就是计算参数更新。那么该怎么计算参数直至模型收敛呢？ 对于回归问题而言，所产生的损失和 w1 的关系是个凸形的，即只有一个斜率为0的位置： 图 2. 回归问题产生的损失与权重图为凸形。 该斜率为 0 的地方即损失函数的收敛之处。 梯度下降法梯度下降法的第一个阶段是为 w1 选择一个起始值（起点）。起点并不重要；因此很多算法就直接将 w1 设为 0 或随机选择一个值。下图显示的是我们选择了一个稍大于 0 的起点： 图 3. 梯度下降法的起点。 然后，梯度下降法算法会计算损失曲线在起点处的梯度。简而言之，梯度是偏导数的矢量；它可以让您了解哪个方向距离目标“更近”或“更远”。请注意，损失相对于单个权重的梯度（如图 3 所示）就等于导数。 主要的数学理论之后再写博客介绍，此处涉及的有 导数、偏导数、梯度。 请注意，梯度是一个矢量，因此具有以下两个特征： 方向 大小 梯度始终指向损失函数中增长最为迅猛的方向。梯度下降法算法会沿着负梯度的方向走一步，以便尽快降低损失。 图 4. 梯度下降法依赖于负梯度。 为了确定损失函数曲线上的下一个点，梯度下降法算法会将梯度大小的一部分与起点相加，如下图所示： 图 5. 一个梯度步长将我们移动到损失曲线上的下一个点。 然后，梯度下降法会重复此过程，逐渐接近最低点。 学习速率学习速率： 决定迭代中下一个点的位置， 一般是梯度乘以学习速率。 超参数：编程人员在机器学习算法中用于调整的旋钮 学习速率不宜过大或过小。 随机梯度下降法批量： 用于在单次迭代中计算梯度的样本总数。 随机梯度下降法 (SGD) ： 每次只迭代计算一个随机样本的损失值，减少计算量。 小批量随机梯度下降法（小批量 SGD）： 每次只迭代计算小批量随机样本的损失值，小批量通常包含 10-1000 个随机选择的样本。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://fengyuwsuong.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://fengyuwsuong.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"损失","slug":"损失","permalink":"https://fengyuwsuong.cn/tags/%E6%8D%9F%E5%A4%B1/"},{"name":"迭代方法， 学习速率， 梯度下降","slug":"迭代方法，-学习速率，-梯度下降","permalink":"https://fengyuwsuong.cn/tags/%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%EF%BC%8C-%E5%AD%A6%E4%B9%A0%E9%80%9F%E7%8E%87%EF%BC%8C-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"}]},{"title":"机器学习入门(3)-线性回归&训练与损失","slug":"机器学习入门-3-线性回归-训练与损失","date":"2018-12-17T09:44:02.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2018/12/17/机器学习入门-3-线性回归-训练与损失/","link":"","permalink":"https://fengyuwsuong.cn/2018/12/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-3-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E8%AE%AD%E7%BB%83%E4%B8%8E%E6%8D%9F%E5%A4%B1/","excerpt":"人们早就知晓，相比凉爽的天气，蟋蟀在较为炎热的天气里鸣叫更为频繁。数十年来，专业和业余昆虫学者已将每分钟的鸣叫声和温度方面的数据编入目录。Ruth 阿姨将她喜爱的蟋蟀数据库作为生日礼物送给您，并邀请您自己利用该数据库训练一个模型，从而预测鸣叫声与温度的关系。 图 1. 每分钟的鸣叫声与温度（摄氏度）的关系。","text":"人们早就知晓，相比凉爽的天气，蟋蟀在较为炎热的天气里鸣叫更为频繁。数十年来，专业和业余昆虫学者已将每分钟的鸣叫声和温度方面的数据编入目录。Ruth 阿姨将她喜爱的蟋蟀数据库作为生日礼物送给您，并邀请您自己利用该数据库训练一个模型，从而预测鸣叫声与温度的关系。 图 1. 每分钟的鸣叫声与温度（摄氏度）的关系。 毫无疑问，此曲线图表明温度随着鸣叫声次数的增加而上升。鸣叫声与温度之间的关系是线性关系吗？是的，您可以绘制一条直线来近似地表示这种关系，如下所示： 图 2. 线性关系。 事实上，虽然该直线并未精确无误地经过每个点，但针对我们拥有的数据，清楚地显示了鸣叫声与温度之间的关系。只需运用一点代数知识，您就可以将这种关系写下来，如下所示：$$y=mx+b$$即一元一次方程。 其中： y 指的是温度（以摄氏度表示），即我们试图预测的值。 m 指的是直线的斜率。 x 指的是每分钟的鸣叫声次数，即输入特征的值。 b 指的是 y 轴截距。 按照机器学习的惯例，您需要写一个存在细微差别的模型方程式：$$y′=b+w_1x_1$$其中： y`指的是预测标签（理想输出值）。 b 指的是偏差（y 轴截距）。而在一些机器学习文档中，它称为 w0。 w1 指的是特征 1 的权重。权重与上文中用 m 表示的“斜率”的概念相同。 x1 指的是特征（已知输入项）。 要根据新的每分钟的鸣叫声值 x1 推断（预测）温度 y′，只需将 x1 值代入此模型即可。 下标（例如 w1 和 x1）预示着可以用多个特征来表示更复杂的模型。例如，具有三个特征的模型可以采用以下方程式：$$y′=b+w1x1+w2x2+w3x3$$ 训练与损失训练模型：通过有标签样本来学习（确定）所有权重和偏差的理想值。 损失： 一个表示对于单个样本而言模型预测的准确程度。如果模型完全准确，则损失为0，反之则越大。 经验风险最小化： 检查多个样本并尝试找出可最大限度地减少损失的模型。 训练模型的目的是从所有样本中找到一组平均损失“较小”的权重和偏差。 例如： 图 3. 左侧模型的损失较大；右侧模型的损失较小。 那么我们该如何定义损失呢？一般都是通过创建一个损失函数，以有意义的方式汇总个损失。 平方损失：接下来我们要看的线性回归模型使用的是一种称为平方损失（又称为 L2 损失）的损失函数。单个样本的平方损失如下： 1&#x3D; (实际值 - 预测值）^2 均方误差 (MSE) 指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量：$$MSE=\\frac{1}{N}\\sum_{(x,y)∈D}(y−prediction(x))$$其中： (x,y)指的是样本，其中 x 指的是模型进行预测时使用的特征集（例如，温度、年龄和交配成功率）。 y 指的是样本的标签（例如，每分钟的鸣叫次数）。 prediction(x) 指的是权重和偏差与特征集 x 结合的函数。 D 指的是包含多个有标签样本（即 (x,y)）的数据集。 N 指的是 D 中的样本数量。 虽然 MSE 常用于机器学习，但它既不是唯一实用的损失函数，也不是适用于所有情形的最佳损失函数。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://fengyuwsuong.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://fengyuwsuong.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"线性回归","slug":"线性回归","permalink":"https://fengyuwsuong.cn/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"name":"损失","slug":"损失","permalink":"https://fengyuwsuong.cn/tags/%E6%8D%9F%E5%A4%B1/"}]},{"title":"每日leetcode-最长公共前缀","slug":"每日leetcode-最长公共前缀","date":"2018-12-14T15:06:06.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2018/12/14/每日leetcode-最长公共前缀/","link":"","permalink":"https://fengyuwsuong.cn/2018/12/14/%E6%AF%8F%E6%97%A5leetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","excerpt":"编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 1234567示例 1:输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;示例 2:输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot; 说明: 所有输入只包含小写字母 a-z 。 题目链接：点击这里~","text":"编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 1234567示例 1:输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;示例 2:输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot; 说明: 所有输入只包含小写字母 a-z 。 题目链接：点击这里~ 思路该题可直接暴力破解，有横向和纵向两种思路： 先记录第一个字符串，然后以第一个字符串的值去匹配剩下的字符串，遇到不同的则截取匹配下一个。例如：字符串数组为 [&quot;abcde&quot;, &quot;abced&quot;, &quot;abbcde&quot;] 。则当第一个去匹配第二个字符串的时候遇到e和第一个值d不同。故截取剩余abc，同理abc与abb截取后得到ab。 依次取每个字符串的相同位置字符作对比，不同则返回。 代码采用横向对比解。 1234567891011121314151617181920212223242526public class 最长公共前缀 &#123; public static String longestCommonPrefix(String[] strs) &#123; // 代码健壮性判断 if(strs.length == 0)&#123; return \"\"; &#125; String res = strs[0]; int len; for(int i = 1; i &lt; strs.length; i++)&#123; len = Math.min(res.length(), strs[i].length()); // 避免aa 和 a 的情况 res = res.substring(0, len); for (int j = 0; j &lt; len; j++)&#123; if(strs[0].charAt(j)!=strs[i].charAt(j)) &#123; res = res.substring(0, j); break; &#125; &#125; &#125; return res; &#125; public static void main(String[] args) &#123; System.out.println(longestCommonPrefix(new String[]&#123;\"aa\", \"a\"&#125;)); &#125;&#125; 注意点： 需要做好代码健壮性，例如输入为 String[]{}。 特殊情况，例如 aa 和 a 的公共前缀为 a。需取最小值。 官方最佳答案采用了横向对比。 123456789101112131415161718192021222324class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) &#123; return \"\"; &#125; int shortest = strs[0].length(); for (int i = 1; i &lt; strs.length; i++) &#123; shortest = Math.min(shortest, strs[i].length()); &#125; String result = \"\"; for (int i = 0; i &lt; shortest; i++) &#123; char ch = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j++) &#123; if (strs[j].charAt(i) != ch) &#123; return result; &#125; &#125; result += ch; &#125; return result; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"},{"name":"每日训练","slug":"每日训练","permalink":"https://fengyuwsuong.cn/tags/%E6%AF%8F%E6%97%A5%E8%AE%AD%E7%BB%83/"},{"name":"算法","slug":"算法","permalink":"https://fengyuwsuong.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"机器学习入门(2)-机器学习主要术语","slug":"机器学习入门-2-机器学习主要术语","date":"2018-12-14T08:36:22.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2018/12/14/机器学习入门-2-机器学习主要术语/","link":"","permalink":"https://fengyuwsuong.cn/2018/12/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-2-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%BB%E8%A6%81%E6%9C%AF%E8%AF%AD/","excerpt":"监督式机器学习机器学习系统通过学习如何组合输入信息来对从未见过的数据做出有用的预测。 标签标签是要预测的事物，即线性回归中的 y 变量。例如未来某个股票的涨跌，图片的动物品种。 简单的说即你想要机器预测的内容。 特征特征是输入变量，即简单线性回归中的 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征，按如下方式指定：$${ x_1, x_2, … x_n }$$举例在识别垃圾邮件的时候，特征变量可能是： 电子邮件的内容 发件人地址 发件时段 标志词 等等…","text":"监督式机器学习机器学习系统通过学习如何组合输入信息来对从未见过的数据做出有用的预测。 标签标签是要预测的事物，即线性回归中的 y 变量。例如未来某个股票的涨跌，图片的动物品种。 简单的说即你想要机器预测的内容。 特征特征是输入变量，即简单线性回归中的 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征，按如下方式指定：$${ x_1, x_2, … x_n }$$举例在识别垃圾邮件的时候，特征变量可能是： 电子邮件的内容 发件人地址 发件时段 标志词 等等… 样本样本是指数据的特定实例：x。（我们采用粗体 x 表示它是一个矢量。）我们将样本分为以下两类： 有标签样本 无标签样本 有标签样本即同时包含标签和特征。即： 1labeled examples: &#123;features, label&#125;: (x, y) 我们使用有标签样本来训练模型。 无标签样本即只包含特征，没有具体标签的样本，我们需要使用训练好的模型来预测该样本的特征。 举例在识别垃圾邮件中， 我们明确知道是垃圾邮件或正常邮件的为有标签样本，不知道的为无标签样本。 模型模型定义了特征与标签之间的关系。例如，垃圾邮件检测模型可能会将某些特征与“垃圾邮件”紧密联系起来。我们来重点介绍一下模型生命周期的两个阶段： 训练表示创建或学习模型。也就是说，您向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。 推断表示将训练后的模型应用于无标签样本。也就是说，您使用训练后的模型来做出有用的预测 (y&#39;)。例如，在推断期间，您可以针对新的无标签样本预测其标签。 回归与分类回归模型可预测连续值。例如，回归模型做出的预测可回答的问题如下： 加利福尼亚州一栋房产的价值是多少？ 用户点击此广告的概率是多少？ 回归模型可以回答确切数值 分类模型可预测离散值。例如分类模型做出的预测可回答： 某个指定电子邮件是垃圾邮件还是非垃圾邮件？ 这是一张狗、猫还是仓鼠图片？ 分类模型可以回答二分问题","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://fengyuwsuong.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://fengyuwsuong.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"术语","slug":"术语","permalink":"https://fengyuwsuong.cn/tags/%E6%9C%AF%E8%AF%AD/"}]},{"title":"每日leetcode-无重复字符的最长子串","slug":"每日leetcode-字符串的排列","date":"2018-12-09T14:33:01.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2018/12/09/每日leetcode-字符串的排列/","link":"","permalink":"https://fengyuwsuong.cn/2018/12/09/%E6%AF%8F%E6%97%A5leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","excerpt":"给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 12345678示例1:输入: s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).示例2:输入: s1&#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidboaoo&quot;输出: False 注意： 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 题目地址：这里~","text":"给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 12345678示例1:输入: s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).示例2:输入: s1&#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidboaoo&quot;输出: False 注意： 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 题目地址：这里~ 思路由于字符串的长度最长为 10000， 故列出所有排列关系时间复杂度过高，我们需要转换思路，寻找其他办法。 由于排列的规则是任意字符串的随意排列，例如abb可以是abb、bab、bba， 那么我们可以观察发现只要 *字符串长度相等且每个字符的个数一致，则该字符串为原串的排列之一。 通过这个原则我们只需要计算 s1 字符串的长度及每个字母的个数即可。然后在 s2 中建立滑动窗口扫描符合的字符串。则该题的问题则变为实现一个滑动窗口。 代码12345678910111213141516171819202122232425262728293031import java.util.Arrays;public class 字符串的排列 &#123; public static boolean checkInclusion(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); // 建立字典并初始化 int[] dict1 = new int[26]; int[] dict2 = new int[26]; // 记录s1中每个字符的个数 for (char s : s1.toCharArray()) &#123; dict1[s - 'a']++; &#125; // 滑动窗口遍历s2 for (int i = 0; i &lt; len2; i++) &#123; // 由于是从0开始，故相等时窗口已经超出len1大小 if (i &gt;= len1) // 将窗口外的记录去除 dict2[s2.charAt(i - len1) - 'a']--; // 将新加入的纳入字典 dict2[s2.charAt(i) - 'a']++; // 判断两数组是否相等 if (Arrays.equals(dict1, dict2)) return true; &#125; return false; &#125;&#125; 官方最佳解法12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; long[] hash = &#123;77886, 51044, 75120, 93338, 63245, 84866, 70301, 19244, 37029, 95036, 62918, 79389, 52211, 69968, 14003, 56270, 20747, 64639, 26711, 95751, 32553, 14959, 81792, 41986, 75273, 99929,&#125;; if (s1.length() &gt; s2.length()) return false; if (s1.equals(s2)) return true; char[] map1 = s1.toCharArray(); char[] map2 = s2.toCharArray(); int cs1Hash = 0; int cs2Hash = 0; for (int i = 0; i &lt; s1.length(); ++i) &#123; cs1Hash += hash[map1[i] - 'a']; cs2Hash += hash[map2[i] - 'a']; &#125; if (cs1Hash == cs2Hash) return true; int len = s2.length() - s1.length(); for (int i = 0; i &lt; len; ++i) &#123; cs2Hash += hash[map2[i + s1.length()] - 'a'] - hash[map2[i] - 'a']; if (cs1Hash == cs2Hash) return true; &#125; return false; &#125;&#125; 这里的hash值应该是 任意个相加后不能相等与其中的一个值的（类似于加法的质数），然后就可以以这个值代替字典的遍历比较，从而使用int进行对比，进一步节省了时间复杂度。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"},{"name":"每日训练","slug":"每日训练","permalink":"https://fengyuwsuong.cn/tags/%E6%AF%8F%E6%97%A5%E8%AE%AD%E7%BB%83/"},{"name":"算法","slug":"算法","permalink":"https://fengyuwsuong.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"每日leetcode-无重复字符的最长子串","slug":"每日leetcode-无重复字符的最长子串","date":"2018-12-09T14:33:01.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2018/12/09/每日leetcode-无重复字符的最长子串/","link":"","permalink":"https://fengyuwsuong.cn/2018/12/09/%E6%AF%8F%E6%97%A5leetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 123456789101112131415示例 1:输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。示例 2:输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。示例 3:输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 题目链接：点击这里~","text":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 123456789101112131415示例 1:输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。示例 2:输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。示例 3:输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 题目链接：点击这里~ 思路使用Hash表建立一个简单的滑动窗口，并尽量扩大滑动窗口的长度。 代码变量说明 res 最大长度 left 上一次重复位置 data 哈希表 记录每个字符出现的位置 t 记录字符对应的ascii值 1234567891011121314151617181920212223class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; // 最大值 上一次起点 int res = 0, left = 0; // 记录上一次出现的位置, 如没出现则为0 int[] data = new int[256]; for (int i = 0; i &lt; s.length(); i++) &#123; // 该字符对应的ascii码 int t = s.charAt(i); if (data[t] == 0 || data[t] &lt; left) &#123; // 由于记录从1开始所以当前位置到起点大小为i-left+1 例如123456 总共有6-1+1个字符 res = Math.max(res, i - left + 1); &#125; else &#123; // 出现重复，重新记录left值 left = data[t]; &#125; // 从1开始 data[t] = i + 1; &#125; return res; &#125;&#125; 难点： Hash表用于记录每个字符出现的位置，如还没出现设为0。 Hash表需建立256位的空间，因为Ascii表功能表示256个字节，所以建立这么大才可以记录所有的字符。 需设定res, left两个变量来进行标记，res负责记录最大的值，left记录上一次出现重复的位置。 res增加的条件不单只是data[t] == 0 (尚未出现)， 还存在上次出现但是在left前面，所以并不算的情况，因此需加上判断data[t]&lt;left，例如abbca*，假设不加判断那么当 *i == 4 时， 由于a在data中已经存在值，故不会进入 if 中， 而是会进入else。 官方最佳答案12345678910111213public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; &#125; return ans; &#125;&#125; 将if-else更改为i = Math.max(index[s.charAt(j)], i);既达到效果也更加美观。 关于为什么要开始进行这个训练呢，其实是有挺多目的： 想通过这个方法保持每天写一点东西。 并且也掌握多一点面试算法相关的，好进行春招的准备。 多进行一些算法相关的学习也能保持住脑子的活跃，不用每天为了业务奔波。 等等。。。 于是就这么愉快的决定了，以后如果没什么事的话尽量每天做一道leetcode的题。 备注：关于算法的题目以后应该都会用Java来进行。由于时间紧迫，所以题目大多会采取直接看答案思路并自己编码。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/categories/leetcode/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://fengyuwsuong.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://fengyuwsuong.cn/tags/leetcode/"},{"name":"每日训练","slug":"每日训练","permalink":"https://fengyuwsuong.cn/tags/%E6%AF%8F%E6%97%A5%E8%AE%AD%E7%BB%83/"},{"name":"算法","slug":"算法","permalink":"https://fengyuwsuong.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"机器学习入门(1)-pandas库的使用","slug":"机器学习入门(1)-pandas库的使用","date":"2018-12-09T13:34:45.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2018/12/09/机器学习入门(1)-pandas库的使用/","link":"","permalink":"https://fengyuwsuong.cn/2018/12/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8(1)-pandas%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"pandas 是一种列存数据分析 API。它是用于处理和分析输入数据的强大工具，很多机器学习框架都支持将 pandas 数据结构作为输入。 官方文档：点这里~ 该系列机器学习是实践 谷歌机器学习教程做的笔记。","text":"pandas 是一种列存数据分析 API。它是用于处理和分析输入数据的强大工具，很多机器学习框架都支持将 pandas 数据结构作为输入。 官方文档：点这里~ 该系列机器学习是实践 谷歌机器学习教程做的笔记。 安装使用pip即可进行安装。 1pip install pandas 基本用法导入12345# coding=utf-8import pandasif __name__ == '__main__': print(pandas.__version__) 输出：0.23.4 基本数据结构 DataFrame: 关系型数据表格，包含多个行和已命名的列。（及类似关系型数据库或excel表） Series: 单一列。DataFrame 中包含一个或多个 Series，每个Series 均有一个名称。 创建Series、DataFrame对象 以list、dict 的方式创建： 1234city_names = pd.Series(['San Francisco', 'San Jose', 'Sacramento'])population = pd.Series([852469, 1015785, 485199])# 将两个series对象整合到dataframe中，如两个series长度不一致则会以NA/NaN填充pd.DataFrame(&#123;'city_name': city_names, 'population': population&#125;) 直接读取文件 12# 方式2 直接读取文件california_housing_dataframe = pd.read_csv(\"https://download.mlcc.google.cn/mledu-datasets/california_housing_train.csv\", sep=\",\") 访问数据123456789101112131415161718192021222324# coding=utf-8import pandas as pdif __name__ == '__main__': print(pd.__version__) # 构建series、dataframe对象 # 方式1 以list，dict的方式构建 city_names = pd.Series(['San Francisco', 'San Jose', 'Sacramento']) population = pd.Series([852469, 1015785, 485199]) # 将两个series对象整合到dataframe中，如两个series长度不一致则会以NA/NaN填充 california_housing_dataframe = pd.DataFrame(&#123;'city_name': city_names, 'population': population&#125;) # 方式2 直接读取文件 # california_housing_dataframe = pd.read_csv(\"https://download.mlcc.google.cn/mledu-datasets/california_housing_train.csv\", sep=\",\") print(\"========显示统计数据========\") print(california_housing_dataframe.describe()) print(\"========显示前几个记录========\") print(california_housing_dataframe.head()) print(\"========显示中值分布========\") print(california_housing_dataframe.hist('population')) 输出： 1234567891011121314151617180.23.4&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;显示统计数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; populationcount 3.000000e+00mean 7.844843e+05std 2.717477e+05min 4.851990e+0525% 6.688340e+0550% 8.524690e+0575% 9.341270e+05max 1.015785e+06&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;显示前几个记录&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; city_name population0 San Francisco 8524691 San Jose 10157852 Sacramento 485199&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;显示中值分布&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;[[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000594CBA8&gt;]] 访问数据直接以 dict/list 的方式 访问数据即可。 1234567891011121314def access_data(): \"\"\" 访问数据 :return: \"\"\" city_names = ['San Francisco', 'San Jose', 'Sacramento'] population = [852469, 1015785, 485199] cities = pd.DataFrame(&#123;'City name': city_names, 'Population': population&#125;) # 直接以list/dict的操作即可 print(type(cities['City name'])) print(cities['City name']) print(type(cities[\"City name\"][1])) print(cities[\"City name\"][1]) 输出： 1234567&lt;class &#39;pandas.core.series.Series&#39;&gt;0 San Francisco1 San Jose2 SacramentoName: City name, dtype: object&lt;class &#39;str&#39;&gt;San Jose 操作数据可直接对 Series/DataFrame 运算。或应用Series.apply()方法，例如： 123456789101112131415161718192021222324def operate_data(): \"\"\" 操作数据 :return: \"\"\" city_names = pd.Series(['San Francisco', 'San Jose', 'Sacramento']) population = pd.Series([852469, 1015785, 485199]) # 可直接向Series应用python基本运算命令 print(population / 1000) # 可应用于Numpy做参数运算 print(np.log(population)) # Series.apply函数 参数 接受lambda函数 # 例如 创建一个population超过100000的新Series new_series = population.apply(lambda val: val &gt; 100000) # 修改DataFrames对象 cities = dict() cities['Population'] = population cities['Area square miles'] = pd.Series([46.87, 176.53, 97.92]) cities['Population density'] = cities['Population'] / cities['Area square miles'] print(cities) 输出： 1234567891011121314151617180 852.4691 1015.7852 485.199dtype: float640 13.6558921 13.8311722 13.092314dtype: float64&#123;&#39;Population&#39;: 0 8524691 10157852 485199dtype: int64, &#39;Area square miles&#39;: 0 46.871 176.532 97.92dtype: float64, &#39;Population density&#39;: 0 18187.9453811 5754.1777602 4955.055147dtype: float64&#125; 索引Series 和 DataFrame 对象也定义了 index 属性，该属性会向每个 Series 项或 DataFrame 行赋一个标识符值。 例如： 12345678910111213141516171819202122def data_index(): \"\"\" 数据索引demo :return: \"\"\" # 模拟创建cities对象 temp = dict() temp['Population'] = pd.Series([852469, 1015785, 485199]) temp['Area square miles'] = pd.Series([46.87, 176.53, 97.92]) temp['Name'] = pd.Series(['San Francisco', 'San Jose', 'Sacramento']) cities = pd.DataFrame(temp) # 默认情况下，在构造时，pandas 会赋可反映源数据顺序的索引值。索引值在创建后是稳定的 # 也就是说，它们不会因为数据重新排序而发生改变。 print(cities['Name'].index) print(cities.index) # 可使用reindex方法手动重新排序 print(cities.reindex([2, 0, 1])) # 利用numpy random.permutation方法重新随机排序 print(cities.reindex(np.random.permutation(cities.index))) 输出： 12345678910RangeIndex(start&#x3D;0, stop&#x3D;3, step&#x3D;1)RangeIndex(start&#x3D;0, stop&#x3D;3, step&#x3D;1) Population Area square miles Name2 485199 97.92 Sacramento0 852469 46.87 San Francisco1 1015785 176.53 San Jose Population Area square miles Name2 485199 97.92 Sacramento1 1015785 176.53 San Jose0 852469 46.87 San Francisco 练习1通过添加一个新的布尔值列（当且仅当以下两项均为 True 时为 True）修改 cities 表格： 城市以圣人命名。 城市面积大于 50 平方英里。 注意：布尔值 Series 是使用“按位”而非传统布尔值“运算符”组合的。例如，执行逻辑与时，应使用 &amp;，而不是 and。 提示：“San” 在西班牙语中意为 “saint”。 答案： 12345678910111213141516171819202122def exe_1(): \"\"\" 练习 1 通过添加一个新的布尔值列（当且仅当以下两项均为 True 时为 True）修改 cities 表格： 城市以San命名。 城市面积大于 50 平方英里。 注意：布尔值 Series 是使用“按位”而非传统布尔值“运算符”组合的。例如，执行逻辑与时，应使用 &amp;，而不是 and。 提示：\"San\" 在西班牙语中意为 \"saint\"。 :return: \"\"\" # 模拟创建cities对象 temp = dict() temp['Population'] = pd.Series([852469, 1015785, 485199]) temp['Area square miles'] = pd.Series([46.87, 176.53, 97.92]) temp['Name'] = pd.Series(['San Francisco', 'San Jose', 'Sacramento']) cities = pd.DataFrame(temp) # 使用apply函数创建该列 cities[\"wide and with san\"] = cities['Name'].apply(lambda name: name.startswith('San')) &amp; (cities['Area square miles'] &gt; 50) print(cities) 注意点： (cities[‘Area square miles’] &gt; 50) 必须要用括号包起来，不然判别就变成 cities[‘Name’].apply(lambda name: name.startswith(‘San’)) &amp; cities[‘Area square miles’] &gt; 50 导致错误。 输出： 123456 Population ... wide and with san0 852469 ... False1 1015785 ... True2 485199 ... False[3 rows x 4 columns] 练习 2reindex 方法允许使用未包含在原始 DataFrame 索引值中的索引值。请试一下，看看如果使用此类值会发生什么！您认为允许此类值的原因是什么？ 12345678910111213141516def exe_2(): \"\"\" 练习 2 reindex 方法允许使用未包含在原始 DataFrame 索引值中的索引值。 请试一下，看看如果使用此类值会发生什么！您认为允许此类值的原因是什么？ :return: \"\"\" # 模拟创建cities对象 temp = dict() temp['Population'] = pd.Series([852469, 1015785, 485199]) temp['Area square miles'] = pd.Series([46.87, 176.53, 97.92]) temp['Name'] = pd.Series(['San Francisco', 'San Jose', 'Sacramento']) cities = pd.DataFrame(temp) # 目前只有三组数据索引: 0 1 2，假设操作索引 2 以上的数据 print(cities.reindex([4, 0, 1, 3])) 输出： 12345 Population Area square miles Name4 NaN NaN NaN0 852469.0 46.87 San Francisco1 1015785.0 176.53 San Jose3 NaN NaN NaN 解释： 如果您的 reindex 输入数组包含原始 DataFrame 索引值中没有的值，reindex 会为此类“丢失的”索引添加新行，并在所有对应列中填充 NaN 值。 这种行为是可取的，因为索引通常是从实际数据中提取的字符串（请参阅 pandas reindex 文档，查看索引值是浏览器名称的示例）。 在这种情况下，如果允许出现“丢失的”索引，您将可以轻松使用外部列表重建索引，因为您不必担心会将输入清理掉。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://fengyuwsuong.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fengyuwsuong.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"pandas","slug":"pandas","permalink":"https://fengyuwsuong.cn/tags/pandas/"},{"name":"机器学习","slug":"机器学习","permalink":"https://fengyuwsuong.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"第一篇博客","slug":"第一篇博客","date":"2018-12-09T10:05:02.000Z","updated":"2022-08-26T08:54:09.908Z","comments":true,"path":"2018/12/09/第一篇博客/","link":"","permalink":"https://fengyuwsuong.cn/2018/12/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"为什么要重新搭建博客其实在之前就已经有自己用java写过一个的博客系统，并且也有在csdn中写博客。但是发现还是这个比较方便美观，所以还是决定迁移到这里来啦。 Flag每周至少写一篇博客吧~","categories":[{"name":"生活","slug":"生活","permalink":"https://fengyuwsuong.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://fengyuwsuong.cn/tags/%E7%94%9F%E6%B4%BB/"},{"name":"随笔","slug":"随笔","permalink":"https://fengyuwsuong.cn/tags/%E9%9A%8F%E7%AC%94/"}]}]}